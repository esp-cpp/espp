# If you want to use mypy or pyright, you may have to ignore some errors, like below:

# mypy: disable-error-code="type-arg"

from typing import overload, List

NumberType = (int, float, np.number)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:base_component.hpp>    ####################



class BaseComponent:
    """/ Base class for all components
    / Provides a logger and some basic logging configuration
    """
    def get_name(self) -> str:
        """/ Get the name of the component
        / \return A const reference to the name of the component
        / \note This is the tag of the logger
        """
        pass

    def set_log_tag(self, tag: std.string_view) -> None:
        """/ Set the tag for the logger
        / \param tag The tag to use for the logger
        """
        pass

    def get_log_level(self) -> Logger.Verbosity:
        """/ Get the log level for the logger
        / \return The verbosity level of the logger
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def set_log_level(self, level: Logger.Verbosity) -> None:
        """/ Set the log level for the logger
        / \param level The verbosity level to use for the logger
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def set_log_verbosity(self, level: Logger.Verbosity) -> None:
        """/ Set the log verbosity for the logger
        / \param level The verbosity level to use for the logger
        / \note This is a convenience method that calls set_log_level
        / \sa set_log_level
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def get_log_verbosity(self) -> Logger.Verbosity:
        """/ Get the log verbosity for the logger
        / \return The verbosity level of the logger
        / \note This is a convenience method that calls get_log_level
        / \sa get_log_level
        / \sa Logger::Verbosity
        / \sa Logger::get_verbosity
        """
        pass

    def set_log_rate_limit(self, rate_limit: std.chrono.duration<float>) -> None:
        """/ Set the rate limit for the logger
        / \param rate_limit The rate limit to use for the logger
        / \note Only calls to the logger that have _rate_limit suffix will be rate limited
        / \sa Logger::set_rate_limit
        """
        pass


####################    </generated_from:base_component.hpp>    ####################


####################    <generated_from:color.hpp>    ####################



class Rgb:
    """*
     * @brief Class representing a color using RGB color space.

    """
    r: float = float(0)  #/< Red value ∈ [0, 1]
    g: float = float(0)  #/< Green value ∈ [0, 1]
    b: float = float(0)  #/< Blue value ∈ [0, 1]

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, r: float, g: float, b: float) -> None:
        """*
           * @brief Construct an Rgb object from the provided rgb values.
           * @note If provided values outside the range [0,1], it will rescale them to
           *       be within the range [0,1] by dividing by 255.
           * @param r Floating point value for the red channel, should be in range [0,
           *        1]
           * @param g Floating point value for the green channel, should be in range
           *        [0, 1]
           * @param b Floating point value for the blue channel, should be in range
           *        [0, 1]

        """
        pass

    @overload
    def __init__(self, rgb: Rgb) -> None:
        """*
           * @brief Copy-construct an Rgb object from the provided object.
           * @note If provided values outside the range [0,1], it will rescale them to
           *       be within the range [0,1] by dividing by 255.
           * @param rgb Rgb struct containing the values to copy.

        """
        pass

    @overload
    def __init__(self, hsv: Hsv) -> None:
        """*
           * @brief Construct an Rgb object from the provided Hsv object.
           * @note This calls hsv.rgb() on the provided object, which means fthat
           *       invalid HSV data (not in the ranges [0,360], [0,1], and [0,1])
           *       could lead to bad RGB data. The Rgb constructor will automatically
           *       convert the values to be in the proper range, but the perceived
           *       color will be changed.
           * @param hsv Hsv object to copy.

        """
        pass


    def __add__(self, rhs: Rgb) -> Rgb:
        """*
           * @brief Perform additive color blending (averaging)
           * @param rhs Other color to add to this color to create the resultant color
           * @return Resultant color from blending this color with the \p rhs color.

        """
        pass

    def __iadd__(self, rhs: Rgb) -> Rgb:
        """*
           * @brief Perform additive color blending (averaging)
           * @param rhs Other color to add to this color

        """
        pass

    def __eq__(self, rhs: Rgb) -> bool:
        pass

    def __ne__(self, rhs: Rgb) -> bool:
        pass

    def hsv(self) -> Hsv:
        """*
           * @brief Get a HSV representation of this RGB color.
           * @return An HSV object containing the HSV representation.

        """
        pass

class Hsv:
    """*
     * @brief Class representing a color using HSV color space.

    """
    h: float = float(0)  #/< Hue ∈ [0, 360]
    s: float = float(0)  #/< Saturation ∈ [0, 1]
    v: float = float(0)  #/< Value ∈ [0, 1]

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, h: float, s: float, v: float) -> None:
        """*
           * @brief Construct a Hsv object from the provided values.
           * @param h Hue - will be clamped to be in range [0, 360]
           * @param s Saturation - will be clamped to be in range [0, 1]
           * @param v Value - will be clamped to be in range [0, 1]

        """
        pass

    @overload
    def __init__(self, hsv: Hsv) -> None:
        """*
           * @brief Copy-construct the Hsv object
           * @param hsv Object to copy from.

        """
        pass

    @overload
    def __init__(self, rgb: Rgb) -> None:
        """*
           * @brief Construct Hsv object from Rgb object. Calls rgb.hsv() to perform
           *        the conversion.
           * @param rgb The Rgb object to convert and copy.

        """
        pass


    def __eq__(self, rhs: Hsv) -> bool:
        pass

    def __ne__(self, rhs: Hsv) -> bool:
        pass

    def rgb(self) -> Rgb:
        """*
           * @brief Get a RGB representation of this HSV color.
           * @return An RGB object containing the RGB representation.

        """
        pass

# namespace espp

####################    </generated_from:color.hpp>    ####################


####################    <generated_from:csv.hpp>    ####################




class __csv_documentation__:
    """*
     * @brief Comma Separated Value (CSV) reader/writer convenience wrapper around
     *        <a href="https://github.com/p-ranav/csv2">p-ranav/csv2</a> which
     *        exposes csv2::Reader and csv2::Writer classes for managing efficient
     *        (lazy-loaded) parsing and serizaliztion of human-readable
     *        CSV-formatted data.
     *
     * @note This class does not really exist or do anything, but it's the only
     *       way I could figure out how to get this documentation built into the
     *       system :(
     *
     * \section csv_ex1 CSV Reader Example
     * \snippet csv_example.cpp csv reader example
     * \section csv_ex2 Complex CSV Writer Example
     * \snippet csv_example.cpp csv writer example

    """
    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:csv.hpp>    ####################


####################    <generated_from:event_manager.hpp>    ####################



class EventManager:
    """*
     * @brief Singleton class for managing events. Provides mechanisms for
     *        anonymous publish / subscribe interactions - enabling one to one,
     *        one to many, many to one, and many to many data distribution with
     *        loose coupling and low overhead. Each topic runs a thread for that
     *        topic's subscribers, executing all the callbacks in sequence and
     *        then going to sleep again until new data is published.
     *
     * @note In c++ objects, it's recommended to call the
     *       add_publisher/add_subscriber functions in the class constructor and
     *       then to call the remove_publisher/remove_subscriber functions in the
     *       class destructor.
     *
     * @note It is recommended (unless you are only interested in events and not
     *       data or are only needing to transmit actual strings) to use a
     *       serialization library (such as espp::serialization - which wraps
     *       alpaca) to serialize your data structures to string when publishing
     *       and then deserialize your data from string in the subscriber
     *       callbacks.
     *
     * \section event_manager_ex1 Event Manager Example
     * \snippet event_manager_example.cpp event manager example

    """

    @staticmethod
    def get() -> EventManager:
        """*
           * @brief Get the singleton instance of the EventManager.
           * @return A reference to the EventManager singleton.

        """
        pass


    def add_publisher(self, topic: str, component: str) -> bool:
        """*
           * @brief Register a publisher for \p component on \p topic.
           * @param topic Topic name for the data being published.
           * @param component Name of the component publishing data.
           * @return True if the publisher was added, False if it was already
           *         registered for that component.

        """
        pass

    @overload
    def add_subscriber(
        self,
        topic: str,
        component: str,
        callback: EventManager.event_callback_fn,
        stack_size_bytes: int = 8192
        ) -> bool:
        """*
           * @brief Register a subscriber for \p component on \p topic.
           * @param topic Topic name for the data being subscribed to.
           * @param component Name of the component publishing data.
           * @param callback The event_callback_fn to be called when receicing data on
           *        \p topic.
           * @param stack_size_bytes The stack size in bytes to use for the subscriber
           * @note The stack size is only used if a subscriber is not already registered
           *       for that topic. If a subscriber is already registered for that topic,
           *       the stack size is ignored.
           * @return True if the subscriber was added, False if it was already
           *         registered for that component.

        """
        pass

    @overload
    def add_subscriber(
        self,
        topic: str,
        component: str,
        callback: EventManager.event_callback_fn,
        task_config: Task.BaseConfig
        ) -> bool:
        """*
           * @brief Register a subscriber for \p component on \p topic.
           * @param topic Topic name for the data being subscribed to.
           * @param component Name of the component publishing data.
           * @param callback The event_callback_fn to be called when receicing data on
           *        \p topic.
           * @param task_config The task configuration to use for the subscriber.
           * @note The task_config is only used if a subscriber is not already
           *       registered for that topic. If a subscriber is already registered for
           *       that topic, the task_config is ignored.
           * @return True if the subscriber was added, False if it was already
           *         registered for that component.

        """
        pass

    def publish(self, topic: str, data: List[int]) -> bool:
        """*
           * @brief Publish \p data on \p topic.
           * @param topic Topic to publish data on.
           * @param data Data to publish, within a vector container.
           * @return True if \p data was successfully published to \p topic, False
           *         otherwise. Publish will not occur (and will return False) if
           *         there are no subscribers for this topic.

        """
        pass

    def remove_publisher(self, topic: str, component: str) -> bool:
        """*
           * @brief Remove \p component's publisher for \p topic.
           * @param topic The topic that \p component was publishing on.
           * @param component The component for which the publisher was registered.
           * @return True if the publisher was removed, False if it was not
           *         registered.

        """
        pass

    def remove_subscriber(self, topic: str, component: str) -> bool:
        """*
           * @brief Remove \p component's subscriber for \p topic.
           * @param topic The topic that \p component was subscribing to.
           * @param component The component for which the subscriber was registered.
           * @return True if the subscriber was removed, False if it was not
           *         registered.

        """
        pass


####################    </generated_from:event_manager.hpp>    ####################


####################    <generated_from:file_system.hpp>    ####################





class FileSystem:
    """/ @brief File system class
    / @details
    / This class is a singleton and should be accessed via the get() method.
    / The class is responsible for mounting the file system and providing
    / access to the file system. It is configured via the menuconfig system and will
    / use the partition with the label specified in the menuconfig. The partition
    / must be formatted with the LittleFS file system. The file system is mounted
    / at the root directory of the partition such that all files will be stored
    / under the path "/<partition_label>/".
    / @see get_partition_label()
    /
    / The class provides methods to get the amount of free, used and total space
    / on the file system. It also provides a method to get a human readable string
    / for a byte size.
    /
    / \section fs_ex1 File System Info Example
    / \snippet file_system_example.cpp file_system info example
    / \section fs_ex2 File System POSIX / NEWLIB Example
    / \snippet file_system_example.cpp file_system posix example
    / \section fs_ex3 File System Info std::filesystem Example
    / \snippet file_system_example.cpp file_system std filesystem example
    """

    @staticmethod
    def human_readable(bytes: int) -> str:
        """/ @brief Get a human readable string for a byte size
        / @details
        / This method returns a human readable string for a byte size.
        / It is copied from the example on the page:
        / https://en.cppreference.com/w/cpp/filesystem/file_size
        / @param bytes The byte size
        / @return The human readable string
        """
        pass


    @staticmethod
    def get_mount_point() -> str:
        """/ @brief Get the mount point
        / @details
        / The mount point is the root directory of the file system.
        / It is the root directory of the partition with the partition label.
        / @see get_root_path()
        / @return The mount point
        """
        pass

    @staticmethod
    def get_root_path() -> std.filesystem.path:
        """/ @brief Get the root path
        / @details
        / The root path is the root directory of the file system.
        / @see get_mount_point()
        / @return The root path
        """
        pass

    @staticmethod
    @overload
    def to_string(permissions: std.filesystem.perms) -> str:
        """/ @brief Convert file permissions to a string
        / @details This method converts file permissions to a string in the format "rwxrwxrwx".
        / @param permissions The file permissions
        / @return The file permissions as a string
        """
        pass

    @staticmethod
    @overload
    def to_string(time: time_t) -> str:
        """/ @brief Convert a time_t to a string
        / @details This method converts a time_t to a string in the format "Jan 01 00:00".
        / @param time The time_t to convert
        / @return The time as a string
        """
        pass

    @staticmethod
    def get() -> FileSystem:
        """/ @brief Access the singleton instance of the file system
        / @return Reference to the file system instance
        """
        pass

    class ListConfig:
        """/ @brief Config for listing the contents of a directory
        / @details
        / This struct is used to configure the output of the list_directory() method.
        / It contains boolean values for each of the fields to include in the output.
        """
        type: bool = True             #/< The type of the file (directory, file, etc.)
        permissions: bool = True      #/< The permissions of the file
        number_of_links: bool = True  #/< The number of links to the file
        owner: bool = True            #/< The owner of the file
        group: bool = True            #/< The group of the file
        size: bool = True             #/< The size of the file
        date_time: bool = True        #/< The date and time of the file
        recursive: bool = False       #/< Whether to list the contents of subdirectories
        def __init__(
            self,
            type: bool = True,
            permissions: bool = True,
            number_of_links: bool = True,
            owner: bool = True,
            group: bool = True,
            size: bool = True,
            date_time: bool = True,
            recursive: bool = False
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    @overload
    def __init__(self, param_0: FileSystem) -> None:
        pass
    @overload
    def __init__(self, param_0: FileSystem) -> None:
        pass

    def get_free_space(self) -> int:
        """/ @brief Get the amount of free space on the file system
        / @return The amount of free space in bytes
        """
        pass

    def get_total_space(self) -> int:
        """/ @brief Get the total amount of space on the file system
        / @return The total amount of space in bytes
        """
        pass

    def get_used_space(self) -> int:
        """/ @brief Get the amount of used space on the file system
        / @return The amount of used space in bytes
        """
        pass

    def get_file_time_as_string(self, path: std.filesystem.path) -> str:
        """/ @brief Get the time of a file as a string
        / @details This method gets the time of a file as a string in the format "Jan 01 00:00".
        / @param path The path to the file
        / @return The time of the file as a string
        / @see file_time_to_string()
        """
        pass

    def get_files_in_path(
        self,
        path: std.filesystem.path,
        include_directories: bool = False,
        recursive: bool = False
        ) -> List[std.filesystem.path]:
        """/ @brief Get a vector of files in a directory
        / @details This method returns a vector of paths to the files in a directory.
        / @param path The path to the directory
        / @param include_directories Whether to include directories in the output
        / @param recursive Whether to include files in subdirectories
        / @return A vector of paths to the files in the directory
        """
        pass

    def remove(self, path: std.filesystem.path, ec: std.error_code) -> bool:
        """/ @brief Completely remove a file or directory (including contents)
        / @details This method removes a file or directory and all of its contents.
        /          If the path is a directory, it will iterate over the contents
        /          and remove them recursively. If the path is a file, it will
        /          remove the file. If the path does not exist, it will return False.
        / @param path The path to the file or directory
        / @param ec The error code to set if an error occurs
        / @return Whether the file or directory was successfully removed
        """
        pass

    def remove_contents(self, path: std.filesystem.path, ec: std.error_code) -> bool:
        """/ @brief Remove the contents of a directory, but not the directory itself
        / @details This method removes the contents of a directory, but not the
        /          directory itself. If the path is not a directory, it will return
        /          False. If the path does not exist, it will return False. If the
        /          path is a directory, it will iterate over the contents and remove
        /          them recursively.
        / @param path The path to the directory
        / @param ec The error code to set if an error occurs
        / @return Whether the contents of the directory were successfully removed
        """
        pass

    @overload
    def list_directory(
        self,
        path: std.filesystem.path,
        config: FileSystem.ListConfig,
        prefix: str = ""
        ) -> str:
        """/ @brief List the contents of a directory
        / @details
        / This method lists the contents of a directory. It returns a string
        / containing the contents of the directory. The contents are formatted
        / according to the config. The config is a struct with boolean values
        / for each of the fields to include in the output. The fields are:
        / - type: The type of the file (directory, file, etc.)
        / - permissions: The permissions of the file
        / - number_of_links: The number of links to the file
        / - owner: The owner of the file
        / - group: The group of the file
        / - size: The size of the file
        / - date_time: The date and time of the file
        / - recursive: Whether to list the contents of subdirectories
        / @param path The path to the directory
        / @param config The config for the output
        / @param prefix The prefix to use for the output
        / @return The contents of the directory
        """
        pass

    @overload
    def list_directory(
        self,
        path: str,
        config: FileSystem.ListConfig,
        prefix: str = ""
        ) -> str:
        """/ @brief List the contents of a directory
        / @details
        / This method lists the contents of a directory. It returns a string
        / containing the contents of the directory. The contents are formatted
        / according to the config. The config is a struct with boolean values
        / for each of the fields to include in the output. The fields are:
        / - type: The type of the file (directory, file, etc.)
        / - permissions: The permissions of the file
        / - number_of_links: The number of links to the file
        / - owner: The owner of the file
        / - group: The group of the file
        / - size: The size of the file
        / - date_time: The date and time of the file
        / - recursive: Whether to list the contents of subdirectories
        / @param path The path to the directory
        / @param config The config for the output
        / @param prefix The prefix to use for the output
        / @return The contents of the directory
        """
        pass

    #  ------------------------------------------------------------------------
    #      <template specializations for function to_time_t>
    @staticmethod
    def to_time_t_filesystem_file_time_type(
        tp: std.filesystem.file_time_type
        ) -> std.time_t:
        """/ Function to convert a time_point to a time_t.
        / \details This function converts a time_point to a time_t. This function
        /     is needed because the standard library does not provide a function to
        /     convert a time_point to a time_t (until c++20 but support seems lacking
        /     on esp32). This function is taken from
        /     https://stackoverflow.com/a/61067330
        / \tparam TP The type of the time_point.
        / \param tp The time_point to convert.
        / \return The time_t.
        """
        pass
    #      </template specializations for function to_time_t>
    #  ------------------------------------------------------------------------


####################    </generated_from:file_system.hpp>    ####################


####################    <generated_from:ftp_server.hpp>    ####################





class FtpServer:
    """/ \brief A class that implements a FTP server."""
    def __init__(
        self,
        ip_address: std.string_view,
        port: int,
        root: std.filesystem.path
        ) -> None:
        """/ \brief A class that implements a FTP server.
        / \note The IP Address is not currently used to select the right
        /       interface, but is instead passed to the FtpClientSession so that
        /       it can be used in the PASV command.
        / \param ip_address The IP address to listen on.
        / \param port The port to listen on.
        / \param root The root directory of the FTP server.
        """
        pass


    def start(self) -> bool:
        """/ \brief Start the FTP server.
        / Bind to the port and start accepting connections.
        / \return True if the server was started, False otherwise.
        """
        pass

    def stop(self) -> None:
        """/ \brief Stop the FTP server."""
        pass


####################    </generated_from:ftp_server.hpp>    ####################


####################    <generated_from:bezier.hpp>    ####################



# namespace espp
####################    </generated_from:bezier.hpp>    ####################


####################    <generated_from:fast_math.hpp>    ####################


def square(f: float) -> float:
    """*
     * @brief Simple square of the input.
     * @param f Value to square.
     * @return The square of f (f*f).

    """
    pass

def cube(f: float) -> float:
    """*
     * @brief Simple cube of the input.
     * @param f Value to cube.
     * @return The cube of f (f*f*f).

    """
    pass

def fast_sqrt(value: float) -> float:
    """*
     * @brief Fast square root approximation.
     * @note Using https://reprap.org/forum/read.php?147,219210 and
     *       https://en.wikipedia.org/wiki/Fast_inverse_square_root
     * @param value Value to take the square root of.
     * @return Approximation of the square root of value.

    """
    pass

#  ------------------------------------------------------------------------
#      <template specializations for function sgn>
def sgn_int(x: int) -> int:
    """*
     * @brief Get the sign of a number (+1, 0, or -1)
     * @param x Value to get the sign of
     * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0

    """
    pass


def sgn_float(x: float) -> int:
    """*
     * @brief Get the sign of a number (+1, 0, or -1)
     * @param x Value to get the sign of
     * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0

    """
    pass
#      </template specializations for function sgn>
#  ------------------------------------------------------------------------

def lerp(a: float, b: float, t: float) -> float:
    """*
     * @brief Linear interpolation between two values.
     * @param a First value.
     * @param b Second value.
     * @param t Interpolation factor in the range [0, 1].
     * @return Linear interpolation between a and b.

    """
    pass

def inv_lerp(a: float, b: float, v: float) -> float:
    """*
     * @brief Compute the inverse lerped value.
     * @param a First value (usually the lower of the two).
     * @param b Second value (usually the higher of the two).
     * @param v Value to inverse lerp (usually a value between a and b).
     * @return Inverse lerp value, the factor of v between a and b in the range [0,
     *         1] if v is between a and b, 0 if v == a, or 1 if v == b. If a == b,
     *         0 is returned. If v is outside the range [a, b], the value is
     *         extrapolated linearly (i.e. if v < a, the value is less than 0, if v
     *         > b, the value is greater than 1).

    """
    pass

def piecewise_linear(points: std.vector<Tuple[float, float>], x: float) -> float:
    """*
     * @brief Compute the piecewise linear interpolation between a set of points.
     * @param points Vector of points to interpolate between. The vector should be
     *               sorted by the first value in the pair. The first value in the
     *               pair is the x value and the second value is the y value. The x
     *               values should be unique. The function will interpolate between
     *               the points using linear interpolation. If x is less than the
     *               first x value, the first y value is returned. If x is greater
     *               than the last x value, the last y value is returned. If x is
     *               between two x values, the y value is interpolated between the
     *               two y values.
     * @param x Value to interpolate at. Should be a value from the first
     *          distribution of the points (the domain). If x is outside the domain
     *          of the points, the value returned will be clamped to the first or
     *          last y value.
     * @return Interpolated value at x.

    """
    pass

def round(x: float) -> int:
    """*
     * @brief Round x to the nearest integer.
     * @param x Floating point value to be rounded.
     * @return Nearest integer to x.

    """
    pass

def fast_ln(x: float) -> float:
    """*
     * @brief fast natural log function, ln(x).
     * @note This speed hack comes from:
     *   https://gist.github.com/LingDong-/7e4c4cae5cbbc44400a05ba650623
     * @param x Value to take the natural log of.
     * @return ln(x)

    """
    pass


def fast_sin(angle: float) -> float:
    """*
     * @brief Fast approximation of sin(angle) (radians).
     * @note \p Angle must be in the range [0, 2PI].
     * @param angle Angle in radians [0, 2*PI]
     * @return Approximation of sin(value)

    """
    pass

def fast_cos(angle: float) -> float:
    """*
     * @brief Fast approximation of cos(angle) (radians).
     * @note \p Angle must be in the range [0, 2PI].
     * @param angle Angle in radians [0, 2*PI]
     * @return Approximation of cos(value)

    """
    pass

####################    </generated_from:fast_math.hpp>    ####################


####################    <generated_from:gaussian.hpp>    ####################


class Gaussian:
    """*
     * @brief Implements a gaussian function
     *        \f$y(t)=\alpha\exp(-\frac{(t-\beta)^2}{2\gamma^2})\f$.
     * @details Alows you to store the alpha, beta, and gamma coefficients as well
     *          as update them dynamically.
     *
     * \section gaussian_ex1 Example
     * \snippet math_example.cpp gaussian example

    """
    class Config:
        """*
           * @brief Configuration structure for initializing the gaussian.

        """
        gamma: float        #/< Slope of the gaussian, range [0, 1]. 0 is more of a thin spike from 0 up to
        #/< max output (alpha), 1 is more of a small wave around the max output (alpha).
        alpha: float = 1.0  #/< Max amplitude of the gaussian output, defautls to 1.0.
        beta: float = 0.5   #/< Beta value for the gaussian, default to be symmetric at 0.5 in range [0,1].
        def __init__(
            self,
            gamma: float = float(),
            alpha: float = 1.0,
            beta: float = 0.5
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass


    def gamma(self, g: float) -> None:
        """*
           * @brief Set / Update the gamma (shape) value.
           * @param g New gamma (shape) to use.

        """
        pass

    @overload
    def alpha(self) -> float:
        """*
           * @brief Get the currently configured alpha (scaling) value.
           * @return The current alpha (scaler) value.

        """
        pass

    @overload
    def alpha(self, a: float) -> None:
        """*
           * @brief Set / Update the alpha (scaling) value.
           * @param a New alpha (scaler) to use.

        """
        pass

    @overload
    def beta(self) -> float:
        """*
           * @brief Get the currently configured beta (shifting) value.
           * @return The current beta (shifter) value [0, 1].

        """
        pass

    @overload
    def beta(self, b: float) -> None:
        """*
           * @brief Set / Update the beta (shifting) value.
           * @param b New beta (shifter) to use.

        """
        pass

    def at(self, t: float) -> float:
        """*
           * @brief Evaluate the gaussian at \p t.
           * @param t The evaluation parameter, [0, 1].
           * @return The gaussian evaluated at \p t.

        """
        pass

    def __call__(self, t: float) -> float:
        """*
           * @brief Evaluate the gaussian at \p t.
           * @note Convienience wrapper around the at() method.
           * @param t The evaluation parameter, [0, 1].
           * @return The gaussian evaluated at \p t.

        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:gaussian.hpp>    ####################


####################    <generated_from:range_mapper.hpp>    ####################





def unmap(v: T) -> T:
    """*
       * @brief Unmap a value \p v from the configured output range (centered,
       *        default [-1,1]) back into the input distribution.
       * @param T&v Value from the centered output distribution.
       * @return Value within the input distribution.

    """
    pass



# namespace espp

####################    </generated_from:range_mapper.hpp>    ####################


####################    <generated_from:vector2d.hpp>    ####################


#  ------------------------------------------------------------------------
#      <template specializations for class Vector2d>
class Vector2d_int:  # Python specialization for Vector2d<int>
    """*
     * @brief Container representing a 2 dimensional vector.
     *
     * Provides getters/setters, index operator, and vector / scalar math
     * utilities.
     *
     * \section vector_ex1 Example
     * \snippet math_example.cpp vector2 example

    """
    @overload
    def __init__(self, x: int = T(0), y: int = T(0)) -> None:
        """*
           * @brief Constructor for the vector, defaults to 0,0.
           * @param x The starting X value.
           * @param y The starting Y value.

        """
        pass

    @overload
    def __init__(self, other: Vector2d) -> None:
        """*
           * @brief Vector copy constructor.
           * @param other Vector to copy.

        """
        pass


    def magnitude(self) -> int:
        """*
           * @brief Returns vector magnitude: ||v||.
           * @return The magnitude.

        """
        pass

    def magnitude_squared(self) -> int:
        """*
           * @brief Returns vector magnitude squared: ||v||^2.
           * @return The magnitude squared.

        """
        pass

    @overload
    def x(self) -> int:
        """*
           * @brief Getter for the x value.
           * @return The current x value.

        """
        pass

    @overload
    def x(self, v: int) -> None:
        """*
           * @brief Setter for the x value.
           * @param v New value for \c x.

        """
        pass

    @overload
    def y(self) -> int:
        """*
           * @brief Getter for the y value.
           * @return The current y value.

        """
        pass

    @overload
    def y(self, v: int) -> None:
        """*
           * @brief Setter for the y value.
           * @param v New value for \c y.

        """
        pass

    def __lt__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __le__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __eq__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __ge__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __gt__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass

    def __eq__(self, other: Vector2d) -> bool:
        """*
           * @brief Equality operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return True if the vectors are equal, False otherwise.

        """
        pass

    def __getitem__(self, index: int) -> int:
        """*
           * @brief Index operator for vector elements.
           * @note Returns a mutable reference to the element.
           * @param index The index to return.
           * @return Mutable reference to the element at \p index.

        """
        pass

    @overload
    def __neg__(self) -> Vector2d:
        """*
           * @brief Negate the vector.
           * @return The new vector which is the negative.

        """
        pass

    @overload
    def __sub__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return a new vector which is the provided vector subtracted from
           *        this vector.
           * @param rhs The vector to subtract from this vector.
           * @return Resultant vector subtraction.

        """
        pass

    def __isub__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return the provided vector subtracted from this vector.
           * @param rhs The vector to subtract from this vector.
           * @return Resultant vector subtraction.

        """
        pass

    def __add__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return a new vector, which is the addition of this vector and the
           *        provided vector.
           * @param rhs The vector to add to this vector.
           * @return Resultant vector addition.

        """
        pass

    def __iadd__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return the vector added with the provided vector.
           * @param rhs The vector to add to this vector.
           * @return Resultant vector addition.

        """
        pass

    def __mul__(self, v: int) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, multiplied by the provided
           *        value.
           * @param v Value the vector should be multiplied by.
           * @return Resultant scaled vector.

        """
        pass

    def __imul__(self, v: int) -> Vector2d:
        """*
           * @brief Return the vector multiplied by the provided value.
           * @param v Value the vector should be scaled by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __truediv__(self, v: int) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, divided by the provided
           *        value.
           * @param v Value the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __itruediv__(self, v: int) -> Vector2d:
        """*
           * @brief Return the vector divided by the provided value.
           * @param v Value the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __truediv__(self, v: Vector2d) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, divided by the provided
           *        vector value. Scales x and y independently.
           * @param v Vector values the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __itruediv__(self, v: Vector2d) -> Vector2d:
        """*
           * @brief Return the vector divided by the provided vector values.
           * @param v Vector of values the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    def dot(self, other: Vector2d) -> T:
        """*
           * @brief Dot product of this vector with another vector.
           * @param other The second vector
           * @return The dot product (x1*x2 + y1*y2)

        """
        pass

    def normalized(self) -> Vector2d:
        """*
           * @brief Return normalized (unit length) version of the vector.
           * @return The normalized vector.

        """
        pass




class Vector2d_float:  # Python specialization for Vector2d<float>
    """*
     * @brief Container representing a 2 dimensional vector.
     *
     * Provides getters/setters, index operator, and vector / scalar math
     * utilities.
     *
     * \section vector_ex1 Example
     * \snippet math_example.cpp vector2 example

    """
    @overload
    def __init__(self, x: float = T(0), y: float = T(0)) -> None:
        """*
           * @brief Constructor for the vector, defaults to 0,0.
           * @param x The starting X value.
           * @param y The starting Y value.

        """
        pass

    @overload
    def __init__(self, other: Vector2d) -> None:
        """*
           * @brief Vector copy constructor.
           * @param other Vector to copy.

        """
        pass


    def magnitude(self) -> float:
        """*
           * @brief Returns vector magnitude: ||v||.
           * @return The magnitude.

        """
        pass

    def magnitude_squared(self) -> float:
        """*
           * @brief Returns vector magnitude squared: ||v||^2.
           * @return The magnitude squared.

        """
        pass

    @overload
    def x(self) -> float:
        """*
           * @brief Getter for the x value.
           * @return The current x value.

        """
        pass

    @overload
    def x(self, v: float) -> None:
        """*
           * @brief Setter for the x value.
           * @param v New value for \c x.

        """
        pass

    @overload
    def y(self) -> float:
        """*
           * @brief Getter for the y value.
           * @return The current y value.

        """
        pass

    @overload
    def y(self, v: float) -> None:
        """*
           * @brief Setter for the y value.
           * @param v New value for \c y.

        """
        pass

    def __lt__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __le__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __eq__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __ge__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __gt__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass

    def __eq__(self, other: Vector2d) -> bool:
        """*
           * @brief Equality operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return True if the vectors are equal, False otherwise.

        """
        pass

    def __getitem__(self, index: int) -> float:
        """*
           * @brief Index operator for vector elements.
           * @note Returns a mutable reference to the element.
           * @param index The index to return.
           * @return Mutable reference to the element at \p index.

        """
        pass

    @overload
    def __neg__(self) -> Vector2d:
        """*
           * @brief Negate the vector.
           * @return The new vector which is the negative.

        """
        pass

    @overload
    def __sub__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return a new vector which is the provided vector subtracted from
           *        this vector.
           * @param rhs The vector to subtract from this vector.
           * @return Resultant vector subtraction.

        """
        pass

    def __isub__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return the provided vector subtracted from this vector.
           * @param rhs The vector to subtract from this vector.
           * @return Resultant vector subtraction.

        """
        pass

    def __add__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return a new vector, which is the addition of this vector and the
           *        provided vector.
           * @param rhs The vector to add to this vector.
           * @return Resultant vector addition.

        """
        pass

    def __iadd__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return the vector added with the provided vector.
           * @param rhs The vector to add to this vector.
           * @return Resultant vector addition.

        """
        pass

    def __mul__(self, v: float) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, multiplied by the provided
           *        value.
           * @param v Value the vector should be multiplied by.
           * @return Resultant scaled vector.

        """
        pass

    def __imul__(self, v: float) -> Vector2d:
        """*
           * @brief Return the vector multiplied by the provided value.
           * @param v Value the vector should be scaled by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __truediv__(self, v: float) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, divided by the provided
           *        value.
           * @param v Value the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __itruediv__(self, v: float) -> Vector2d:
        """*
           * @brief Return the vector divided by the provided value.
           * @param v Value the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __truediv__(self, v: Vector2d) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, divided by the provided
           *        vector value. Scales x and y independently.
           * @param v Vector values the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __itruediv__(self, v: Vector2d) -> Vector2d:
        """*
           * @brief Return the vector divided by the provided vector values.
           * @param v Vector of values the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    def dot(self, other: Vector2d) -> T:
        """*
           * @brief Dot product of this vector with another vector.
           * @param other The second vector
           * @return The dot product (x1*x2 + y1*y2)

        """
        pass

    def normalized(self) -> Vector2d:
        """*
           * @brief Return normalized (unit length) version of the vector.
           * @return The normalized vector.

        """
        pass


#      </template specializations for class Vector2d>
#  ------------------------------------------------------------------------




# namespace espp

####################    </generated_from:vector2d.hpp>    ####################


####################    <generated_from:rtsp_client.hpp>    ####################





class RtspClient:
    """/ A class for interacting with an RTSP server using RTP and RTCP over UDP
    /
    / This class is used to connect to an RTSP server and receive JPEG frames
    / over RTP. It uses the TCP socket to send RTSP requests and receive RTSP
    / responses. It uses the UDP socket to receive RTP and RTCP packets.
    /
    / The RTSP client is designed to be used with the RTSP server in the
    / [camera-streamer]https://github.com/esp-cpp/camera-streamer) project, but it
    / should work with any RTSP server that sends JPEG frames over RTP.
    /
    / \section RtspClient Example
    / \snippet rtsp_example.cpp rtsp_client_example
    """

    class Config:
        """/ Configuration for the RTSP client"""
        server_address: str                                            #/< The server IP Address to connect to
        rtsp_port: int = int(8554)                                     #/< The port of the RTSP server
        path: str = str("/mjpeg/1")                                    #/< The path to the RTSP stream on the server. Will be appended
        #/< to the server address and port to form the full path of the
        #/< form "rtsp://<server_address>:<rtsp_port><path>"
        on_jpeg_frame: espp.RtspClient.jpeg_frame_callback_t           #/< The callback to call when a JPEG frame is received
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity.INFO  #/< The verbosity of the logger
        def __init__(
            self,
            server_address: str = "",
            rtsp_port: int = int(8554),
            path: str = str("/mjpeg/1"),
            on_jpeg_frame: RtspClient.jpeg_frame_callback_t = RtspClient.jpeg_frame_callback_t(),
            log_level: Logger.Verbosity = Logger.Verbosity.INFO
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    def send_request(
        self,
        method: str,
        path: str,
        extra_headers: std.unordered_map<str, str>,
        ec: std.error_code
        ) -> str:
        """/ Send an RTSP request to the server
        / \note This is a blocking call
        / \note This will parse the response and set the session ID if it is
        /      present in the response. If the response is not a 200 OK, then
        /      an error code will be set and the response will be returned.
        /      If the response is a 200 OK, then the response will be returned
        /      and the error code will be set to success.
        / \param method The method to use for connecting.
        /       Options are "OPTIONS", "DESCRIBE", "SETUP", "PLAY", and "TEARDOWN"
        / \param path The path to the RTSP stream on the server.
        / \param extra_headers Any extra headers to send with the request. These
        /      will be added to the request after the CSeq and Session headers. The
        /      key is the header name and the value is the header value. For example,
        /      {"Accept": "application/sdp"} will add "Accept: application/sdp" to the
        /      request. The "User-Agent" header will be added automatically. The
        /      "CSeq" and "Session" headers will be added automatically.
        /      The "Accept" header will be added automatically. The "Transport"
        /      header will be added automatically for the "SETUP" method. Defaults to
        /      an empty map.
        / \param ec The error code to set if an error occurs
        / \return The response from the server
        """
        pass

    def connect(self, ec: std.error_code) -> None:
        """/ Connect to the RTSP server
        / Connects to the RTSP server and sends the OPTIONS request.
        / \param ec The error code to set if an error occurs
        """
        pass

    def disconnect(self, ec: std.error_code) -> None:
        """/ Disconnect from the RTSP server
        / Disconnects from the RTSP server and sends the TEARDOWN request.
        / \param ec The error code to set if an error occurs
        """
        pass

    def describe(self, ec: std.error_code) -> None:
        """/ Describe the RTSP stream
        / Sends the DESCRIBE request to the RTSP server and parses the response.
        / \param ec The error code to set if an error occurs
        """
        pass

    @overload
    def setup(self, ec: std.error_code) -> None:
        """/ Setup the RTSP stream
        / \note Starts the RTP and RTCP threads.
        / Sends the SETUP request to the RTSP server and parses the response.
        / \note The default ports are 5000 and 5001 for RTP and RTCP respectively.
        / \param ec The error code to set if an error occurs
        """
        pass

    @overload
    def setup(self, rtp_port: int, rtcp_port: int, ec: std.error_code) -> None:
        """/ Setup the RTSP stream
        / Sends the SETUP request to the RTSP server and parses the response.
        / \note Starts the RTP and RTCP threads.
        / \param rtp_port The RTP client port
        / \param rtcp_port The RTCP client port
        / \param ec The error code to set if an error occurs
        """
        pass

    def play(self, ec: std.error_code) -> None:
        """/ Play the RTSP stream
        / Sends the PLAY request to the RTSP server and parses the response.
        / \param ec The error code to set if an error occurs
        """
        pass

    def pause(self, ec: std.error_code) -> None:
        """/ Pause the RTSP stream
        / Sends the PAUSE request to the RTSP server and parses the response.
        / \param ec The error code to set if an error occurs
        """
        pass

    def teardown(self, ec: std.error_code) -> None:
        """/ Teardown the RTSP stream
        / Sends the TEARDOWN request to the RTSP server and parses the response.
        / \param ec The error code to set if an error occurs
        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass


####################    </generated_from:rtsp_client.hpp>    ####################


####################    <generated_from:rtsp_server.hpp>    ####################






class RtspServer:
    """/ Class for streaming MJPEG data from a camera using RTSP + RTP
    / Starts a TCP socket to listen for RTSP connections, and then spawns off a
    / new RTSP session for each connection.
    / @see RtspSession
    / @note This class does not currently send RTCP packets
    /
    / \section RtspServer example
    / \snippet rtsp_example.cpp rtsp_server_example
    """
    class Config:
        """/ @brief Configuration for the RTSP server"""
        server_address: str                                            #/< The ip address of the server
        port: int                                                      #/< The port to listen on
        path: str                                                      #/< The path to the RTSP stream
        max_data_size: int = 1000                                      #/< The maximum size of RTP packet data for the MJPEG stream. Frames will be broken
        #/< up into multiple packets if they are larger than this. It seems that 1500 works
        #/< well for sending, but is too large for the esp32 (camera-display) to receive
        #/< properly.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity.WARN  #/< The log level for the RTSP server
        def __init__(
            self,
            server_address: str = "",
            port: int = int(),
            path: str = "",
            max_data_size: int = 1000,
            log_level: Logger.Verbosity = Logger.Verbosity.WARN
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    def set_session_log_level(self, log_level: Logger.Verbosity) -> None:
        """/ @brief Sets the log level for the RTSP sessions created by this server
        / @note This does not affect the log level of the RTSP server itself
        / @note This does not change the log level of any sessions that have
        /       already been created
        / @param log_level The log level to set
        """
        pass

    def start(self) -> bool:
        """/ @brief Start the RTSP server
        / Starts the accept task, session task, and binds the RTSP socket
        / @return True if the server was started successfully, False otherwise
        """
        pass

    def stop(self) -> None:
        """/ @brief Stop the FTP server
        / Stops the accept task, session task, and closes the RTSP socket
        """
        pass

    def send_frame(self, frame: JpegFrame) -> None:
        """/ @brief Send a frame over the RTSP connection
        / Converts the full JPEG frame into a series of simplified RTP/JPEG
        / packets and stores it to be sent over the RTP socket, but does not
        / actually send it
        / @note Overwrites any existing frame that has not been sent
        / @param frame The frame to send
        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:rtsp_server.hpp>    ####################


####################    <generated_from:socket.hpp>    ####################






class Socket:
    """*
     *   @brief Class for a generic socket with some helper functions for
     *          configuring the socket.

    """
    class Type(enum.Enum):
        raw = enum.auto()    # (= SOCK_RAW)  #*< Only IP headers, no TCP or UDP headers as well.
        dgram = enum.auto()  # (= SOCK_DGRAM)  #*< UDP/IP socket - datagram.
        stream = enum.auto() # (= SOCK_STREAM)  #*< TCP/IP socket - stream.

    class Info:
        """*
           *  @brief Storage for socket information (address, port) with convenience
           *         functions to convert to/from POSIX structures.

        """
        address: str         #*< IP address of the endpoint as a string.
        port: int            #*< Port of the endpoint as an integer.

        def init_ipv4(self, addr: str, prt: int) -> None:
            """*
                 * @brief Initialize the struct as an ipv4 address/port combo.
                 * @param addr IPv4 address string
                 * @param prt port number

            """
            pass

        def ipv4_ptr(self) -> struct sockaddr_in:
            """*
                 * @brief Gives access to IPv4 sockaddr structure (sockaddr_in) for use
                 *        with low level socket calls like sendto / recvfrom.
                 * @return *sockaddr_in pointer to ipv4 data structure

            """
            pass

        def ipv6_ptr(self) -> struct sockaddr_in6:
            """*
                 * @brief Gives access to IPv6 sockaddr structure (sockaddr_in6) for use
                 *        with low level socket calls like sendto / recvfrom.
                 * @return *sockaddr_in6 pointer to ipv6 data structure

            """
            pass

        def update(self) -> None:
            """*
                 * @brief Will update address and port based on the curent data in raw.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_storage) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_in) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_in6) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass
        def __init__(self, address: str = "", port: int = int()) -> None:
            """Auto-generated default constructor with named params"""
            pass






    @overload
    def is_valid(self) -> bool:
        """*
           * @brief Is the socket valid.
           * @return True if the socket file descriptor is >= 0.

        """
        pass

    @staticmethod
    @overload
    def is_valid(socket_fd: int) -> bool:
        """*
           * @brief Is the socket valid.
           * @param socket_fd Socket file descriptor.
           * @return True if the socket file descriptor is >= 0.

        """
        pass

    def get_ipv4_info(self) -> Optional[Socket.Info]:
        """*
           * @brief Get the Socket::Info for the socket.
           * @details This will call getsockname() on the socket to get the
           *          sockaddr_storage structure, and then fill out the Socket::Info
           *          structure.
           * @return Socket::Info for the socket.

        """
        pass

    def set_receive_timeout(self, timeout: std.chrono.duration<float>) -> bool:
        """*
           * @brief Set the receive timeout on the provided socket.
           * @param timeout requested timeout, must be > 0.
           * @return True if SO_RECVTIMEO was successfully set.

        """
        pass

    def enable_reuse(self) -> bool:
        """*
           * @brief Allow others to use this address/port combination after we're done
           *        with it.
           * @return True if SO_REUSEADDR and SO_REUSEPORT were successfully set.

        """
        pass

    def make_multicast(self, time_to_live: int = 1, loopback_enabled: int = True) -> bool:
        """*
           * @brief Configure the socket to be multicast (if time_to_live > 0).
           *        Sets the IP_MULTICAST_TTL (number of multicast hops allowed) and
           *        optionally configures whether this node should receive its own
           *        multicast packets (IP_MULTICAST_LOOP).
           * @param time_to_live number of multicast hops allowed (TTL).
           * @param loopback_enabled Whether to receive our own multicast packets.
           * @return True if IP_MULTICAST_TTL and IP_MULTICAST_LOOP were set.

        """
        pass

    def add_multicast_group(self, multicast_group: str) -> bool:
        """*
           * @brief If this is a server socket, add it to the provided the multicast
           *        group.
           *
           *         @note Multicast groups must be Class D addresses (224.0.0.0 to
           *                239.255.255.255)
           *
           *        See https://en.wikipedia.org/wiki/Multicast_address for more
           *        information.
           * @param multicast_group multicast group to join.
           * @return True if IP_ADD_MEMBERSHIP was successfully set.

        """
        pass

    def select(self, timeout: std.chrono.microseconds) -> int:
        """*
           * @brief Select on the socket for read events.
           * @param timeout how long to wait for an event.
           * @return number of events that occurred.

        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

# namespace espp

####################    </generated_from:socket.hpp>    ####################


####################    <generated_from:tcp_socket.hpp>    ####################





class TcpSocket:
    """*
     *   @brief Class for managing sending and receiving data using TCP/IP. Can be
     *          used to create client or server sockets.
     *
     * \section tcp_ex1 TCP Client Example
     * \snippet socket_example.cpp TCP Client example
     * \section tcp_ex2 TCP Server Example
     * \snippet socket_example.cpp TCP Server example
     *
     * \section tcp_ex3 TCP Client Response Example
     * \snippet socket_example.cpp TCP Client Response example
     * \section tcp_ex4 TCP Server Response Example
     * \snippet socket_example.cpp TCP Server Response example
     *

    """
    class Config:
        """*
           * @brief Config struct for the TCP socket.

        """
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.WARN)  #*< Verbosity level for the TCP socket logger.
        def __init__(
            self,
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class ConnectConfig:
        """*
           * @brief Config struct for connecting to a remote TCP server.

        """
        ip_address: str                                                                       #*< Address to send data to.
        port: int                                                                             #*< Port number to send data to.
        def __init__(self, ip_address: str = "", port: int = int()) -> None:
            """Auto-generated default constructor with named params"""
            pass



    def reinit(self) -> None:
        """*
           * @brief Reinitialize the socket, cleaning it up if first it is already
           *        initalized.

        """
        pass

    def close(self) -> None:
        """*
           * @brief Close the socket.

        """
        pass

    def is_connected(self) -> bool:
        """*
           * @brief Check if the socket is connected to a remote endpoint.
           * @return True if the socket is connected to a remote endpoint.

        """
        pass

    def connect(self, connect_config: TcpSocket.ConnectConfig) -> bool:
        """*
           * @brief Open a connection to the remote TCP server.
           * @param connect_config ConnectConfig struct describing the server endpoint.
           * @return True if the client successfully connected to the server.

        """
        pass

    def get_remote_info(self) -> Socket.Info:
        """*
           * @brief Get the remote endpoint info.
           * @return The remote endpoint info.

        """
        pass

    @overload
    def transmit(
        self,
        data: List[int],
        transmit_config: detail.TcpTransmitConfig = detail.TcpTransmitConfig()
        ) -> bool:
        pass

    @overload
    def transmit(
        self,
        data: List[char],
        transmit_config: detail.TcpTransmitConfig = detail.TcpTransmitConfig()
        ) -> bool:
        pass

    @overload
    def transmit(
        self,
        data: std.string_view,
        transmit_config: detail.TcpTransmitConfig = detail.TcpTransmitConfig()
        ) -> bool:
        pass

    @overload
    def receive(self, data: List[int], max_num_bytes: int) -> bool:
        """*
           * @brief Call read on the socket, assuming it has already been configured
           *        appropriately.
           *
           * @param data Vector of bytes of received data.
           * @param max_num_bytes Maximum number of bytes to receive.
           * @return True if successfully received, False otherwise.

        """
        pass

    @overload
    def receive(self, data: int, max_num_bytes: int) -> int:
        """*
           * @brief Call read on the socket, assuming it has already been configured
           *        appropriately.
           * @note This function will block until max_num_bytes are received or the
           *       receive timeout is reached.
           * @note The data pointed to by data must be at least max_num_bytes in size.
           * @param data Pointer to buffer to receive data.
           * @param max_num_bytes Maximum number of bytes to receive.
           * @return Number of bytes received.

        """
        pass

    def bind(self, port: int) -> bool:
        """*
           * @brief Bind the socket as a server on \p port.
           * @param port The port to which to bind the socket.
           * @return True if the socket was bound.

        """
        pass

    def listen(self, max_pending_connections: int) -> bool:
        """*
           * @brief Listen for incoming client connections.
           * @note Must be called after bind and before accept.
           * @see bind
           * @see accept
           * @param max_pending_connections Max number of allowed pending connections.
           * @return True if socket was able to start listening.

        """
        pass

    def accept(self) -> TcpSocket:
        """*
           * @brief Accept an incoming connection.
           * @note Blocks until a connection is accepted.
           * @note Must be called after listen.
           * @note This function will block until a connection is accepted.
           * @return A unique pointer to a TcpClientSession if a connection was
           *         accepted, None otherwise.

        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:tcp_socket.hpp>    ####################


####################    <generated_from:udp_socket.hpp>    ####################



# TODO: should this class _contain_ a socket or just create sockets within each
#       call?

class UdpSocket:
    """*
     *   @brief Class for managing sending and receiving data using UDP/IP. Can be
     *          used to create client or server sockets.
     *
     *   See
     *   https://github.com/espressif/esp-idf/tree/master/examples/protocols/sockets/udp_multicast
     *   for more information on udp multicast sockets.
     *
     * \section udp_ex1 UDP Client Example
     * \snippet socket_example.cpp UDP Client example
     * \section udp_ex2 UDP Server Example
     * \snippet socket_example.cpp UDP Server example
     *
     * \section udp_ex3 UDP Client Response Example
     * \snippet socket_example.cpp UDP Client Response example
     * \section udp_ex4 UDP Server Response Example
     * \snippet socket_example.cpp UDP Server Response example
     *
     * \section udp_ex5 UDP Multicast Client Example
     * \snippet socket_example.cpp UDP Multicast Client example
     * \section udp_ex6 UDP Multicast Server Example
     * \snippet socket_example.cpp UDP Multicast Server example
     *

    """
    class ReceiveConfig:
        port: int                                                                                        #*< Port number to bind to / receive from.
        buffer_size: int                                                                                 #*< Max size of data we can receive at one time.
        is_multicast_endpoint: bool = bool(False)                                                        #*< Whether this should be a multicast endpoint.
        multicast_group: str = str("")                                                                   #*< If this is a multicast endpoint, this is the group it belongs to.
        on_receive_callback: espp.Socket.receive_callback_fn = espp.Socket.receive_callback_fn(None)     #*< Function containing business logic to handle data received.
        def __init__(
            self,
            port: int = int(),
            buffer_size: int = int(),
            is_multicast_endpoint: bool = bool(False),
            multicast_group: str = str(""),
            on_receive_callback: Socket.receive_callback_fn = Socket.receive_callback_fn(None)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class SendConfig:
        ip_address: str                                                                                  #*< Address to send data to.
        port: int                                                                                        #*< Port number to send data to.
        is_multicast_endpoint: bool = bool(False)                                                        #*< Whether this should be a multicast endpoint.
        wait_for_response: bool = bool(False)                                                            #*< Whether to wait for a response from the remote or not.
        response_size: int = int(0)                                                                      #*< If waiting for a response, this is the maximum size response we will receive.
        on_response_callback: espp.Socket.response_callback_fn = espp.Socket.response_callback_fn(None)  #*< If waiting for a response, this is an optional handler which is provided the
                             response data.
        response_timeout: std.chrono.duration<float> = std.chrono.duration<float>(0.5)                   #*< If waiting for a response, this is the maximum timeout to wait.
        def __init__(
            self,
            ip_address: str = "",
            port: int = int(),
            is_multicast_endpoint: bool = bool(False),
            wait_for_response: bool = bool(False),
            response_size: int = int(0),
            on_response_callback: Socket.response_callback_fn = Socket.response_callback_fn(None),
            response_timeout: std.chrono.duration<float> = std.chrono.duration<float>(0.5)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class Config:
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.WARN)             #*< Verbosity level for the UDP socket logger.
        def __init__(
            self,
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    @overload
    def send(self, data: List[int], send_config: UdpSocket.SendConfig) -> bool:
        """*
           * @brief Send data to the endpoint specified by the send_config.
           *        Can be configured to multicast (within send_config) and can be
           *        configured to block waiting for a response from the remote.
           *
           *        @note in the case of multicast, it will block only until the first
           *              response.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data vector of bytes to send to the remote endpoint.
           * @param send_config SendConfig struct indicating where to send and whether
           *        to wait for a response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def send(self, data: std.string_view, send_config: UdpSocket.SendConfig) -> bool:
        """*
           * @brief Send data to the endpoint specified by the send_config.
           *        Can be configured to multicast (within send_config) and can be
           *        configured to block waiting for a response from the remote.
           *
           *        @note in the case of multicast, it will block only until the first
           *              response.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data String view of bytes to send to the remote endpoint.
           * @param send_config SendConfig struct indicating where to send and whether
           *        to wait for a response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    def receive(
        self,
        max_num_bytes: int,
        data: List[int],
        remote_info: Socket.Info
        ) -> bool:
        """*
           * @brief Call recvfrom on the socket, assuming it has already been
           *        configured appropriately.
           *
           * @param max_num_bytes Maximum number of bytes to receive.
           * @param data Vector of bytes of received data.
           * @param remote_info Socket::Info containing the sender's information. This
           *        will be populated with the information about the sender.
           * @return True if successfully received, False otherwise.

        """
        pass

    def start_receiving(
        self,
        task_config: Task.Config,
        receive_config: UdpSocket.ReceiveConfig
        ) -> bool:
        """*
           * @brief Configure a server socket and start a thread to continuously
           *        receive and handle data coming in on that socket.
           *
           * @param task_config Task::Config struct for configuring the receive task.
           * @param receive_config ReceiveConfig struct with socket and callback info.
           * @return True if the socket was created and task was started, False otherwise.

        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:udp_socket.hpp>    ####################


####################    <generated_from:task.hpp>    ####################





class Task:
    """*
     * @brief Task provides an abstraction over std::thread which optionally
     * includes memory / priority configuration on ESP systems. It allows users to
     * easily stop the task, and will automatically stop itself if destroyed.
     *
     * There is also a utility function which can be used to get the info for the
     * task of the current context, or for a provided Task object.
     *
     * There is also a helper function to run a lambda on a specific core, which can
     * be used to run a specific function on a specific core, as you might want to
     * do when registering an interrupt driver on a specific core.
     *
     * \section task_ex1 Basic Task Example
     * \snippet task_example.cpp Task example
     * \section task_ex2 Many Task Example
     * \snippet task_example.cpp ManyTask example
     * \section task_ex3 Long Running Task Example
     * \snippet task_example.cpp LongRunningTask example
     * \section task_ex4 Task Info Example
     * \snippet task_example.cpp Task Info example
     * \section task_ex5 Task Request Stop Example
     * \snippet task_example.cpp Task Request Stop example
     *
     * \section run_on_core_ex1 Run on Core Example
     * \snippet task_example.cpp run on core example

    """


    class BaseConfig:
        """*
           * @brief Base configuration struct for the Task.
           * @note This is designed to be used as a configuration struct in other classes
           *       that may have a Task as a member.

        """
        name: str                                                                             #*< Name of the task
        stack_size_bytes: int = int(4096)                                                     #*< Stack Size (B) allocated to the task.
        priority: int = int(0)                                                                #*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(-1)                                                                #*< Core ID of the task, -1 means it is not pinned to any core.
        def __init__(
            self,
            name: str = "",
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class Config:
        """*
           * @brief Configuration struct for the Task.
           * @note This is the recommended way to configure the Task, and allows you to
           *       use the condition variable and mutex from the task to wait_for and
           *       wait_until.
           * @note This is an older configuration struct, and is kept for backwards
           *       compatibility. It is recommended to use the AdvancedConfig struct
           *       instead.

        """
        name: str                                                                             #*< Name of the task
        callback: espp.Task.callback_fn                                                       #*< Callback function
        stack_size_bytes: int = int(4096)                                                     #*< Stack Size (B) allocated to the task.
        priority: int = int(0)                                                                #*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(-1)                                                                #*< Core ID of the task, -1 means it is not pinned to any core.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.WARN)  #*< Log verbosity for the task.
        def __init__(
            self,
            name: str = "",
            callback: Task.callback_fn = Task.callback_fn(),
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class SimpleConfig:
        """*
           * @brief Simple configuration struct for the Task.
           * @note This is useful for when you don't need to use the condition variable
           *       or mutex in the callback.

        """
        callback: espp.Task.simple_callback_fn                                                #*< Callback function
        task_config: BaseConfig                                                               #*< Base configuration for the task.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.WARN)  #*< Log verbosity for the task.
        def __init__(
            self,
            callback: Task.simple_callback_fn = Task.simple_callback_fn(),
            task_config: BaseConfig = BaseConfig(),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class AdvancedConfig:
        """*
           * @brief Advanced configuration struct for the Task.
           * @note This is the recommended way to configure the Task, and allows you to
           *       use the condition variable and mutex from the task to wait_for and
           *       wait_until.

        """
        callback: espp.Task.callback_fn                                                       #*< Callback function
        task_config: espp.Task.BaseConfig                                                     #*< Base configuration for the task.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.WARN)  #*< Log verbosity for the task.
        def __init__(
            self,
            callback: Task.callback_fn = Task.callback_fn(),
            task_config: Task.BaseConfig = Task.BaseConfig(),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass




    @staticmethod
    @overload
    def make_unique(config: Task.Config) -> Task:
        """*
           * @brief Get a unique pointer to a new task created with \p config.
           *        Useful to not have to use templated std::make_unique (less typing).
           * @param config Config struct to initialize the Task with.
           * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass

    @staticmethod
    @overload
    def make_unique(config: Task.SimpleConfig) -> Task:
        """*
           * @brief Get a unique pointer to a new task created with \p config.
           *        Useful to not have to use templated std::make_unique (less typing).
           * @param config SimpleConfig struct to initialize the Task with.
           * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass

    @staticmethod
    @overload
    def make_unique(config: Task.AdvancedConfig) -> Task:
        """*
           * @brief Get a unique pointer to a new task created with \p config.
           *        Useful to not have to use templated std::make_unique (less typing).
           * @param config AdvancedConfig struct to initialize the Task with.
           * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass


    def start(self) -> bool:
        """*
           * @brief Start executing the task.
           *
           * @return True if the task started, False if it was already started.

        """
        pass

    def stop(self) -> bool:
        """*
           * @brief Stop the task execution, blocking until it stops.
           *
           * @return True if the task stopped, False if it was not started / already
           * stopped.

        """
        pass

    def is_started(self) -> bool:
        """*
           * @brief Has the task been started or not?
           *
           * @return True if the task is started / running, False otherwise.

        """
        pass

    def is_running(self) -> bool:
        """*
           * @brief Is the task running?
           *
           * @return True if the task is running, False otherwise.

        """
        pass


    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

# namespace espp

####################    </generated_from:task.hpp>    ####################


####################    <generated_from:timer.hpp>    ####################



class Timer:
    """/ @brief A timer that can be used to schedule tasks to run at a later time.
    / @details A timer can be used to schedule a task to run at a later time.
    /          The timer will run in the background and will call the task when
    /          the time is up. The timer can be canceled at any time. A timer
    /          can be configured to run once or to repeat.
    /
    /          The timer uses a task to run in the background. The task will
    /          sleep until the timer is ready to run. When the timer is ready to
    /          run, the task will call the callback function. The callback
    /          function can return True to cancel the timer or False to keep the
    /          timer running. If the timer is configured to repeat, then the
    /          callback function will be called again after the period has
    /          elapsed. If the timer is configured to run once, then the
    /          callback function will only be called once.
    /
    /          The timer can be configured to start automatically when it is
    /          constructed. If the timer is not configured to start
    /          automatically, then the timer can be started by calling start().
    /          The timer can be canceled at any time by calling cancel().
    /
    / @note The timer uses a task to run in the background, so the timer
    /       callback function will be called in the context of the task. The
    /       timer callback function should not block for a long time because it
    /       will block the task. If the timer callback function blocks for a
    /       long time, then the timer will not be able to keep up with the
    /       period.
    /
    / \section timer_ex1 Timer Example 1
    / \snippet timer_example.cpp timer example
    / \section timer_ex2 Timer Delay Example
    / \snippet timer_example.cpp timer delay example
    / \section timer_ex3 Oneshot Timer Example
    / \snippet timer_example.cpp timer oneshot example
    / \section timer_ex4 Timer Cancel Itself Example
    / \snippet timer_example.cpp timer cancel itself example
    / \section timer_ex5 Oneshot Timer Cancel Itself Then Start again with Delay Example
    / \snippet timer_example.cpp timer oneshot restart example
    / \section timer_ex6 Timer Update Period Example
    / \snippet timer_example.cpp timer update period example
    """

    class Config:
        """/ @brief The configuration for the timer."""
        name: std.string_view                                              #/< The name of the timer.
        period: std.chrono.duration<float>                                 #/< The period of the timer. If 0, the timer callback will only be called once.
        delay: std.chrono.duration<float> = std.chrono.duration<float>(0)  #/< The delay before the first execution of the timer callback after start() is called.
        callback: callback_fn                                              #/< The callback function to call when the timer expires.
        auto_start: bool = bool(True)                                      #/< If True, the timer will start automatically when constructed.
        stack_size_bytes: int = int(4096)                                  #/< The stack size of the task that runs the timer.
        priority: int = int(0)                                             #/< Priority of the timer, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(-1)                                             #/< Core ID of the timer, -1 means it is not pinned to any core.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity.WARN      #/< The log level for the timer.
        def __init__(
            self,
            name: std.string_view = std.string_view(),
            period: std.chrono.duration<float> = std.chrono.duration<float>(),
            delay: std.chrono.duration<float> = std.chrono.duration<float>(0),
            callback: callback_fn = callback_fn(),
            auto_start: bool = bool(True),
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1),
            log_level: Logger.Verbosity = Logger.Verbosity.WARN
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    @overload
    def start(self) -> None:
        """/ @brief Start the timer.
        / @details Starts the timer. Does nothing if the timer is already running.
        """
        pass

    @overload
    def start(self, delay: std.chrono.duration<float>) -> None:
        """/ @brief Start the timer with a delay.
        / @details Starts the timer with a delay. If the timer is already running,
        /          this will cancel the timer and start it again with the new
        /          delay. If the timer is not running, this will start the timer
        /          with the delay. Overwrites any previous delay that might have
        /          been set.
        / @param delay The delay before the first execution of the timer callback.
        """
        pass

    def stop(self) -> None:
        """/ @brief Stop the timer, same as cancel().
        / @details Stops the timer, same as cancel().
        """
        pass

    def cancel(self) -> None:
        """/ @brief Cancel the timer.
        / @details Cancels the timer.
        """
        pass

    def set_period(self, period: std.chrono.duration<float>) -> None:
        """/ @brief Set the period of the timer.
        / @details Sets the period of the timer.
        / @param period The period of the timer.
        / @note If the period is 0, the timer will run once.
        / @note If the period is negative, the period will not be set / updated.
        / @note If the timer is running, the period will be updated after the
        /       current period has elapsed.
        """
        pass

    def is_running(self) -> bool:
        """/ @brief Check if the timer is running.
        / @details Checks if the timer is running.
        / @return True if the timer is running, False otherwise.
        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:timer.hpp>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
