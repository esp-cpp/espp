# If you want to use mypy or pyright, you may have to ignore some errors, like below:

# mypy: disable-error-code="type-arg"

from typing import overload, List

NumberType = (int, float, np.number)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:csv.hpp>    ####################

class __csv_documentation__:
    """*
    * @brief Comma Separated Value (CSV) reader/writer convenience wrapper around
    *        <a href="https://github.com/p-ranav/csv2">p-ranav/csv2</a> which
    *        exposes csv2::Reader and csv2::Writer classes for managing efficient
    *        (lazy-loaded) parsing and serizaliztion of human-readable
    *        CSV-formatted data.
    *
    * @note This class does not really exist or do anything, but it's the only
    *       way I could figure out how to get this documentation built into the
    *       system :(
    *
    * \section csv_ex1 CSV Reader Example
    * \snippet csv_example.cpp csv reader example
    * \section csv_ex2 Complex CSV Writer Example
    * \snippet csv_example.cpp csv writer example

    """

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:csv.hpp>    ####################

####################    <generated_from:event_manager.hpp>    ####################

class EventManager:
    """*
    * @brief Singleton class for managing events. Provides mechanisms for
    *        anonymous publish / subscribe interactions - enabling one to one,
    *        one to many, many to one, and many to many data distribution with
    *        loose coupling and low overhead. Each topic runs a thread for that
    *        topic's subscribers, executing all the callbacks in sequence and
    *        then going to sleep again until new data is published.
    *
    * @note In c++ objects, it's recommended to call the
    *       add_publisher/add_subscriber functions in the class constructor and
    *       then to call the remove_publisher/remove_subscriber functions in the
    *       class destructor.
    *
    * @note It is recommended (unless you are only interested in events and not
    *       data or are only needing to transmit actual strings) to use a
    *       serialization library (such as espp::serialization - which wraps
    *       alpaca) to serialize your data structures to string when publishing
    *       and then deserialize your data from string in the subscriber
    *       callbacks.
    *
    * \section event_manager_ex1 Event Manager Example
    * \snippet event_manager_example.cpp event manager example

    """

    @staticmethod
    def get() -> EventManager:
        """*
        * @brief Get the singleton instance of the EventManager.
        * @return A reference to the EventManager singleton.

        """
        pass

    def add_publisher(self, topic: str, component: str) -> bool:
        """*
        * @brief Register a publisher for \p component on \p topic.
        * @param topic Topic name for the data being published.
        * @param component Name of the component publishing data.
        * @return True if the publisher was added, False if it was already
        *         registered for that component.

        """
        pass

    @overload
    def add_subscriber(
        self,
        topic: str,
        component: str,
        callback: event_callback_fn,
        stack_size_bytes: int = 8192,
    ) -> bool:
        """*
        * @brief Register a subscriber for \p component on \p topic.
        * @param topic Topic name for the data being subscribed to.
        * @param component Name of the component publishing data.
        * @param callback The event_callback_fn to be called when receicing data on
        *        \p topic.
        * @param stack_size_bytes The stack size in bytes to use for the subscriber
        * @note The stack size is only used if a subscriber is not already registered
        *       for that topic. If a subscriber is already registered for that topic,
        *       the stack size is ignored.
        * @return True if the subscriber was added, False if it was already
        *         registered for that component.

        """
        pass

    @overload
    def add_subscriber(
        self,
        topic: str,
        component: str,
        callback: event_callback_fn,
        task_config: Task.BaseConfig,
    ) -> bool:
        """*
        * @brief Register a subscriber for \p component on \p topic.
        * @param topic Topic name for the data being subscribed to.
        * @param component Name of the component publishing data.
        * @param callback The event_callback_fn to be called when receicing data on
        *        \p topic.
        * @param task_config The task configuration to use for the subscriber.
        * @note The task_config is only used if a subscriber is not already
        *       registered for that topic. If a subscriber is already registered for
        *       that topic, the task_config is ignored.
        * @return True if the subscriber was added, False if it was already
        *         registered for that component.

        """
        pass

    def publish(self, topic: str, data: List[int]) -> bool:
        """*
        * @brief Publish \p data on \p topic.
        * @param topic Topic to publish data on.
        * @param data Data to publish, within a vector container.
        * @return True if \p data was successfully published to \p topic, False
        *         otherwise. Publish will not occur (and will return False) if
        *         there are no subscribers for this topic.

        """
        pass

    def remove_publisher(self, topic: str, component: str) -> bool:
        """*
        * @brief Remove \p component's publisher for \p topic.
        * @param topic The topic that \p component was publishing on.
        * @param component The component for which the publisher was registered.
        * @return True if the publisher was removed, False if it was not
        *         registered.

        """
        pass

    def remove_subscriber(self, topic: str, component: str) -> bool:
        """*
        * @brief Remove \p component's subscriber for \p topic.
        * @param topic The topic that \p component was subscribing to.
        * @param component The component for which the subscriber was registered.
        * @return True if the subscriber was removed, False if it was not
        *         registered.

        """
        pass

####################    </generated_from:event_manager.hpp>    ####################

####################    <generated_from:file_system.hpp>    ####################

class FileSystem:
    """/ @brief File system class
    / @details
    / This class is a singleton and should be accessed via the get() method.
    / The class is responsible for mounting the file system and providing
    / access to the file system. It is configured via the menuconfig system and will
    / use the partition with the label specified in the menuconfig. The partition
    / must be formatted with the LittleFS file system. The file system is mounted
    / at the root directory of the partition such that all files will be stored
    / under the path "/<partition_label>/".
    / @see get_partition_label()
    /
    / The class provides methods to get the amount of free, used and total space
    / on the file system. It also provides a method to get a human readable string
    / for a byte size.
    /
    / \section fs_ex1 File System Info Example
    / \snippet file_system_example.cpp file_system info example
    / \section fs_ex2 File System POSIX / NEWLIB Example
    / \snippet file_system_example.cpp file_system posix example
    / \section fs_ex3 File System Info std::filesystem Example
    / \snippet file_system_example.cpp file_system std filesystem example
    """

    @staticmethod
    def human_readable(bytes: int) -> str:
        """/ @brief Get a human readable string for a byte size
        / @details
        / This method returns a human readable string for a byte size.
        / It is copied from the example on the page:
        / https://en.cppreference.com/w/cpp/filesystem/file_size
        / @param bytes The byte size
        / @return The human readable string
        """
        pass

    @staticmethod
    def get_mount_point() -> str:
        """/ @brief Get the mount point
        / @details
        / The mount point is the root directory of the file system.
        / It is the root directory of the partition with the partition label.
        / @see get_root_path()
        / @return The mount point
        """
        pass

    @staticmethod
    def get_root_path() -> std.filesystem.path:
        """/ @brief Get the root path
        / @details
        / The root path is the root directory of the file system.
        / @see get_mount_point()
        / @return The root path
        """
        pass

    @staticmethod
    @overload
    def to_string(permissions: std.filesystem.perms) -> str:
        """/ @brief Convert file permissions to a string
        / @details This method converts file permissions to a string in the format "rwxrwxrwx".
        / @param permissions The file permissions
        / @return The file permissions as a string
        """
        pass

    @staticmethod
    @overload
    def to_string(time: time_t) -> str:
        """/ @brief Convert a time_t to a string
        / @details This method converts a time_t to a string in the format "Jan 01 00:00".
        / @param time The time_t to convert
        / @return The time as a string
        """
        pass

    @staticmethod
    def get() -> FileSystem:
        """/ @brief Access the singleton instance of the file system
        / @return Reference to the file system instance
        """
        pass

    class ListConfig:
        """/ @brief Config for listing the contents of a directory
        / @details
        / This struct is used to configure the output of the list_directory() method.
        / It contains boolean values for each of the fields to include in the output.
        """

        type: bool = True  # /< The type of the file (directory, file, etc.)
        permissions: bool = True  # /< The permissions of the file
        number_of_links: bool = True  # /< The number of links to the file
        owner: bool = True  # /< The owner of the file
        group: bool = True  # /< The group of the file
        size: bool = True  # /< The size of the file
        date_time: bool = True  # /< The date and time of the file
        recursive: bool = False  # /< Whether to list the contents of subdirectories
        def __init__(
            self,
            type: bool = True,
            permissions: bool = True,
            number_of_links: bool = True,
            owner: bool = True,
            group: bool = True,
            size: bool = True,
            date_time: bool = True,
            recursive: bool = False,
        ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    @overload
    def __init__(self, param_0: FileSystem) -> None:
        pass

    @overload
    def __init__(self, param_0: FileSystem) -> None:
        pass

    def get_free_space(self) -> int:
        """/ @brief Get the amount of free space on the file system
        / @return The amount of free space in bytes
        """
        pass

    def get_total_space(self) -> int:
        """/ @brief Get the total amount of space on the file system
        / @return The total amount of space in bytes
        """
        pass

    def get_used_space(self) -> int:
        """/ @brief Get the amount of used space on the file system
        / @return The amount of used space in bytes
        """
        pass

    def get_file_time_as_string(self, path: std.filesystem.path) -> str:
        """/ @brief Get the time of a file as a string
        / @details This method gets the time of a file as a string in the format "Jan 01 00:00".
        / @param path The path to the file
        / @return The time of the file as a string
        / @see file_time_to_string()
        """
        pass

    def get_files_in_path(
        self,
        path: std.filesystem.path,
        include_directories: bool = False,
        recursive: bool = False,
    ) -> List[std.filesystem.path]:
        """/ @brief Get a vector of files in a directory
        / @details This method returns a vector of paths to the files in a directory.
        / @param path The path to the directory
        / @param include_directories Whether to include directories in the output
        / @param recursive Whether to include files in subdirectories
        / @return A vector of paths to the files in the directory
        """
        pass

    def remove(self, path: std.filesystem.path, ec: std.error_code) -> bool:
        """/ @brief Completely remove a file or directory (including contents)
        / @details This method removes a file or directory and all of its contents.
        /          If the path is a directory, it will iterate over the contents
        /          and remove them recursively. If the path is a file, it will
        /          remove the file. If the path does not exist, it will return False.
        / @param path The path to the file or directory
        / @param ec The error code to set if an error occurs
        / @return Whether the file or directory was successfully removed
        """
        pass

    def remove_contents(self, path: std.filesystem.path, ec: std.error_code) -> bool:
        """/ @brief Remove the contents of a directory, but not the directory itself
        / @details This method removes the contents of a directory, but not the
        /          directory itself. If the path is not a directory, it will return
        /          False. If the path does not exist, it will return False. If the
        /          path is a directory, it will iterate over the contents and remove
        /          them recursively.
        / @param path The path to the directory
        / @param ec The error code to set if an error occurs
        / @return Whether the contents of the directory were successfully removed
        """
        pass

    @overload
    def list_directory(
        self, path: std.filesystem.path, config: FileSystem.ListConfig, prefix: str = ""
    ) -> str:
        """/ @brief List the contents of a directory
        / @details
        / This method lists the contents of a directory. It returns a string
        / containing the contents of the directory. The contents are formatted
        / according to the config. The config is a struct with boolean values
        / for each of the fields to include in the output. The fields are:
        / - type: The type of the file (directory, file, etc.)
        / - permissions: The permissions of the file
        / - number_of_links: The number of links to the file
        / - owner: The owner of the file
        / - group: The group of the file
        / - size: The size of the file
        / - date_time: The date and time of the file
        / - recursive: Whether to list the contents of subdirectories
        / @param path The path to the directory
        / @param config The config for the output
        / @param prefix The prefix to use for the output
        / @return The contents of the directory
        """
        pass

    @overload
    def list_directory(
        self, path: str, config: FileSystem.ListConfig, prefix: str = ""
    ) -> str:
        """/ @brief List the contents of a directory
        / @details
        / This method lists the contents of a directory. It returns a string
        / containing the contents of the directory. The contents are formatted
        / according to the config. The config is a struct with boolean values
        / for each of the fields to include in the output. The fields are:
        / - type: The type of the file (directory, file, etc.)
        / - permissions: The permissions of the file
        / - number_of_links: The number of links to the file
        / - owner: The owner of the file
        / - group: The group of the file
        / - size: The size of the file
        / - date_time: The date and time of the file
        / - recursive: Whether to list the contents of subdirectories
        / @param path The path to the directory
        / @param config The config for the output
        / @param prefix The prefix to use for the output
        / @return The contents of the directory
        """
        pass
    #  ------------------------------------------------------------------------
    #      <template specializations for function to_time_t>
    @staticmethod
    def to_time_t_filesystem_file_time_type(
        tp: std.filesystem.file_time_type,
    ) -> std.time_t:
        """/ Function to convert a time_point to a time_t.
        / \details This function converts a time_point to a time_t. This function
        /     is needed because the standard library does not provide a function to
        /     convert a time_point to a time_t (until c++20 but support seems lacking
        /     on esp32). This function is taken from
        /     https://stackoverflow.com/a/61067330
        / \tparam TP The type of the time_point.
        / \param tp The time_point to convert.
        / \return The time_t.
        """
        pass
    #      </template specializations for function to_time_t>
    #  ------------------------------------------------------------------------

####################    </generated_from:file_system.hpp>    ####################

####################    <generated_from:ftp_server.hpp>    ####################

class FtpServer:
    """/ \brief A class that implements a FTP server."""

    def __init__(
        self, ip_address: std.string_view, port: int, root: std.filesystem.path
    ) -> None:
        """/ \brief A class that implements a FTP server.
        / \note The IP Address is not currently used to select the right
        /       interface, but is instead passed to the FtpClientSession so that
        /       it can be used in the PASV command.
        / \param ip_address The IP address to listen on.
        / \param port The port to listen on.
        / \param root The root directory of the FTP server.
        """
        pass

    def start(self) -> bool:
        """/ \brief Start the FTP server.
        / Bind to the port and start accepting connections.
        / \return True if the server was started, False otherwise.
        """
        pass

    def stop(self) -> None:
        """/ \brief Stop the FTP server."""
        pass

####################    </generated_from:ftp_server.hpp>    ####################

####################    <generated_from:gaussian.hpp>    ####################

class Gaussian:
    """*
    * @brief Implements a gaussian function
    *        \f$y(t)=\alpha\exp(-\frac{(t-\beta)^2}{2\gamma^2})\f$.
    * @details Alows you to store the alpha, beta, and gamma coefficients as well
    *          as update them dynamically.
    *
    * \section gaussian_ex1 Example
    * \snippet math_example.cpp gaussian example

    """

    class Config:
        """*
        * @brief Configuration structure for initializing the gaussian.

        """

        gamma: float  # /< Slope of the gaussian, range [0, 1]. 0 is more of a thin spike from 0 up to
        # /< max output (alpha), 1 is more of a small wave around the max output (alpha).
        alpha: float = 1.0  # /< Max amplitude of the gaussian output, defautls to 1.0.
        beta: float = (
            0.5  # /< Beta value for the gaussian, default to be symmetric at 0.5 in range [0,1].
        )
        def __init__(
            self, gamma: float = float(), alpha: float = 1.0, beta: float = 0.5
        ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def gamma(self, g: float) -> None:
        """*
        * @brief Set / Update the gamma (shape) value.
        * @param g New gamma (shape) to use.

        """
        pass

    @overload
    def alpha(self) -> float:
        """*
        * @brief Get the currently configured alpha (scaling) value.
        * @return The current alpha (scaler) value.

        """
        pass

    @overload
    def alpha(self, a: float) -> None:
        """*
        * @brief Set / Update the alpha (scaling) value.
        * @param a New alpha (scaler) to use.

        """
        pass

    @overload
    def beta(self) -> float:
        """*
        * @brief Get the currently configured beta (shifting) value.
        * @return The current beta (shifter) value [0, 1].

        """
        pass

    @overload
    def beta(self, b: float) -> None:
        """*
        * @brief Set / Update the beta (shifting) value.
        * @param b New beta (shifter) to use.

        """
        pass

    def at(self, t: float) -> float:
        """*
        * @brief Evaluate the gaussian at \p t.
        * @param t The evaluation parameter, [0, 1].
        * @return The gaussian evaluated at \p t.

        """
        pass

    def __call__(self, t: float) -> float:
        """*
        * @brief Evaluate the gaussian at \p t.
        * @note Convienience wrapper around the at() method.
        * @param t The evaluation parameter, [0, 1].
        * @return The gaussian evaluated at \p t.

        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:gaussian.hpp>    ####################

####################    <generated_from:task.hpp>    ####################

class Task:
    """*
    * @brief Task provides an abstraction over std::thread which optionally
    * includes memory / priority configuration on ESP systems. It allows users to
    * easily stop the task, and will automatically stop itself if destroyed.
    *
    * There is also a utility function which can be used to get the info for the
    * task of the current context, or for a provided Task object.
    *
    * There is also a helper function to run a lambda on a specific core, which can
    * be used to run a specific function on a specific core, as you might want to
    * do when registering an interrupt driver on a specific core.
    *
    * \section task_ex1 Basic Task Example
    * \snippet task_example.cpp Task example
    * \section task_ex2 Many Task Example
    * \snippet task_example.cpp ManyTask example
    * \section task_ex3 Long Running Task Example
    * \snippet task_example.cpp LongRunningTask example
    * \section task_ex4 Task Info Example
    * \snippet task_example.cpp Task Info example
    * \section task_ex5 Task Request Stop Example
    * \snippet task_example.cpp Task Request Stop example
    *
    * \section run_on_core_ex1 Run on Core Example
    * \snippet task_example.cpp run on core example

    """

    class BaseConfig:
        """*
        * @brief Base configuration struct for the Task.
        * @note This is designed to be used as a configuration struct in other classes
        *       that may have a Task as a member.

        """

        name: str  # *< Name of the task
        stack_size_bytes: int = int(4096)  # *< Stack Size (B) allocated to the task.
        priority: int = int(
            0
        )  # *< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(
            -1
        )  # *< Core ID of the task, -1 means it is not pinned to any core.
        def __init__(
            self,
            name: str = "",
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1),
        ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class Config:
        """*
        * @brief Configuration struct for the Task.
        * @note This is the recommended way to configure the Task, and allows you to
        *       use the condition variable and mutex from the task to wait_for and
        *       wait_until.
        * @note This is an older configuration struct, and is kept for backwards
        *       compatibility. It is recommended to use the AdvancedConfig struct
        *       instead.

        """

        name: str  # *< Name of the task
        callback: callback_fn  # *< Callback function
        stack_size_bytes: int = int(4096)  # *< Stack Size (B) allocated to the task.
        priority: int = int(
            0
        )  # *< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(
            -1
        )  # *< Core ID of the task, -1 means it is not pinned to any core.
        log_level: Logger.Verbosity = Logger.Verbosity(
            Logger.Verbosity.WARN
        )  # *< Log verbosity for the task.
        def __init__(
            self,
            name: str = "",
            callback: callback_fn = callback_fn(),
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN),
        ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class SimpleConfig:
        """*
        * @brief Simple configuration struct for the Task.
        * @note This is useful for when you don't need to use the condition variable
        *       or mutex in the callback.

        """

        callback: simple_callback_fn  # *< Callback function
        task_config: BaseConfig  # *< Base configuration for the task.
        log_level: Logger.Verbosity = Logger.Verbosity(
            Logger.Verbosity.WARN
        )  # *< Log verbosity for the task.
        def __init__(
            self,
            callback: simple_callback_fn = simple_callback_fn(),
            task_config: BaseConfig = BaseConfig(),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN),
        ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class AdvancedConfig:
        """*
        * @brief Advanced configuration struct for the Task.
        * @note This is the recommended way to configure the Task, and allows you to
        *       use the condition variable and mutex from the task to wait_for and
        *       wait_until.

        """

        callback: callback_fn  # *< Callback function
        task_config: BaseConfig  # *< Base configuration for the task.
        log_level: Logger.Verbosity = Logger.Verbosity(
            Logger.Verbosity.WARN
        )  # *< Log verbosity for the task.
        def __init__(
            self,
            callback: callback_fn = callback_fn(),
            task_config: BaseConfig = BaseConfig(),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN),
        ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    @staticmethod
    @overload
    def make_unique(config: Task.Config) -> Task:
        """*
        * @brief Get a unique pointer to a new task created with \p config.
        *        Useful to not have to use templated std::make_unique (less typing).
        * @param config Config struct to initialize the Task with.
        * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass

    @staticmethod
    @overload
    def make_unique(config: Task.SimpleConfig) -> Task:
        """*
        * @brief Get a unique pointer to a new task created with \p config.
        *        Useful to not have to use templated std::make_unique (less typing).
        * @param config SimpleConfig struct to initialize the Task with.
        * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass

    @staticmethod
    @overload
    def make_unique(config: Task.AdvancedConfig) -> Task:
        """*
        * @brief Get a unique pointer to a new task created with \p config.
        *        Useful to not have to use templated std::make_unique (less typing).
        * @param config AdvancedConfig struct to initialize the Task with.
        * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass

    def start(self) -> bool:
        """*
        * @brief Start executing the task.
        *
        * @return True if the task started, False if it was already started.

        """
        pass

    def stop(self) -> bool:
        """*
        * @brief Stop the task execution, blocking until it stops.
        *
        * @return True if the task stopped, False if it was not started / already
        * stopped.

        """
        pass

    def is_started(self) -> bool:
        """*
        * @brief Has the task been started or not?
        *
        * @return True if the task is started / running, False otherwise.

        """
        pass

    def is_running(self) -> bool:
        """*
        * @brief Is the task running?
        *
        * @return True if the task is running, False otherwise.

        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:task.hpp>    ####################

####################    <generated_from:tcp_socket.hpp>    ####################

class TcpSocket:
    """*
    *   @brief Class for managing sending and receiving data using TCP/IP. Can be
    *          used to create client or server sockets.
    *
    * \section tcp_ex1 TCP Client Example
    * \snippet socket_example.cpp TCP Client example
    * \section tcp_ex2 TCP Server Example
    * \snippet socket_example.cpp TCP Server example
    *
    * \section tcp_ex3 TCP Client Response Example
    * \snippet socket_example.cpp TCP Client Response example
    * \section tcp_ex4 TCP Server Response Example
    * \snippet socket_example.cpp TCP Server Response example
    *

    """

    class Config:
        """*
        * @brief Config struct for the TCP socket.

        """

        log_level: Logger.Verbosity = Logger.Verbosity(
            Logger.Verbosity.WARN
        )  # *< Verbosity level for the TCP socket logger.
        def __init__(
            self, log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.WARN)
        ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class ConnectConfig:
        """*
        * @brief Config struct for connecting to a remote TCP server.

        """

        ip_address: str  # *< Address to send data to.
        port: int  # *< Port number to send data to.
        def __init__(self, ip_address: str = "", port: int = int()) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def reinit(self) -> None:
        """*
        * @brief Reinitialize the socket, cleaning it up if first it is already
        *        initalized.

        """
        pass

    def close(self) -> None:
        """*
        * @brief Close the socket.

        """
        pass

    def is_connected(self) -> bool:
        """*
        * @brief Check if the socket is connected to a remote endpoint.
        * @return True if the socket is connected to a remote endpoint.

        """
        pass

    def connect(self, connect_config: TcpSocket.ConnectConfig) -> bool:
        """*
        * @brief Open a connection to the remote TCP server.
        * @param connect_config ConnectConfig struct describing the server endpoint.
        * @return True if the client successfully connected to the server.

        """
        pass

    def get_remote_info(self) -> Socket.Info:
        """*
        * @brief Get the remote endpoint info.
        * @return The remote endpoint info.

        """
        pass

    @overload
    def transmit(
        self,
        data: List[int],
        transmit_config: detail.TcpTransmitConfig = detail.TcpTransmitConfig(),
    ) -> bool:
        pass

    @overload
    def transmit(
        self,
        data: List[char],
        transmit_config: detail.TcpTransmitConfig = detail.TcpTransmitConfig(),
    ) -> bool:
        pass

    @overload
    def transmit(
        self,
        data: std.string_view,
        transmit_config: detail.TcpTransmitConfig = detail.TcpTransmitConfig(),
    ) -> bool:
        pass

    @overload
    def receive(self, data: List[int], max_num_bytes: int) -> bool:
        """*
        * @brief Call read on the socket, assuming it has already been configured
        *        appropriately.
        *
        * @param data Vector of bytes of received data.
        * @param max_num_bytes Maximum number of bytes to receive.
        * @return True if successfully received, False otherwise.

        """
        pass

    @overload
    def receive(self, data: int, max_num_bytes: int) -> int:
        """*
        * @brief Call read on the socket, assuming it has already been configured
        *        appropriately.
        * @note This function will block until max_num_bytes are received or the
        *       receive timeout is reached.
        * @note The data pointed to by data must be at least max_num_bytes in size.
        * @param data Pointer to buffer to receive data.
        * @param max_num_bytes Maximum number of bytes to receive.
        * @return Number of bytes received.

        """
        pass

    def bind(self, port: int) -> bool:
        """*
        * @brief Bind the socket as a server on \p port.
        * @param port The port to which to bind the socket.
        * @return True if the socket was bound.

        """
        pass

    def listen(self, max_pending_connections: int) -> bool:
        """*
        * @brief Listen for incoming client connections.
        * @note Must be called after bind and before accept.
        * @see bind
        * @see accept
        * @param max_pending_connections Max number of allowed pending connections.
        * @return True if socket was able to start listening.

        """
        pass

    def accept(self) -> TcpSocket:
        """*
        * @brief Accept an incoming connection.
        * @note Blocks until a connection is accepted.
        * @note Must be called after listen.
        * @note This function will block until a connection is accepted.
        * @return A unique pointer to a TcpClientSession if a connection was
        *         accepted, None otherwise.

        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:tcp_socket.hpp>    ####################

####################    <generated_from:deep_history_state.hpp>    ####################

# <submodule state_machine>
class state_machine:  # Proxy class that introduces typings for the *submodule* state_machine
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace state_machine"""

    class DeepHistoryState:
        """*
        * @brief Deep History Pseudostates exist purely to re-implement the
        *  makeActive() function to actually call
        *  _parentState->setDeepHistory()

        """

        @overload
        def __init__(self) -> None:
            """*
            * @brief Construct a new Deep History State object

            """
            pass

        @overload
        def __init__(self, _parent: StateBase) -> None:
            """*
            * @brief Construct a new Deep History State object
            * @param _parent The parent state of this state

            """
            pass

        def make_active(self) -> None:
            """*
            * @brief Calls _parentState->setDeepHistory()

            """
            pass

# </submodule state_machine>
####################    </generated_from:deep_history_state.hpp>    ####################

####################    <generated_from:shallow_history_state.hpp>    ####################

# <submodule state_machine>
class state_machine:  # Proxy class that introduces typings for the *submodule* state_machine
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace state_machine"""

    class ShallowHistoryState:
        """*
        * @brief Shallow History Pseudostates exist purely to re-implement
        *  the makeActive() function to actually call
        *  _parentState->setShallowHistory()

        """

        @overload
        def __init__(self) -> None:
            """*
            * @brief Default constructor

            """
            pass

        @overload
        def __init__(self, _parent: StateBase) -> None:
            """*
            * @brief Constructor
            * @param _parent The parent state

            """
            pass

        def make_active(self) -> None:
            """*
            * @brief Calls _parentState->setShallowHistory().

            """
            pass

# </submodule state_machine>
####################    </generated_from:shallow_history_state.hpp>    ####################

####################    <generated_from:state_base.hpp>    ####################

# <submodule state_machine>
class state_machine:  # Proxy class that introduces typings for the *submodule* state_machine
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace state_machine"""

    # Base Class for Events, abstract so you never instantiate.
    class EventBase:
        """class EventBase"""

        def to_string(self) -> str:
            """/ Returns a string representation of the event"""
            pass

        def __init__(self) -> None:
            """Autogenerated default constructor"""
            pass

    # *
    # * States contain other states and can consume generic
    # * EventBase objects if they have internal or external
    # * transitions on those events and if those transitions' guards are
    # * satisfied. Only one transition can consume an event in a given
    # * state machine.
    # *
    # * There is also a different kind of Event, the tick event, which is
    # * not consumed, but instead executes from the top-level state all
    # * the way to the curently active leaf state.
    # *
    # * Entry and Exit actions also occur whenever a state is entered or
    # * exited, respectively.
    #
    class StateBase:
        """class StateBase"""

        @overload
        def __init__(self) -> None:
            """*
            * @brief Default constructor

            """
            pass

        @overload
        def __init__(self, parent: StateBase) -> None:
            """*
            * @brief Constructor that sets the parent state.
            * @param[in] parent Pointer to parent state

            """
            pass

        def initialize(self) -> None:
            """*
            * @brief Will be generated to call entry() then handle any child
            *  initialization. Finally calls makeActive on the leaf.

            """
            pass

        def entry(self) -> None:
            """*
            * @brief Will be generated to run the entry() function defined in
            *  the model.

            """
            pass

        def exit(self) -> None:
            """*
            * @brief Will be generated to run the exit() function defined in
            *   the model.

            """
            pass

        def handle_event(self, event: EventBase) -> bool:
            """*
            * @brief Calls handleEvent on the activeLeaf.
            * @param[in] event Event needing to be handled
            * @return True if event is consumed, False otherwise

            """
            pass

        def tick(self) -> None:
            """*
            * @brief Will be generated to run the tick() function defined in
            *  the model and then call _activeState->tick().

            """
            pass

        def get_timer_period(self) -> float:
            """*
            * @brief Returns the timer period for the state.

            """
            pass

        def get_initial(self) -> StateBase:
            """*
            * @brief Will be known from the model so will be generated in
            *  derived classes to immediately return the correct initial
            *  state pointer for quickly transitioning to the proper state
            *  during external transition handling.
            * @return Pointer to initial substate

            """
            pass

        def exit_children(self) -> None:
            """*
            * @brief Recurses down to the leaf state and calls the exit
            *  actions as it unwinds.

            """
            pass

        def get_active_child(self) -> StateBase:
            """*
            * @brief Will return _activeState if it exists, otherwise will
            *  return None.
            * @return Pointer to last active substate

            """
            pass

        def get_active_leaf(self) -> StateBase:
            """*
            * @brief Will return the active leaf state, otherwise will return
            *  None.
            * @return Pointer to last active leaf state.

            """
            pass

        def make_active(self) -> None:
            """*
            * @brief Make this state the active substate of its parent and
            *  then recurse up through the tree to the root.
            * @note Should only be called on leaf nodes!

            """
            pass

        def set_active_child(self, child_state: StateBase) -> None:
            """*
            * @brief Update the active child state.

            """
            pass

        def set_shallow_history(self) -> None:
            """*
            * @brief Sets the currentlyActive state to the last active state
            *  and re-initializes them.

            """
            pass

        def set_deep_history(self) -> None:
            """*
            * @brief Go to the last active leaf of this state. If none
            *  exists, re-initialize.

            """
            pass

        def set_parent_state(self, parent: StateBase) -> None:
            """*
            * @brief Will set the parent state.
            * @param[in] parent Pointer to parent state

            """
            pass

        def get_parent_state(self) -> StateBase:
            """*
            * @brief Will return the parent state.

            """
            pass
        # Pointer to the currently or most recently active substate of this
        # state.
        _active_state: StateBase

        # Pointer to the parent state of this state.
        _parent_state: StateBase

# </submodule state_machine>
####################    </generated_from:state_base.hpp>    ####################

####################    <generated_from:rtsp_server.hpp>    ####################

class RtspServer:
    """/ Class for streaming MJPEG data from a camera using RTSP + RTP
    / Starts a TCP socket to listen for RTSP connections, and then spawns off a
    / new RTSP session for each connection.
    / @see RtspSession
    / @note This class does not currently send RTCP packets
    /
    / \section RtspServer example
    / \snippet rtsp_example.cpp rtsp_server_example
    """

    class Config:
        """/ @brief Configuration for the RTSP server"""

        server_address: str  # /< The ip address of the server
        port: int  # /< The port to listen on
        path: str  # /< The path to the RTSP stream
        max_data_size: int = (
            1000  # /< The maximum size of RTP packet data for the MJPEG stream. Frames will be broken
        )
        # /< up into multiple packets if they are larger than this. It seems that 1500 works
        # /< well for sending, but is too large for the esp32 (camera-display) to receive
        # /< properly.
        log_level: Logger.Verbosity = (
            Logger.Verbosity.WARN
        )  # /< The log level for the RTSP server
        def __init__(
            self,
            server_address: str = "",
            port: int = int(),
            path: str = "",
            max_data_size: int = 1000,
            log_level: Logger.Verbosity = Logger.Verbosity.WARN,
        ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def set_session_log_level(self, log_level: Logger.Verbosity) -> None:
        """/ @brief Sets the log level for the RTSP sessions created by this server
        / @note This does not affect the log level of the RTSP server itself
        / @note This does not change the log level of any sessions that have
        /       already been created
        / @param log_level The log level to set
        """
        pass

    def start(self) -> bool:
        """/ @brief Start the RTSP server
        / Starts the accept task, session task, and binds the RTSP socket
        / @return True if the server was started successfully, False otherwise
        """
        pass

    def stop(self) -> None:
        """/ @brief Stop the FTP server
        / Stops the accept task, session task, and closes the RTSP socket
        """
        pass

    def send_frame(self, frame: JpegFrame) -> None:
        """/ @brief Send a frame over the RTSP connection
        / Converts the full JPEG frame into a series of simplified RTP/JPEG
        / packets and stores it to be sent over the RTP socket, but does not
        / actually send it
        / @note Overwrites any existing frame that has not been sent
        / @param frame The frame to send
        """
        pass

    def __init__(self) -> None:
        """Autogenerated default constructor"""
        pass

####################    </generated_from:rtsp_server.hpp>    ####################

####################    <generated_from:color.hpp>    ####################

class Rgb:
    """*
    * @brief Class representing a color using RGB color space.

    """

    r: float = float(0)  # /< Red value ∈ [0, 1]
    g: float = float(0)  # /< Green value ∈ [0, 1]
    b: float = float(0)  # /< Blue value ∈ [0, 1]

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, r: float, g: float, b: float) -> None:
        """*
        * @brief Construct an Rgb object from the provided rgb values.
        * @note If provided values outside the range [0,1], it will rescale them to
        *       be within the range [0,1] by dividing by 255.
        * @param r Floating point value for the red channel, should be in range [0,
        *        1]
        * @param g Floating point value for the green channel, should be in range
        *        [0, 1]
        * @param b Floating point value for the blue channel, should be in range
        *        [0, 1]

        """
        pass

    @overload
    def __init__(self, rgb: Rgb) -> None:
        """*
        * @brief Copy-construct an Rgb object from the provided object.
        * @note If provided values outside the range [0,1], it will rescale them to
        *       be within the range [0,1] by dividing by 255.
        * @param rgb Rgb struct containing the values to copy.

        """
        pass

    @overload
    def __init__(self, hsv: Hsv) -> None:
        """*
        * @brief Construct an Rgb object from the provided Hsv object.
        * @note This calls hsv.rgb() on the provided object, which means fthat
        *       invalid HSV data (not in the ranges [0,360], [0,1], and [0,1])
        *       could lead to bad RGB data. The Rgb constructor will automatically
        *       convert the values to be in the proper range, but the perceived
        *       color will be changed.
        * @param hsv Hsv object to copy.

        """
        pass

    def __add__(self, rhs: Rgb) -> Rgb:
        """*
        * @brief Perform additive color blending (averaging)
        * @param rhs Other color to add to this color to create the resultant color
        * @return Resultant color from blending this color with the \p rhs color.

        """
        pass

    def __iadd__(self, rhs: Rgb) -> Rgb:
        """*
        * @brief Perform additive color blending (averaging)
        * @param rhs Other color to add to this color

        """
        pass

    def __eq__(self, rhs: Rgb) -> bool:
        pass

    def __ne__(self, rhs: Rgb) -> bool:
        pass

    def hsv(self) -> Hsv:
        """*
        * @brief Get a HSV representation of this RGB color.
        * @return An HSV object containing the HSV representation.

        """
        pass

class Hsv:
    """*
    * @brief Class representing a color using HSV color space.

    """

    h: float = float(0)  # /< Hue ∈ [0, 360]
    s: float = float(0)  # /< Saturation ∈ [0, 1]
    v: float = float(0)  # /< Value ∈ [0, 1]

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, h: float, s: float, v: float) -> None:
        """*
        * @brief Construct a Hsv object from the provided values.
        * @param h Hue - will be clamped to be in range [0, 360]
        * @param s Saturation - will be clamped to be in range [0, 1]
        * @param v Value - will be clamped to be in range [0, 1]

        """
        pass

    @overload
    def __init__(self, hsv: Hsv) -> None:
        """*
        * @brief Copy-construct the Hsv object
        * @param hsv Object to copy from.

        """
        pass

    @overload
    def __init__(self, rgb: Rgb) -> None:
        """*
        * @brief Construct Hsv object from Rgb object. Calls rgb.hsv() to perform
        *        the conversion.
        * @param rgb The Rgb object to convert and copy.

        """
        pass

    def __eq__(self, rhs: Hsv) -> bool:
        pass

    def __ne__(self, rhs: Hsv) -> bool:
        pass

    def rgb(self) -> Rgb:
        """*
        * @brief Get a RGB representation of this HSV color.
        * @return An RGB object containing the RGB representation.

        """
        pass

####################    </generated_from:color.hpp>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
