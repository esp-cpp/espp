# If you want to use mypy or pyright, you may have to ignore some errors, like below:

# mypy: disable-error-code="type-arg"

from typing import overload, List

NumberType = (int, float, np.number)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:base_component.hpp>    ####################



class BaseComponent:
    """/ Base class for all components
    / Provides a logger and some basic logging configuration
    """
    def get_name(self) -> str:
        """/ Get the name of the component
        / \return A const reference to the name of the component
        / \note This is the tag of the logger
        """
        pass

    def set_log_tag(self, tag: std.string_view) -> None:
        """/ Set the tag for the logger
        / \param tag The tag to use for the logger
        """
        pass

    def get_log_level(self) -> Logger.Verbosity:
        """/ Get the log level for the logger
        / \return The verbosity level of the logger
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def set_log_level(self, level: Logger.Verbosity) -> None:
        """/ Set the log level for the logger
        / \param level The verbosity level to use for the logger
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def set_log_verbosity(self, level: Logger.Verbosity) -> None:
        """/ Set the log verbosity for the logger
        / \param level The verbosity level to use for the logger
        / \note This is a convenience method that calls set_log_level
        / \sa set_log_level
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def get_log_verbosity(self) -> Logger.Verbosity:
        """/ Get the log verbosity for the logger
        / \return The verbosity level of the logger
        / \note This is a convenience method that calls get_log_level
        / \sa get_log_level
        / \sa Logger::Verbosity
        / \sa Logger::get_verbosity
        """
        pass

    def set_log_rate_limit(self, rate_limit: std.chrono.duration<float>) -> None:
        """/ Set the rate limit for the logger
        / \param rate_limit The rate limit to use for the logger
        / \note Only calls to the logger that have _rate_limit suffix will be rate limited
        / \sa Logger::set_rate_limit
        """
        pass


####################    </generated_from:base_component.hpp>    ####################


####################    <generated_from:color.hpp>    ####################




class Rgb:
    """*
     * @brief Class representing a color using RGB color space.

    """
    r: float = float(0)  #/< Red value ∈ [0, 1]
    g: float = float(0)  #/< Green value ∈ [0, 1]
    b: float = float(0)  #/< Blue value ∈ [0, 1]

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, r: float, g: float, b: float) -> None:
        """*
           * @brief Construct an Rgb object from the provided rgb values.
           * @note If provided values outside the range [0,1], it will rescale them to
           *       be within the range [0,1] by dividing by 255.
           * @param r Floating point value for the red channel, should be in range [0,
           *        1]
           * @param g Floating point value for the green channel, should be in range
           *        [0, 1]
           * @param b Floating point value for the blue channel, should be in range
           *        [0, 1]

        """
        pass

    @overload
    def __init__(self, rgb: Rgb) -> None:
        """*
           * @brief Copy-construct an Rgb object from the provided object.
           * @note If provided values outside the range [0,1], it will rescale them to
           *       be within the range [0,1] by dividing by 255.
           * @param rgb Rgb struct containing the values to copy.

        """
        pass

    @overload
    def __init__(self, hsv: Hsv) -> None:
        """*
           * @brief Construct an Rgb object from the provided Hsv object.
           * @note This calls hsv.rgb() on the provided object, which means that invalid
           *       HSV data (not in the ranges [0,360], [0,1], and [0,1]) could lead to
           *       bad RGB data. The Rgb constructor will automatically convert the
           *       values to be in the proper range, but the perceived color will be
           *       changed.
           * @param hsv Hsv object to copy.

        """
        pass

    @overload
    def __init__(self, hex: int) -> None:
        """*
           * @brief Construct an Rgb object from the provided hex value.
           * @param hex Hex value to convert to RGB. The hex value should be in the
           *        format 0xRRGGBB.

        """
        pass



    def __add__(self, rhs: Rgb) -> Rgb:
        """*
           * @brief Perform additive color blending (averaging)
           * @param rhs Other color to add to this color to create the resultant color
           * @return Resultant color from blending this color with the \p rhs color.

        """
        pass

    def __iadd__(self, rhs: Rgb) -> Rgb:
        """*
           * @brief Perform additive color blending (averaging)
           * @param rhs Other color to add to this color

        """
        pass

    def __eq__(self, rhs: Rgb) -> bool:
        pass

    def __ne__(self, rhs: Rgb) -> bool:
        pass

    def hsv(self) -> Hsv:
        """*
           * @brief Get a HSV representation of this RGB color.
           * @return An HSV object containing the HSV representation.

        """
        pass

    def hex(self) -> int:
        """*
           * @brief Get the hex representation of this RGB color.
           * @return The hex representation of this RGB color.

        """
        pass

class Hsv:
    """*
     * @brief Class representing a color using HSV color space.

    """
    h: float = float(0)  #/< Hue ∈ [0, 360]
    s: float = float(0)  #/< Saturation ∈ [0, 1]
    v: float = float(0)  #/< Value ∈ [0, 1]

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, h: float, s: float, v: float) -> None:
        """*
           * @brief Construct a Hsv object from the provided values.
           * @param h Hue - will be clamped to be in range [0, 360]
           * @param s Saturation - will be clamped to be in range [0, 1]
           * @param v Value - will be clamped to be in range [0, 1]

        """
        pass

    @overload
    def __init__(self, hsv: Hsv) -> None:
        """*
           * @brief Copy-construct the Hsv object
           * @param hsv Object to copy from.

        """
        pass

    @overload
    def __init__(self, rgb: Rgb) -> None:
        """*
           * @brief Construct Hsv object from Rgb object. Calls rgb.hsv() to perform
           *        the conversion.
           * @param rgb The Rgb object to convert and copy.

        """
        pass


    def __eq__(self, rhs: Hsv) -> bool:
        pass

    def __ne__(self, rhs: Hsv) -> bool:
        pass


    def rgb(self) -> Rgb:
        """*
           * @brief Get a RGB representation of this HSV color.
           * @return An RGB object containing the RGB representation.

        """
        pass

@overload
def color_code(rgb: Rgb) -> Any:
    """
    (C++ auto return type)
    """
    pass
@overload
def color_code(hsv: Hsv) -> Any:
    """
    (C++ auto return type)
    """
    pass


# namespace espp

####################    </generated_from:color.hpp>    ####################


####################    <generated_from:event_manager.hpp>    ####################



class EventManager:
    """*
     * @brief Singleton class for managing events. Provides mechanisms for
     *        anonymous publish / subscribe interactions - enabling one to one,
     *        one to many, many to one, and many to many data distribution with
     *        loose coupling and low overhead. Each topic runs a thread for that
     *        topic's subscribers, executing all the callbacks in sequence and
     *        then going to sleep again until new data is published.
     *
     * @note In c++ objects, it's recommended to call the
     *       add_publisher/add_subscriber functions in the class constructor and
     *       then to call the remove_publisher/remove_subscriber functions in the
     *       class destructor.
     *
     * @note It is recommended (unless you are only interested in events and not
     *       data or are only needing to transmit actual strings) to use a
     *       serialization library (such as espp::serialization - which wraps
     *       alpaca) to serialize your data structures to string when publishing
     *       and then deserialize your data from string in the subscriber
     *       callbacks.
     *
     * \section event_manager_ex1 Event Manager Example
     * \snippet event_manager_example.cpp event manager example

    """

    @staticmethod
    def get() -> EventManager:
        """*
           * @brief Get the singleton instance of the EventManager.
           * @return A reference to the EventManager singleton.

        """
        pass


    def add_publisher(self, topic: str, component: str) -> bool:
        """*
           * @brief Register a publisher for \p component on \p topic.
           * @param topic Topic name for the data being published.
           * @param component Name of the component publishing data.
           * @return True if the publisher was added, False if it was already
           *         registered for that component.

        """
        pass

    @overload
    def add_subscriber(
        self,
        topic: str,
        component: str,
        callback: EventManager.event_callback_fn,
        stack_size_bytes: int = 8192
        ) -> bool:
        """*
           * @brief Register a subscriber for \p component on \p topic.
           * @param topic Topic name for the data being subscribed to.
           * @param component Name of the component publishing data.
           * @param callback The event_callback_fn to be called when receicing data on
           *        \p topic.
           * @param stack_size_bytes The stack size in bytes to use for the subscriber
           * @note The stack size is only used if a subscriber is not already registered
           *       for that topic. If a subscriber is already registered for that topic,
           *       the stack size is ignored.
           * @return True if the subscriber was added, False if it was already
           *         registered for that component.

        """
        pass

    @overload
    def add_subscriber(
        self,
        topic: str,
        component: str,
        callback: EventManager.event_callback_fn,
        task_config: Task.BaseConfig
        ) -> bool:
        """*
           * @brief Register a subscriber for \p component on \p topic.
           * @param topic Topic name for the data being subscribed to.
           * @param component Name of the component publishing data.
           * @param callback The event_callback_fn to be called when receicing data on
           *        \p topic.
           * @param task_config The task configuration to use for the subscriber.
           * @note The task_config is only used if a subscriber is not already
           *       registered for that topic. If a subscriber is already registered for
           *       that topic, the task_config is ignored.
           * @return True if the subscriber was added, False if it was already
           *         registered for that component.

        """
        pass

    def publish(self, topic: str, data: List[int]) -> bool:
        """*
           * @brief Publish \p data on \p topic.
           * @param topic Topic to publish data on.
           * @param data Data to publish, within a vector container.
           * @return True if \p data was successfully published to \p topic, False
           *         otherwise. Publish will not occur (and will return False) if
           *         there are no subscribers for this topic.

        """
        pass

    def remove_publisher(self, topic: str, component: str) -> bool:
        """*
           * @brief Remove \p component's publisher for \p topic.
           * @param topic The topic that \p component was publishing on.
           * @param component The component for which the publisher was registered.
           * @return True if the publisher was removed, False if it was not
           *         registered.

        """
        pass

    def remove_subscriber(self, topic: str, component: str) -> bool:
        """*
           * @brief Remove \p component's subscriber for \p topic.
           * @param topic The topic that \p component was subscribing to.
           * @param component The component for which the subscriber was registered.
           * @return True if the subscriber was removed, False if it was not
           *         registered.

        """
        pass


####################    </generated_from:event_manager.hpp>    ####################


####################    <generated_from:ftp_server.hpp>    ####################





class FtpServer:
    """/ \brief A class that implements a FTP server."""
    def __init__(
        self,
        ip_address: std.string_view,
        port: int,
        root: std.filesystem.path
        ) -> None:
        """/ \brief A class that implements a FTP server.
        / \note The IP Address is not currently used to select the right
        /       interface, but is instead passed to the FtpClientSession so that
        /       it can be used in the PASV command.
        / \param ip_address The IP address to listen on.
        / \param port The port to listen on.
        / \param root The root directory of the FTP server.
        """
        pass


    def start(self) -> bool:
        """/ \brief Start the FTP server.
        / Bind to the port and start accepting connections.
        / \return True if the server was started, False otherwise.
        """
        pass

    def stop(self) -> None:
        """/ \brief Stop the FTP server."""
        pass


####################    </generated_from:ftp_server.hpp>    ####################


####################    <generated_from:logger.hpp>    ####################





class Logger:
    """*
     * @brief Logger provides a wrapper around nicer / more robust formatting than
     * standard ESP_LOG* macros with the ability to change the log level at
     * run-time. Logger currently is a light wrapper around libfmt (future
     * std::format).
     *
     * To save on code size, the logger has the ability to be compiled out based on
     * the log level set in the sdkconfig. This means that if the log level is set to
     * ERROR, all debug, info, and warn logs will be compiled out. This is done by
     * checking the log level at compile time and only compiling in the functions
     * that are needed.
     *
     * \section logger_ex1 Basic Example
     * \snippet logger_example.cpp Logger example
     * \section logger_ex2 Threaded Logging and Verbosity Example
     * \snippet logger_example.cpp MultiLogger example

    """
    class Verbosity(enum.Enum):
        """*
           *   Verbosity levels for the logger, in order of increasing priority.

        """
        debug = enum.auto()                                                     # (= 0)  #*< Debug level verbosity.
        info = enum.auto()                                                      # (= 1)  #*< Info level verbosity.
        warn = enum.auto()                                                      # (= 2)  #*< Warn level verbosity.
        error = enum.auto()                                                     # (= 3)  #*< Error level verbosity.
        none = enum.auto()                                                      # (= 4)  #*< No verbosity - logger will not print anything.

    class Config:
        """*
           * @brief Configuration struct for the logger.

        """
        tag: std.string_view                                                    #*< The TAG that will be prepended to all logs.
        include_time: bool = bool(True)                                         #*< Include the time in the log.
        rate_limit: std.chrono.duration<float> = std.chrono.duration<float>(0)  #*< The rate limit for the logger. Optional, if <= 0 no
        rate limit. @note Only calls that have _rate_limited suffixed will be rate limited.
        level: espp.Logger.Verbosity = espp.Logger.Verbosity.warn               #*< The verbosity level for the logger.
        def __init__(
            self,
            tag: std.string_view = std.string_view(),
            include_time: bool = bool(True),
            rate_limit: std.chrono.duration<float> = std.chrono.duration<float>(0),
            level: Logger.Verbosity = Logger.Verbosity.warn
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass


    def set_verbosity(self, level: Logger.Verbosity) -> None:
        """*
           * @brief Change the verbosity for the logger. \sa Logger::Verbosity
           * @param level new verbosity level

        """
        pass

    def set_tag(self, tag: std.string_view) -> None:
        """*
           * @brief Change the tag for the logger.
           * @param tag The new tag.

        """
        pass

    def get_tag(self) -> str:
        """*
           * @brief Get the current tag for the logger.
           * @return A const reference to the current tag.

        """
        pass

    def set_include_time(self, include_time: bool) -> None:
        """*
           * @brief Whether to include the time in the log.
           * @param include_time Whether to include the time in the log.
           * @note The time is in seconds since boot and is represented as a floating
           *       point number with precision to the millisecond.

        """
        pass

    def set_rate_limit(self, rate_limit: std.chrono.duration<float>) -> None:
        """*
           * @brief Change the rate limit for the logger.
           * @param rate_limit The new rate limit.
           * @note Only calls that have _rate_limited suffixed will be rate limited.

        """
        pass

    def get_rate_limit(self) -> std.chrono.duration<float>:
        """*
           * @brief Get the current rate limit for the logger.
           * @return The current rate limit.

        """
        pass










    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:logger.hpp>    ####################


####################    <generated_from:bezier.hpp>    ####################


#  ------------------------------------------------------------------------
#      <template specializations for class Bezier>
class Bezier_espp_Vector2f:  # Python specialization for Bezier<espp::Vector2f>
    """*
     * @brief Implements rational / weighted and unweighted cubic bezier curves
     *        between control points.
     * @note See https://pomax.github.io/bezierinfo/ for information on bezier
     *       curves.
     * @note Template class which can be used individually on floating point
     *       values directly or on containers such as Vector2<float>.
     * @tparam T The type of the control points, e.g. float or Vector2<float>.
     * @note The bezier curve is defined by 4 control points, P0, P1, P2, P3.
     *      The curve is defined by the equation:
     *      \f$B(t) = (1-t)^3 * P0 + 3 * (1-t)^2 * t * P1 + 3 * (1-t) * t^2 * P2 + t^3 * P3\f$
     *      where t is the evaluation parameter, [0, 1].
     *
     * @note The weighted bezier curve is defined by 4 control points, P0, P1, P2, P3
     *      and 4 weights, W0, W1, W2, W3.
     *      The curve is defined by the equation:
     *      \f$B(t) = (W0 * (1-t)^3 * P0 + W1 * 3 * (1-t)^2 * t * P1 + W2 * 3 * (1-t) * t^2 * P2 + W3 *
     * t^3 * P3) / (W0 + W1 + W2 + W3)\f$ where t is the evaluation parameter, [0, 1].
     *
     * \section bezier_ex1 Example
     * \snippet math_example.cpp bezier example

    """
    class Config:
        """*
           * @brief Unweighted cubic bezier configuration for 4 control points.

        """
        control_points: List[espp.Vector2f]       #/< Array of 4 control points
        def __init__(self) -> None:
            """Auto-generated default constructor"""
            pass

    class WeightedConfig:
        """*
           * @brief Weighted cubic bezier configuration for 4 control points with
           *        individual weights.

        """
        control_points: List[espp.Vector2f]       #/< Array of 4 control points
        weights: List[float] = List[float](1.0, 1.0, 1.0,
                                            1.0)  #/< Array of 4 weights, default is array of 1.0
        def __init__(self) -> None:
            """Auto-generated default constructor"""
            pass



    def __call__(self, t: float) -> Vector2f:
        """*
           * @brief Evaluate the bezier at \p t.
           * @note Convienience wrapper around the at() method.
           * @param t The evaluation parameter, [0, 1].
           * @return The bezier evaluated at \p t.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass
#      </template specializations for class Bezier>
#  ------------------------------------------------------------------------

####################    </generated_from:bezier.hpp>    ####################


####################    <generated_from:fast_math.hpp>    ####################


def square(f: float) -> float:
    """*
     * @brief Simple square of the input.
     * @param f Value to square.
     * @return The square of f (f*f).

    """
    pass

def cube(f: float) -> float:
    """*
     * @brief Simple cube of the input.
     * @param f Value to cube.
     * @return The cube of f (f*f*f).

    """
    pass

def fast_sqrt(value: float) -> float:
    """*
     * @brief Fast square root approximation.
     * @note Using https://reprap.org/forum/read.php?147,219210 and
     *       https://en.wikipedia.org/wiki/Fast_inverse_square_root
     * @param value Value to take the square root of.
     * @return Approximation of the square root of value.

    """
    pass

#  ------------------------------------------------------------------------
#      <template specializations for function sgn>
@overload
def sgn(x: int) -> int:
    """*
     * @brief Get the sign of a number (+1, 0, or -1)
     * @param x Value to get the sign of
     * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0

    """
    pass


@overload
def sgn(x: float) -> int:
    """*
     * @brief Get the sign of a number (+1, 0, or -1)
     * @param x Value to get the sign of
     * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0

    """
    pass
#      </template specializations for function sgn>
#  ------------------------------------------------------------------------

def lerp(a: float, b: float, t: float) -> float:
    """*
     * @brief Linear interpolation between two values.
     * @param a First value.
     * @param b Second value.
     * @param t Interpolation factor in the range [0, 1].
     * @return Linear interpolation between a and b.

    """
    pass

def inv_lerp(a: float, b: float, v: float) -> float:
    """*
     * @brief Compute the inverse lerped value.
     * @param a First value (usually the lower of the two).
     * @param b Second value (usually the higher of the two).
     * @param v Value to inverse lerp (usually a value between a and b).
     * @return Inverse lerp value, the factor of v between a and b in the range [0,
     *         1] if v is between a and b, 0 if v == a, or 1 if v == b. If a == b,
     *         0 is returned. If v is outside the range [a, b], the value is
     *         extrapolated linearly (i.e. if v < a, the value is less than 0, if v
     *         > b, the value is greater than 1).

    """
    pass

def piecewise_linear(points: std.vector<Tuple[float, float>], x: float) -> float:
    """*
     * @brief Compute the piecewise linear interpolation between a set of points.
     * @param points Vector of points to interpolate between. The vector should be
     *               sorted by the first value in the pair. The first value in the
     *               pair is the x value and the second value is the y value. The x
     *               values should be unique. The function will interpolate between
     *               the points using linear interpolation. If x is less than the
     *               first x value, the first y value is returned. If x is greater
     *               than the last x value, the last y value is returned. If x is
     *               between two x values, the y value is interpolated between the
     *               two y values.
     * @param x Value to interpolate at. Should be a value from the first
     *          distribution of the points (the domain). If x is outside the domain
     *          of the points, the value returned will be clamped to the first or
     *          last y value.
     * @return Interpolated value at x.

    """
    pass

def round(x: float) -> int:
    """*
     * @brief Round x to the nearest integer.
     * @param x Floating point value to be rounded.
     * @return Nearest integer to x.

    """
    pass

def fast_ln(x: float) -> float:
    """*
     * @brief fast natural log function, ln(x).
     * @note This speed hack comes from:
     *   https://gist.github.com/LingDong-/7e4c4cae5cbbc44400a05ba650623
     * @param x Value to take the natural log of.
     * @return ln(x)

    """
    pass


def fast_sin(angle: float) -> float:
    """*
     * @brief Fast approximation of sin(angle) (radians).
     * @note \p Angle must be in the range [0, 2PI].
     * @param angle Angle in radians [0, 2*PI]
     * @return Approximation of sin(value)

    """
    pass

def fast_cos(angle: float) -> float:
    """*
     * @brief Fast approximation of cos(angle) (radians).
     * @note \p Angle must be in the range [0, 2PI].
     * @param angle Angle in radians [0, 2*PI]
     * @return Approximation of cos(value)

    """
    pass

####################    </generated_from:fast_math.hpp>    ####################


####################    <generated_from:gaussian.hpp>    ####################


class Gaussian:
    """*
     * @brief Implements a gaussian function
     *        \f$y(t)=\alpha\exp(-\frac{(t-\beta)^2}{2\gamma^2})\f$.
     * @details Alows you to store the alpha, beta, and gamma coefficients as well
     *          as update them dynamically.
     *
     * \section gaussian_ex1 Example
     * \snippet math_example.cpp gaussian example
     * \section gaussian_ex2 Fade-In/Fade-Out Example
     * \snippet math_example.cpp gaussian fade in fade out example

    """
    class Config:
        """*
           * @brief Configuration structure for initializing the gaussian.

        """
        gamma: float               #/< Slope of the gaussian, range [0, 1]. 0 is more of a thin spike from 0 up to
        #/< max output (alpha), 1 is more of a small wave around the max output (alpha).
        alpha: float = float(1.0)  #/< Max amplitude of the gaussian output, defautls to 1.0.
        beta: float = float(0.5)   #/< Beta value for the gaussian, default to be symmetric at 0.5 in range [0,1].

        def __eq__(self, rhs: Gaussian.Config) -> bool:
            pass
        def __init__(
            self,
            gamma: float = float(),
            alpha: float = float(1.0),
            beta: float = float(0.5)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass


    def __call__(self, t: float) -> float:
        """*
           * @brief Evaluate the gaussian at \p t.
           * @note Convienience wrapper around the at() method.
           * @param t The evaluation parameter, [0, 1].
           * @return The gaussian evaluated at \p t.

        """
        pass

    def update(self, config: Gaussian.Config) -> None:
        """*
           * @brief Update the gaussian configuration.
           * @param config The new configuration.

        """
        pass

    def set_config(self, config: Gaussian.Config) -> None:
        """*
           * @brief Set the configuration of the gaussian.
           * @param config The new configuration.

        """
        pass

    def get_config(self) -> Gaussian.Config:
        """*
           * @brief Get the current configuration of the gaussian.
           * @return The current configuration.

        """
        pass

    def get_gamma(self) -> float:
        """*
           * @brief Get the gamma value.
           * @return The gamma value.

        """
        pass

    def get_alpha(self) -> float:
        """*
           * @brief Get the alpha value.
           * @return The alpha value.

        """
        pass

    def get_beta(self) -> float:
        """*
           * @brief Get the beta value.
           * @return The beta value.

        """
        pass

    def set_gamma(self, gamma: float) -> None:
        """*
           * @brief Set the gamma value.
           * @param gamma The new gamma value.

        """
        pass

    def set_alpha(self, alpha: float) -> None:
        """*
           * @brief Set the alpha value.
           * @param alpha The new alpha value.

        """
        pass

    def set_beta(self, beta: float) -> None:
        """*
           * @brief Set the beta value.
           * @param beta The new beta value.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:gaussian.hpp>    ####################


####################    <generated_from:range_mapper.hpp>    ####################


#  ------------------------------------------------------------------------
#      <template specializations for class RangeMapper>
class RangeMapper_int:  # Python specialization for RangeMapper<int>
    """*
     * @brief Template class for converting a value from an uncentered [minimum,
     *        maximum] range into a centered output range (default [-1,1]). If
     *        provided a non-zero deadband, it will convert all values within
     *        [center-deadband, center+deadband] to be the configured
     *        output_center (default 0).
     *
     *        The RangeMapper can be optionally configured to invert the input,
     *        so that it will compute the input w.r.t. the configured min/max of
     *        the input range when mapping to the output range - this will mean
     *        that a values within the ranges [minimum, minimum+deadband] and
     *        [maximum-deadband, maximum] will all map to the output_center and
     *        the input center will map to both output_max and output_min
     *        depending on the sign of the input.
     *
     * @note When inverting the input range, you are introducing a discontinuity
     *       between the input distribution and the output distribution at the
     *       input center. Noise around the input's center value will create
     *       oscillations in the output which will jump between output maximum
     *       and output minimum. Therefore it is advised to use \p invert_input
     *       sparignly, and to set the values robustly.
     *
     *        The RangeMapper can be optionally configured to invert the output,
     *        so that after converting from the input range to the output range,
     *        it will flip the sign on the output.
     *
     * \section range_mapper_ex1 Example
     * \snippet math_example.cpp range_mapper example

    """
    class Config:
        """*
           *  @brief Configuration for the input uncentered range with optional
           *  values for the centered output range, default values of 0 output center
           *  and 1 output range provide a default output range between [-1, 1].

        """
        center: int                  #*< Center value for the input range.
        center_deadband: int = 0     #*< Deadband amount around (+-) the center for which output will be 0.
        minimum: int                 #*< Minimum value for the input range.
        maximum: int                 #*< Maximum value for the input range.
        range_deadband: int = 0      #*< Deadband amount around the minimum and maximum for which output will
                                     be min/max output.
        output_center: int = 0       #*< The center for the output. Default 0.
        output_range: int = 1        #*< The range (+/-) from the center for the output. Default 1. @note Will
                                     be passed through std::abs() to ensure it is positive.
        invert_output: bool = False  #*< Whether to invert the output (default False). @note If True will flip the sign
                          of the output after converting from the input distribution.
        def __init__(
            self,
            center: int = int(),
            center_deadband: int = 0,
            minimum: int = int(),
            maximum: int = int(),
            range_deadband: int = 0,
            output_center: int = 0,
            output_range: int = 1,
            invert_output: bool = False
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def __init__(self) -> None:
        pass


    def get_center_deadband(self) -> int:
        """*
           * @brief Return the configured deadband around the center of the input
           *        distribution
           * @return Deadband around the center of the input distribution for this
           *         range mapper.

        """
        pass

    def get_minimum(self) -> int:
        """*
           * @brief Return the configured minimum of the input distribution
           * @return Minimum of the input distribution for this range mapper.

        """
        pass

    def get_maximum(self) -> int:
        """*
           * @brief Return the configured maximum of the input distribution
           * @return Maximum of the input distribution for this range mapper.

        """
        pass

    def get_range(self) -> int:
        """*
           * @brief Return the configured range of the input distribution
           * @note Always positive.
           * @return Range of the input distribution for this range mapper.

        """
        pass

    def get_range_deadband(self) -> int:
        """*
           * @brief Return the configured deadband around the min/max of the input
           *        distribution
           * @return Deadband around the min/max of the input distribution for this
           *         range mapper.

        """
        pass

    def get_output_center(self) -> int:
        """*
           * @brief Return the configured center of the output distribution
           * @return Center of the output distribution for this range mapper.

        """
        pass

    def get_output_range(self) -> int:
        """*
           * @brief Return the configured range of the output distribution
           * @note Always positive.
           * @return Range of the output distribution for this range mapper.

        """
        pass

    def get_output_min(self) -> int:
        """*
           * @brief Return the configured minimum of the output distribution
           * @return Minimum of the output distribution for this range mapper.

        """
        pass

    def get_output_max(self) -> int:
        """*
           * @brief Return the configured maximum of the output distribution
           * @return Maximum of the output distribution for this range mapper.

        """
        pass

    def set_center_deadband(self, deadband: int) -> None:
        """*
           * @brief Set the deadband around the center of the input distribution.
           * @param deadband The deadband to use around the center of the input
           *        distribution.
           * @note The deadband must be non-negative.
           * @note The deadband is applied around the center value of the input
           *       distribution.

        """
        pass

    def set_range_deadband(self, deadband: int) -> None:
        """*
           * @brief Set the deadband around the min/max of the input distribution.
           * @param deadband The deadband to use around the min/max of the input
           *        distribution.
           * @note The deadband must be non-negative.
           * @note The deadband is applied around the min/max values of the input
           *       distribution.

        """
        pass

    def map(self, v: int) -> int:
        """*
           * @brief Map a value \p v from the input distribution into the configured
           *        output range (centered, default [-1,1]).
           * @param v Value from the (possibly uncentered and possibly inverted -
           *        defined by the previously configured Config) input distribution
           * @return Value within the centered output distribution.

        """
        pass

    def unmap(self, v: int) -> int:
        """*
           * @brief Unmap a value \p v from the configured output range (centered,
           *        default [-1,1]) back into the input distribution.
           * @param T&v Value from the centered output distribution.
           * @return Value within the input distribution.

        """
        pass



class RangeMapper_float:  # Python specialization for RangeMapper<float>
    """*
     * @brief Template class for converting a value from an uncentered [minimum,
     *        maximum] range into a centered output range (default [-1,1]). If
     *        provided a non-zero deadband, it will convert all values within
     *        [center-deadband, center+deadband] to be the configured
     *        output_center (default 0).
     *
     *        The RangeMapper can be optionally configured to invert the input,
     *        so that it will compute the input w.r.t. the configured min/max of
     *        the input range when mapping to the output range - this will mean
     *        that a values within the ranges [minimum, minimum+deadband] and
     *        [maximum-deadband, maximum] will all map to the output_center and
     *        the input center will map to both output_max and output_min
     *        depending on the sign of the input.
     *
     * @note When inverting the input range, you are introducing a discontinuity
     *       between the input distribution and the output distribution at the
     *       input center. Noise around the input's center value will create
     *       oscillations in the output which will jump between output maximum
     *       and output minimum. Therefore it is advised to use \p invert_input
     *       sparignly, and to set the values robustly.
     *
     *        The RangeMapper can be optionally configured to invert the output,
     *        so that after converting from the input range to the output range,
     *        it will flip the sign on the output.
     *
     * \section range_mapper_ex1 Example
     * \snippet math_example.cpp range_mapper example

    """
    class Config:
        """*
           *  @brief Configuration for the input uncentered range with optional
           *  values for the centered output range, default values of 0 output center
           *  and 1 output range provide a default output range between [-1, 1].

        """
        center: float                #*< Center value for the input range.
        center_deadband: float = 0   #*< Deadband amount around (+-) the center for which output will be 0.
        minimum: float               #*< Minimum value for the input range.
        maximum: float               #*< Maximum value for the input range.
        range_deadband: float = 0    #*< Deadband amount around the minimum and maximum for which output will
                                     be min/max output.
        output_center: float = 0     #*< The center for the output. Default 0.
        output_range: float = 1      #*< The range (+/-) from the center for the output. Default 1. @note Will
                                     be passed through std::abs() to ensure it is positive.
        invert_output: bool = False  #*< Whether to invert the output (default False). @note If True will flip the sign
                          of the output after converting from the input distribution.
        def __init__(
            self,
            center: float = float(),
            center_deadband: float = 0,
            minimum: float = float(),
            maximum: float = float(),
            range_deadband: float = 0,
            output_center: float = 0,
            output_range: float = 1,
            invert_output: bool = False
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def __init__(self) -> None:
        pass


    def get_center_deadband(self) -> float:
        """*
           * @brief Return the configured deadband around the center of the input
           *        distribution
           * @return Deadband around the center of the input distribution for this
           *         range mapper.

        """
        pass

    def get_minimum(self) -> float:
        """*
           * @brief Return the configured minimum of the input distribution
           * @return Minimum of the input distribution for this range mapper.

        """
        pass

    def get_maximum(self) -> float:
        """*
           * @brief Return the configured maximum of the input distribution
           * @return Maximum of the input distribution for this range mapper.

        """
        pass

    def get_range(self) -> float:
        """*
           * @brief Return the configured range of the input distribution
           * @note Always positive.
           * @return Range of the input distribution for this range mapper.

        """
        pass

    def get_range_deadband(self) -> float:
        """*
           * @brief Return the configured deadband around the min/max of the input
           *        distribution
           * @return Deadband around the min/max of the input distribution for this
           *         range mapper.

        """
        pass

    def get_output_center(self) -> float:
        """*
           * @brief Return the configured center of the output distribution
           * @return Center of the output distribution for this range mapper.

        """
        pass

    def get_output_range(self) -> float:
        """*
           * @brief Return the configured range of the output distribution
           * @note Always positive.
           * @return Range of the output distribution for this range mapper.

        """
        pass

    def get_output_min(self) -> float:
        """*
           * @brief Return the configured minimum of the output distribution
           * @return Minimum of the output distribution for this range mapper.

        """
        pass

    def get_output_max(self) -> float:
        """*
           * @brief Return the configured maximum of the output distribution
           * @return Maximum of the output distribution for this range mapper.

        """
        pass

    def set_center_deadband(self, deadband: float) -> None:
        """*
           * @brief Set the deadband around the center of the input distribution.
           * @param deadband The deadband to use around the center of the input
           *        distribution.
           * @note The deadband must be non-negative.
           * @note The deadband is applied around the center value of the input
           *       distribution.

        """
        pass

    def set_range_deadband(self, deadband: float) -> None:
        """*
           * @brief Set the deadband around the min/max of the input distribution.
           * @param deadband The deadband to use around the min/max of the input
           *        distribution.
           * @note The deadband must be non-negative.
           * @note The deadband is applied around the min/max values of the input
           *       distribution.

        """
        pass

    def map(self, v: float) -> float:
        """*
           * @brief Map a value \p v from the input distribution into the configured
           *        output range (centered, default [-1,1]).
           * @param v Value from the (possibly uncentered and possibly inverted -
           *        defined by the previously configured Config) input distribution
           * @return Value within the centered output distribution.

        """
        pass

    def unmap(self, v: float) -> float:
        """*
           * @brief Unmap a value \p v from the configured output range (centered,
           *        default [-1,1]) back into the input distribution.
           * @param T&v Value from the centered output distribution.
           * @return Value within the input distribution.

        """
        pass

#      </template specializations for class RangeMapper>
#  ------------------------------------------------------------------------



# namespace espp

####################    </generated_from:range_mapper.hpp>    ####################


####################    <generated_from:vector2d.hpp>    ####################


#  ------------------------------------------------------------------------
#      <template specializations for class Vector2d>
class Vector2d_int:  # Python specialization for Vector2d<int>
    """*
     * @brief Container representing a 2 dimensional vector.
     *
     * Provides getters/setters, index operator, and vector / scalar math
     * utilities.
     *
     * \section vector_ex1 Example
     * \snippet math_example.cpp vector2 example

    """
    @overload
    def __init__(self, x: int = 0, y: int = 0) -> None:
        """*
           * @brief Constructor for the vector, defaults to 0,0.
           * @param x The starting X value.
           * @param y The starting Y value.

        """
        pass

    @overload
    def __init__(self, other: Vector2d) -> None:
        """*
           * @brief Vector copy constructor.
           * @param other Vector to copy.

        """
        pass


    def magnitude(self) -> int:
        """*
           * @brief Returns vector magnitude: ||v||.
           * @return The magnitude.

        """
        pass

    def magnitude_squared(self) -> int:
        """*
           * @brief Returns vector magnitude squared: ||v||^2.
           * @return The magnitude squared.

        """
        pass

    @overload
    def x(self) -> int:
        """*
           * @brief Getter for the x value.
           * @return The current x value.

        """
        pass

    @overload
    def x(self, v: int) -> None:
        """*
           * @brief Setter for the x value.
           * @param v New value for \c x.

        """
        pass

    @overload
    def y(self) -> int:
        """*
           * @brief Getter for the y value.
           * @return The current y value.

        """
        pass

    @overload
    def y(self, v: int) -> None:
        """*
           * @brief Setter for the y value.
           * @param v New value for \c y.

        """
        pass

    def __lt__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __le__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __eq__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __ge__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __gt__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass

    def __eq__(self, other: Vector2d) -> bool:
        """*
           * @brief Equality operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return True if the vectors are equal, False otherwise.

        """
        pass

    def __getitem__(self, index: int) -> int:
        """*
           * @brief Index operator for vector elements.
           * @note Returns a mutable reference to the element.
           * @param index The index to return.
           * @return Mutable reference to the element at \p index.

        """
        pass

    @overload
    def __neg__(self) -> Vector2d:
        """*
           * @brief Negate the vector.
           * @return The new vector which is the negative.

        """
        pass

    @overload
    def __sub__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return a new vector which is the provided vector subtracted from
           *        this vector.
           * @param rhs The vector to subtract from this vector.
           * @return Resultant vector subtraction.

        """
        pass

    def __isub__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return the provided vector subtracted from this vector.
           * @param rhs The vector to subtract from this vector.
           * @return Resultant vector subtraction.

        """
        pass

    def __add__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return a new vector, which is the addition of this vector and the
           *        provided vector.
           * @param rhs The vector to add to this vector.
           * @return Resultant vector addition.

        """
        pass

    def __iadd__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return the vector added with the provided vector.
           * @param rhs The vector to add to this vector.
           * @return Resultant vector addition.

        """
        pass

    def __mul__(self, v: int) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, multiplied by the provided
           *        value.
           * @param v Value the vector should be multiplied by.
           * @return Resultant scaled vector.

        """
        pass

    def __imul__(self, v: int) -> Vector2d:
        """*
           * @brief Return the vector multiplied by the provided value.
           * @param v Value the vector should be scaled by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __truediv__(self, v: int) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, divided by the provided
           *        value.
           * @param v Value the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __itruediv__(self, v: int) -> Vector2d:
        """*
           * @brief Return the vector divided by the provided value.
           * @param v Value the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __truediv__(self, v: Vector2d) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, divided by the provided
           *        vector value. Scales x and y independently.
           * @param v Vector values the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __itruediv__(self, v: Vector2d) -> Vector2d:
        """*
           * @brief Return the vector divided by the provided vector values.
           * @param v Vector of values the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    def dot(self, other: Vector2d) -> T:
        """*
           * @brief Dot product of this vector with another vector.
           * @param other The second vector
           * @return The dot product (x1*x2 + y1*y2)

        """
        pass

    def normalized(self) -> Vector2d:
        """*
           * @brief Return normalized (unit length) version of the vector.
           * @return The normalized vector.

        """
        pass




class Vector2d_float:  # Python specialization for Vector2d<float>
    """*
     * @brief Container representing a 2 dimensional vector.
     *
     * Provides getters/setters, index operator, and vector / scalar math
     * utilities.
     *
     * \section vector_ex1 Example
     * \snippet math_example.cpp vector2 example

    """
    @overload
    def __init__(self, x: float = 0, y: float = 0) -> None:
        """*
           * @brief Constructor for the vector, defaults to 0,0.
           * @param x The starting X value.
           * @param y The starting Y value.

        """
        pass

    @overload
    def __init__(self, other: Vector2d) -> None:
        """*
           * @brief Vector copy constructor.
           * @param other Vector to copy.

        """
        pass


    def magnitude(self) -> float:
        """*
           * @brief Returns vector magnitude: ||v||.
           * @return The magnitude.

        """
        pass

    def magnitude_squared(self) -> float:
        """*
           * @brief Returns vector magnitude squared: ||v||^2.
           * @return The magnitude squared.

        """
        pass

    @overload
    def x(self) -> float:
        """*
           * @brief Getter for the x value.
           * @return The current x value.

        """
        pass

    @overload
    def x(self, v: float) -> None:
        """*
           * @brief Setter for the x value.
           * @param v New value for \c x.

        """
        pass

    @overload
    def y(self) -> float:
        """*
           * @brief Getter for the y value.
           * @return The current y value.

        """
        pass

    @overload
    def y(self, v: float) -> None:
        """*
           * @brief Setter for the y value.
           * @param v New value for \c y.

        """
        pass

    def __lt__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __le__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __eq__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __ge__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass
    def __gt__(self, other: Vector2d) -> bool:
        """*
           * @brief Spaceship operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return -1 if this vector is less than \p other, 0 if they are equal, 1 if
           *         this vector is greater than \p other.

        """
        pass

    def __eq__(self, other: Vector2d) -> bool:
        """*
           * @brief Equality operator for comparing two vectors.
           * @param other The vector to compare against.
           * @return True if the vectors are equal, False otherwise.

        """
        pass

    def __getitem__(self, index: int) -> float:
        """*
           * @brief Index operator for vector elements.
           * @note Returns a mutable reference to the element.
           * @param index The index to return.
           * @return Mutable reference to the element at \p index.

        """
        pass

    @overload
    def __neg__(self) -> Vector2d:
        """*
           * @brief Negate the vector.
           * @return The new vector which is the negative.

        """
        pass

    @overload
    def __sub__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return a new vector which is the provided vector subtracted from
           *        this vector.
           * @param rhs The vector to subtract from this vector.
           * @return Resultant vector subtraction.

        """
        pass

    def __isub__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return the provided vector subtracted from this vector.
           * @param rhs The vector to subtract from this vector.
           * @return Resultant vector subtraction.

        """
        pass

    def __add__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return a new vector, which is the addition of this vector and the
           *        provided vector.
           * @param rhs The vector to add to this vector.
           * @return Resultant vector addition.

        """
        pass

    def __iadd__(self, rhs: Vector2d) -> Vector2d:
        """*
           * @brief Return the vector added with the provided vector.
           * @param rhs The vector to add to this vector.
           * @return Resultant vector addition.

        """
        pass

    def __mul__(self, v: float) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, multiplied by the provided
           *        value.
           * @param v Value the vector should be multiplied by.
           * @return Resultant scaled vector.

        """
        pass

    def __imul__(self, v: float) -> Vector2d:
        """*
           * @brief Return the vector multiplied by the provided value.
           * @param v Value the vector should be scaled by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __truediv__(self, v: float) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, divided by the provided
           *        value.
           * @param v Value the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __itruediv__(self, v: float) -> Vector2d:
        """*
           * @brief Return the vector divided by the provided value.
           * @param v Value the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __truediv__(self, v: Vector2d) -> Vector2d:
        """*
           * @brief Return a scaled version of the vector, divided by the provided
           *        vector value. Scales x and y independently.
           * @param v Vector values the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    @overload
    def __itruediv__(self, v: Vector2d) -> Vector2d:
        """*
           * @brief Return the vector divided by the provided vector values.
           * @param v Vector of values the vector should be divided by.
           * @return Resultant scaled vector.

        """
        pass

    def dot(self, other: Vector2d) -> T:
        """*
           * @brief Dot product of this vector with another vector.
           * @param other The second vector
           * @return The dot product (x1*x2 + y1*y2)

        """
        pass

    def normalized(self) -> Vector2d:
        """*
           * @brief Return normalized (unit length) version of the vector.
           * @return The normalized vector.

        """
        pass


#      </template specializations for class Vector2d>
#  ------------------------------------------------------------------------




# namespace espp

####################    </generated_from:vector2d.hpp>    ####################


####################    <generated_from:socket.hpp>    ####################


# if we're on windows, we cannot include netinet/in.h and instead need to use
# winsock2.h




class Socket:
    """*
     *   @brief Class for a generic socket with some helper functions for
     *          configuring the socket.

    """
    class Type(enum.Enum):
        raw = enum.auto()    # (= SOCK_RAW)  #*< Only IP headers, no TCP or UDP headers as well.
        dgram = enum.auto()  # (= SOCK_DGRAM)  #*< UDP/IP socket - datagram.
        stream = enum.auto() # (= SOCK_STREAM)  #*< TCP/IP socket - stream.

    class Info:
        """*
           *  @brief Storage for socket information (address, port) with convenience
           *         functions to convert to/from POSIX structures.

        """
        address: str         #*< IP address of the endpoint as a string.
        port: int            #*< Port of the endpoint as an integer.

        def init_ipv4(self, addr: str, prt: int) -> None:
            """*
                 * @brief Initialize the struct as an ipv4 address/port combo.
                 * @param addr IPv4 address string
                 * @param prt port number

            """
            pass

        def ipv4_ptr(self) -> struct sockaddr_in:
            """*
                 * @brief Gives access to IPv4 sockaddr structure (sockaddr_in) for use
                 *        with low level socket calls like sendto / recvfrom.
                 * @return *sockaddr_in pointer to ipv4 data structure

            """
            pass

        def ipv6_ptr(self) -> struct sockaddr_in6:
            """*
                 * @brief Gives access to IPv6 sockaddr structure (sockaddr_in6) for use
                 *        with low level socket calls like sendto / recvfrom.
                 * @return *sockaddr_in6 pointer to ipv6 data structure

            """
            pass

        def update(self) -> None:
            """*
                 * @brief Will update address and port based on the curent data in raw.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_storage) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_in) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_in6) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass
        def __init__(self, address: str = "", port: int = int()) -> None:
            """Auto-generated default constructor with named params"""
            pass






    @overload
    def is_valid(self) -> bool:
        """*
           * @brief Is the socket valid.
           * @return True if the socket file descriptor is >= 0.

        """
        pass

    @staticmethod
    @overload
    def is_valid(socket_fd: int) -> bool:
        """*
           * @brief Is the socket valid.
           * @param socket_fd Socket file descriptor.
           * @return True if the socket file descriptor is >= 0.

        """
        pass

    def get_ipv4_info(self) -> Optional[Socket.Info]:
        """*
           * @brief Get the Socket::Info for the socket.
           * @details This will call getsockname() on the socket to get the
           *          sockaddr_storage structure, and then fill out the Socket::Info
           *          structure.
           * @return Socket::Info for the socket.

        """
        pass

    def set_receive_timeout(self, timeout: std.chrono.duration<float>) -> bool:
        """*
           * @brief Set the receive timeout on the provided socket.
           * @param timeout requested timeout, must be > 0.
           * @return True if SO_RECVTIMEO was successfully set.

        """
        pass

    def enable_reuse(self) -> bool:
        """*
           * @brief Allow others to use this address/port combination after we're done
           *        with it.
           * @return True if SO_REUSEADDR and SO_REUSEPORT were successfully set.

        """
        pass

    def make_multicast(self, time_to_live: int = 1, loopback_enabled: int = True) -> bool:
        """*
           * @brief Configure the socket to be multicast (if time_to_live > 0).
           *        Sets the IP_MULTICAST_TTL (number of multicast hops allowed) and
           *        optionally configures whether this node should receive its own
           *        multicast packets (IP_MULTICAST_LOOP).
           * @param time_to_live number of multicast hops allowed (TTL).
           * @param loopback_enabled Whether to receive our own multicast packets.
           * @return True if IP_MULTICAST_TTL and IP_MULTICAST_LOOP were set.

        """
        pass

    def add_multicast_group(self, multicast_group: str) -> bool:
        """*
           * @brief If this is a server socket, add it to the provided the multicast
           *        group.
           *
           *         @note Multicast groups must be Class D addresses (224.0.0.0 to
           *                239.255.255.255)
           *
           *        See https://en.wikipedia.org/wiki/Multicast_address for more
           *        information.
           * @param multicast_group multicast group to join.
           * @return True if IP_ADD_MEMBERSHIP was successfully set.

        """
        pass

    def select(self, timeout: std.chrono.microseconds) -> int:
        """*
           * @brief Select on the socket for read events.
           * @param timeout how long to wait for an event.
           * @return number of events that occurred.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

# namespace espp

####################    </generated_from:socket.hpp>    ####################


####################    <generated_from:tcp_socket.hpp>    ####################


# if we're on windows, we cannot include netinet/in.h and instead need to use
# winsock2.h


class TcpSocket:
    """*
     *   @brief Class for managing sending and receiving data using TCP/IP. Can be
     *          used to create client or server sockets.
     *
     * \section tcp_ex1 TCP Client Example
     * \snippet socket_example.cpp TCP Client example
     * \section tcp_ex2 TCP Server Example
     * \snippet socket_example.cpp TCP Server example
     *
     * \section tcp_ex3 TCP Client Response Example
     * \snippet socket_example.cpp TCP Client Response example
     * \section tcp_ex4 TCP Server Response Example
     * \snippet socket_example.cpp TCP Server Response example
     *

    """
    class Config:
        """*
           * @brief Config struct for the TCP socket.

        """
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.warn)  #*< Verbosity level for the TCP socket logger.
        def __init__(
            self,
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class ConnectConfig:
        """*
           * @brief Config struct for connecting to a remote TCP server.

        """
        ip_address: str                                                                       #*< Address to send data to.
        port: int                                                                             #*< Port number to send data to.
        def __init__(self, ip_address: str = "", port: int = int()) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class TransmitConfig:
        """*
           * @brief Config struct for sending data to a remote TCP socket.
           * @note This is only used when waiting for a response from the remote.

        """
        wait_for_response: bool = False                                                       #*< Whether to wait for a response from the remote or not.
        response_size: int = 0                                                                #*< If waiting for a response, this is the maximum size response we will receive.
        on_response_callback: espp.Socket.response_callback_fn = None                         #*< If waiting for a
                           response, this is an optional handler which is provided the response data.
        response_timeout: std.chrono.duration<float> = std.chrono.duration<float>(
                0.5)                                                                          #*< If waiting for a response, this is the maximum timeout to wait.

        @staticmethod
        def default() -> TcpSocket.TransmitConfig:
            pass
        def __init__(
            self,
            wait_for_response: bool = False,
            response_size: int = 0,
            on_response_callback: Socket.response_callback_fn = None,
            response_timeout: std.chrono.duration<float> = std.chrono.duration<float>(
                    0.5)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    def reinit(self) -> None:
        """*
           * @brief Reinitialize the socket, cleaning it up if first it is already
           *        initalized.

        """
        pass

    def close(self) -> None:
        """*
           * @brief Close the socket.

        """
        pass

    def is_connected(self) -> bool:
        """*
           * @brief Check if the socket is connected to a remote endpoint.
           * @return True if the socket is connected to a remote endpoint.

        """
        pass

    def connect(self, connect_config: TcpSocket.ConnectConfig) -> bool:
        """*
           * @brief Open a connection to the remote TCP server.
           * @param connect_config ConnectConfig struct describing the server endpoint.
           * @return True if the client successfully connected to the server.

        """
        pass

    def get_remote_info(self) -> Socket.Info:
        """*
           * @brief Get the remote endpoint info.
           * @return The remote endpoint info.

        """
        pass

    @overload
    def transmit(
        self,
        data: List[int],
        transmit_config: TcpSocket.TransmitConfig = TcpSocket.TransmitConfig.Default()
        ) -> bool:
        """*
           * @brief Send data to the endpoint already connected to by TcpSocket::connect.
           *        Can be configured to block waiting for a response from the remote.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data vector of bytes to send to the remote endpoint.
           * @param transmit_config TransmitConfig struct indicating whether to wait for a
           *        response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def transmit(
        self,
        data: List[char],
        transmit_config: TcpSocket.TransmitConfig = TcpSocket.TransmitConfig.Default()
        ) -> bool:
        """*
           * @brief Send data to the endpoint already connected to by TcpSocket::connect.
           *        Can be configured to block waiting for a response from the remote.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data vector of bytes to send to the remote endpoint.
           * @param transmit_config TransmitConfig struct indicating whether to wait for a
           *        response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def transmit(
        self,
        data: std.string_view,
        transmit_config: TcpSocket.TransmitConfig = TcpSocket.TransmitConfig.Default()
        ) -> bool:
        """*
           * @brief Send data to the endpoint already connected to by TcpSocket::connect.
           *        Can be configured to block waiting for a response from the remote.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data string view of bytes to send to the remote endpoint.
           * @param transmit_config TransmitConfig struct indicating whether to wait for a
           *        response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def receive(self, data: List[int], max_num_bytes: int) -> bool:
        """*
           * @brief Call read on the socket, assuming it has already been configured
           *        appropriately.
           *
           * @param data Vector of bytes of received data.
           * @param max_num_bytes Maximum number of bytes to receive.
           * @return True if successfully received, False otherwise.

        """
        pass

    @overload
    def receive(self, data: int, max_num_bytes: int) -> int:
        """*
           * @brief Call read on the socket, assuming it has already been configured
           *        appropriately.
           * @note This function will block until max_num_bytes are received or the
           *       receive timeout is reached.
           * @note The data pointed to by data must be at least max_num_bytes in size.
           * @param data Pointer to buffer to receive data.
           * @param max_num_bytes Maximum number of bytes to receive.
           * @return Number of bytes received.

        """
        pass

    def bind(self, port: int) -> bool:
        """*
           * @brief Bind the socket as a server on \p port.
           * @param port The port to which to bind the socket.
           * @return True if the socket was bound.

        """
        pass

    def listen(self, max_pending_connections: int) -> bool:
        """*
           * @brief Listen for incoming client connections.
           * @note Must be called after bind and before accept.
           * @see bind
           * @see accept
           * @param max_pending_connections Max number of allowed pending connections.
           * @return True if socket was able to start listening.

        """
        pass

    def accept(self) -> TcpSocket:
        """*
           * @brief Accept an incoming connection.
           * @note Blocks until a connection is accepted.
           * @note Must be called after listen.
           * @note This function will block until a connection is accepted.
           * @return A unique pointer to a TcpClientSession if a connection was
           *         accepted, None otherwise.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:tcp_socket.hpp>    ####################


####################    <generated_from:udp_socket.hpp>    ####################



# TODO: should this class _contain_ a socket or just create sockets within each
#       call?

class UdpSocket:
    """*
     *   @brief Class for managing sending and receiving data using UDP/IP. Can be
     *          used to create client or server sockets.
     *
     *   See
     *   https://github.com/espressif/esp-idf/tree/master/examples/protocols/sockets/udp_multicast
     *   for more information on udp multicast sockets.
     *
     * \section udp_ex1 UDP Client Example
     * \snippet socket_example.cpp UDP Client example
     * \section udp_ex2 UDP Server Example
     * \snippet socket_example.cpp UDP Server example
     *
     * \section udp_ex3 UDP Client Response Example
     * \snippet socket_example.cpp UDP Client Response example
     * \section udp_ex4 UDP Server Response Example
     * \snippet socket_example.cpp UDP Server Response example
     *
     * \section udp_ex5 UDP Multicast Client Example
     * \snippet socket_example.cpp UDP Multicast Client example
     * \section udp_ex6 UDP Multicast Server Example
     * \snippet socket_example.cpp UDP Multicast Server example
     *

    """
    class ReceiveConfig:
        port: int                                                                                        #*< Port number to bind to / receive from.
        buffer_size: int                                                                                 #*< Max size of data we can receive at one time.
        is_multicast_endpoint: bool = bool(False)                                                        #*< Whether this should be a multicast endpoint.
        multicast_group: str = str("")                                                                   #*< If this is a multicast endpoint, this is the group it belongs to.
        on_receive_callback: espp.Socket.receive_callback_fn = espp.Socket.receive_callback_fn(None)     #*< Function containing business logic to handle data received.
        def __init__(
            self,
            port: int = int(),
            buffer_size: int = int(),
            is_multicast_endpoint: bool = bool(False),
            multicast_group: str = str(""),
            on_receive_callback: Socket.receive_callback_fn = Socket.receive_callback_fn(None)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class SendConfig:
        ip_address: str                                                                                  #*< Address to send data to.
        port: int                                                                                        #*< Port number to send data to.
        is_multicast_endpoint: bool = bool(False)                                                        #*< Whether this should be a multicast endpoint.
        wait_for_response: bool = bool(False)                                                            #*< Whether to wait for a response from the remote or not.
        response_size: int = int(0)                                                                      #*< If waiting for a response, this is the maximum size response we will receive.
        on_response_callback: espp.Socket.response_callback_fn = espp.Socket.response_callback_fn(None)  #*< If waiting for a response, this is an optional handler which is provided the
                             response data.
        response_timeout: std.chrono.duration<float> = std.chrono.duration<float>(
                0.5)                                                                                     #*< If waiting for a response, this is the maximum timeout to wait.
        def __init__(
            self,
            ip_address: str = "",
            port: int = int(),
            is_multicast_endpoint: bool = bool(False),
            wait_for_response: bool = bool(False),
            response_size: int = int(0),
            on_response_callback: Socket.response_callback_fn = Socket.response_callback_fn(None),
            response_timeout: std.chrono.duration<float> = std.chrono.duration<float>(
                    0.5)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class Config:
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.warn)             #*< Verbosity level for the UDP socket logger.
        def __init__(
            self,
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    @overload
    def send(self, data: List[int], send_config: UdpSocket.SendConfig) -> bool:
        """*
           * @brief Send data to the endpoint specified by the send_config.
           *        Can be configured to multicast (within send_config) and can be
           *        configured to block waiting for a response from the remote.
           *
           *        @note in the case of multicast, it will block only until the first
           *              response.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data vector of bytes to send to the remote endpoint.
           * @param send_config SendConfig struct indicating where to send and whether
           *        to wait for a response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def send(self, data: std.string_view, send_config: UdpSocket.SendConfig) -> bool:
        """*
           * @brief Send data to the endpoint specified by the send_config.
           *        Can be configured to multicast (within send_config) and can be
           *        configured to block waiting for a response from the remote.
           *
           *        @note in the case of multicast, it will block only until the first
           *              response.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data String view of bytes to send to the remote endpoint.
           * @param send_config SendConfig struct indicating where to send and whether
           *        to wait for a response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    def receive(
        self,
        max_num_bytes: int,
        data: List[int],
        remote_info: Socket.Info
        ) -> bool:
        """*
           * @brief Call recvfrom on the socket, assuming it has already been
           *        configured appropriately.
           *
           * @param max_num_bytes Maximum number of bytes to receive.
           * @param data Vector of bytes of received data.
           * @param remote_info Socket::Info containing the sender's information. This
           *        will be populated with the information about the sender.
           * @return True if successfully received, False otherwise.

        """
        pass

    def start_receiving(
        self,
        task_config: Task.Config,
        receive_config: UdpSocket.ReceiveConfig
        ) -> bool:
        """*
           * @brief Configure a server socket and start a thread to continuously
           *        receive and handle data coming in on that socket.
           *
           * @param task_config Task::Config struct for configuring the receive task.
           * @param receive_config ReceiveConfig struct with socket and callback info.
           * @return True if the socket was created and task was started, False otherwise.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:udp_socket.hpp>    ####################


####################    <generated_from:task.hpp>    ####################





class Task:
    """*
     * @brief Task provides an abstraction over std::thread which optionally
     * includes memory / priority configuration on ESP systems. It allows users to
     * easily stop the task, and will automatically stop itself if destroyed.
     *
     * There is also a utility function which can be used to get the info for the
     * task of the current context, or for a provided Task object.
     *
     * There is also a helper function to run a lambda on a specific core, which can
     * be used to run a specific function on a specific core, as you might want to
     * do when registering an interrupt driver on a specific core.
     *
     * \section task_ex1 Basic Task Example
     * \snippet task_example.cpp Task example
     * \section task_ex2 Many Task Example
     * \snippet task_example.cpp ManyTask example
     * \section task_ex3 Long Running Task Example
     * \snippet task_example.cpp LongRunningTask example
     * \section task_ex4 Task Info Example
     * \snippet task_example.cpp Task Info example
     * \section task_ex5 Task Request Stop Example
     * \snippet task_example.cpp Task Request Stop example
     *
     * \section run_on_core_ex1 Run on Core Example
     * \snippet task_example.cpp run on core example

    """


    class BaseConfig:
        """*
           * @brief Base configuration struct for the Task.
           * @note This is designed to be used as a configuration struct in other classes
           *       that may have a Task as a member.

        """
        name: str                                                                             #*< Name of the task
        stack_size_bytes: int = int(4096)                                                     #*< Stack Size (B) allocated to the task.
        priority: int = int(0)                                                                #*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(-1)                                                                #*< Core ID of the task, -1 means it is not pinned to any core.
        def __init__(
            self,
            name: str = "",
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class Config:
        """*
           * @brief Configuration struct for the Task.
           * @note This is the recommended way to configure the Task, and allows you to
           *       use the condition variable and mutex from the task to wait_for and
           *       wait_until.
           * @note This is an older configuration struct, and is kept for backwards
           *       compatibility. It is recommended to use the AdvancedConfig struct
           *       instead.

        """
        name: str                                                                             #*< Name of the task
        callback: espp.Task.callback_fn                                                       #*< Callback function
        stack_size_bytes: int = int(4096)                                                     #*< Stack Size (B) allocated to the task.
        priority: int = int(0)                                                                #*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(-1)                                                                #*< Core ID of the task, -1 means it is not pinned to any core.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.warn)  #*< Log verbosity for the task.
        def __init__(
            self,
            name: str = "",
            callback: Task.callback_fn = Task.callback_fn(),
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class SimpleConfig:
        """*
           * @brief Simple configuration struct for the Task.
           * @note This is useful for when you don't need to use the condition variable
           *       or mutex in the callback.

        """
        callback: espp.Task.simple_callback_fn                                                #*< Callback function
        task_config: espp.Task.BaseConfig                                                     #*< Base configuration for the task.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.warn)  #*< Log verbosity for the task.
        def __init__(
            self,
            callback: Task.simple_callback_fn = Task.simple_callback_fn(),
            task_config: Task.BaseConfig = Task.BaseConfig(),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class AdvancedConfig:
        """*
           * @brief Advanced configuration struct for the Task.
           * @note This is the recommended way to configure the Task, and allows you to
           *       use the condition variable and mutex from the task to wait_for and
           *       wait_until.

        """
        callback: espp.Task.callback_fn                                                       #*< Callback function
        task_config: espp.Task.BaseConfig                                                     #*< Base configuration for the task.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity(espp.Logger.Verbosity.warn)  #*< Log verbosity for the task.
        def __init__(
            self,
            callback: Task.callback_fn = Task.callback_fn(),
            task_config: Task.BaseConfig = Task.BaseConfig(),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass




    @staticmethod
    @overload
    def make_unique(config: Task.Config) -> Task:
        """*
           * @brief Get a unique pointer to a new task created with \p config.
           *        Useful to not have to use templated std::make_unique (less typing).
           * @param config Config struct to initialize the Task with.
           * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass

    @staticmethod
    @overload
    def make_unique(config: Task.SimpleConfig) -> Task:
        """*
           * @brief Get a unique pointer to a new task created with \p config.
           *        Useful to not have to use templated std::make_unique (less typing).
           * @param config SimpleConfig struct to initialize the Task with.
           * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass

    @staticmethod
    @overload
    def make_unique(config: Task.AdvancedConfig) -> Task:
        """*
           * @brief Get a unique pointer to a new task created with \p config.
           *        Useful to not have to use templated std::make_unique (less typing).
           * @param config AdvancedConfig struct to initialize the Task with.
           * @return std::unique_ptr<Task> pointer to the newly created task.

        """
        pass


    def start(self) -> bool:
        """*
           * @brief Start executing the task.
           *
           * @return True if the task started, False if it was already started.

        """
        pass

    def stop(self) -> bool:
        """*
           * @brief Stop the task execution, blocking until it stops.
           *
           * @return True if the task stopped, False if it was not started / already
           * stopped.

        """
        pass

    def is_started(self) -> bool:
        """*
           * @brief Has the task been started or not?
           *
           * @return True if the task is started / running, False otherwise.

        """
        pass

    def is_running(self) -> bool:
        """*
           * @brief Is the task running?
           *
           * @return True if the task is running, False otherwise.

        """
        pass


    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

# namespace espp

####################    </generated_from:task.hpp>    ####################


####################    <generated_from:timer.hpp>    ####################



class Timer:
    """/ @brief A timer that can be used to schedule tasks to run at a later time.
    / @details A timer can be used to schedule a task to run at a later time.
    /          The timer will run in the background and will call the task when
    /          the time is up. The timer can be canceled at any time. A timer
    /          can be configured to run once or to repeat.
    /
    /          The timer uses a task to run in the background. The task will
    /          sleep until the timer is ready to run. When the timer is ready to
    /          run, the task will call the callback function. The callback
    /          function can return True to cancel the timer or False to keep the
    /          timer running. If the timer is configured to repeat, then the
    /          callback function will be called again after the period has
    /          elapsed. If the timer is configured to run once, then the
    /          callback function will only be called once.
    /
    /          The timer can be configured to start automatically when it is
    /          constructed. If the timer is not configured to start
    /          automatically, then the timer can be started by calling start().
    /          The timer can be canceled at any time by calling cancel().
    /
    / @note The timer uses a task to run in the background, so the timer
    /       callback function will be called in the context of the task. The
    /       timer callback function should not block for a long time because it
    /       will block the task. If the timer callback function blocks for a
    /       long time, then the timer will not be able to keep up with the
    /       period.
    /
    / \section timer_ex1 Timer Example 1
    / \snippet timer_example.cpp timer example
    / \section timer_ex2 Timer Delay Example
    / \snippet timer_example.cpp timer delay example
    / \section timer_ex3 Oneshot Timer Example
    / \snippet timer_example.cpp timer oneshot example
    / \section timer_ex4 Timer Cancel Itself Example
    / \snippet timer_example.cpp timer cancel itself example
    / \section timer_ex5 Oneshot Timer Cancel Itself Then Start again with Delay Example
    / \snippet timer_example.cpp timer oneshot restart example
    / \section timer_ex6 Timer Update Period Example
    / \snippet timer_example.cpp timer update period example
    """

    class Config:
        """/ @brief The configuration for the timer."""
        name: std.string_view                                          #/< The name of the timer.
        period: std.chrono.duration<float>                             #/< The period of the timer. If 0, the timer callback will only be called once.
        delay: std.chrono.duration<float> = std.chrono.duration<float>(
                0)                                                     #/< The delay before the first execution of the timer callback after start() is called.
        callback: espp.Timer.callback_fn                               #/< The callback function to call when the timer expires.
        auto_start: bool = bool(True)                                  #/< If True, the timer will start automatically when constructed.
        stack_size_bytes: int = int(4096)                              #/< The stack size of the task that runs the timer.
        priority: int = int(0)                                         #/< Priority of the timer, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(-1)                                         #/< Core ID of the timer, -1 means it is not pinned to any core.
        log_level: espp.Logger.Verbosity = espp.Logger.Verbosity.warn  #/< The log level for the timer.
        def __init__(
            self,
            name: std.string_view = std.string_view(),
            period: std.chrono.duration<float> = std.chrono.duration<float>(),
            delay: std.chrono.duration<float> = std.chrono.duration<float>(
                    0),
            callback: Timer.callback_fn = Timer.callback_fn(),
            auto_start: bool = bool(True),
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1),
            log_level: Logger.Verbosity = Logger.Verbosity.warn
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    @overload
    def start(self) -> None:
        """/ @brief Start the timer.
        / @details Starts the timer. Does nothing if the timer is already running.
        """
        pass

    @overload
    def start(self, delay: std.chrono.duration<float>) -> None:
        """/ @brief Start the timer with a delay.
        / @details Starts the timer with a delay. If the timer is already running,
        /          this will cancel the timer and start it again with the new
        /          delay. If the timer is not running, this will start the timer
        /          with the delay. Overwrites any previous delay that might have
        /          been set.
        / @param delay The delay before the first execution of the timer callback.
        """
        pass

    def stop(self) -> None:
        """/ @brief Stop the timer, same as cancel().
        / @details Stops the timer, same as cancel().
        """
        pass

    def cancel(self) -> None:
        """/ @brief Cancel the timer.
        / @details Cancels the timer.
        """
        pass

    def set_period(self, period: std.chrono.duration<float>) -> None:
        """/ @brief Set the period of the timer.
        / @details Sets the period of the timer.
        / @param period The period of the timer.
        / @note If the period is 0, the timer will run once.
        / @note If the period is negative, the period will not be set / updated.
        / @note If the timer is running, the period will be updated after the
        /       current period has elapsed.
        """
        pass

    def is_running(self) -> bool:
        """/ @brief Check if the timer is running.
        / @details Checks if the timer is running.
        / @return True if the timer is running, False otherwise.
        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:timer.hpp>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
