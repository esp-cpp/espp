# If you want to use mypy or pyright, you may have to ignore some errors, like below:

# mypy: disable-error-code="type-arg"

from typing import overload, List

NumberType = (int, float, np.number)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:base_component.hpp>    ####################



class BaseComponent:
    """/ Base class for all components
    / Provides a logger and some basic logging configuration
    """
    def get_name(self) -> str:
        """/ Get the name of the component
        / \return A const reference to the name of the component
        / \note This is the tag of the logger
        """
        pass

    def set_log_tag(self, tag: std.string_view) -> None:
        """/ Set the tag for the logger
        / \param tag The tag to use for the logger
        """
        pass

    def get_log_level(self) -> Logger.Verbosity:
        """/ Get the log level for the logger
        / \return The verbosity level of the logger
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def set_log_level(self, level: Logger.Verbosity) -> None:
        """/ Set the log level for the logger
        / \param level The verbosity level to use for the logger
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def set_log_verbosity(self, level: Logger.Verbosity) -> None:
        """/ Set the log verbosity for the logger
        / \param level The verbosity level to use for the logger
        / \note This is a convenience method that calls set_log_level
        / \sa set_log_level
        / \sa Logger::Verbosity
        / \sa Logger::set_verbosity
        """
        pass

    def get_log_verbosity(self) -> Logger.Verbosity:
        """/ Get the log verbosity for the logger
        / \return The verbosity level of the logger
        / \note This is a convenience method that calls get_log_level
        / \sa get_log_level
        / \sa Logger::Verbosity
        / \sa Logger::get_verbosity
        """
        pass

    def set_log_rate_limit(self, rate_limit: std.chrono.duration[float]) -> None:
        """/ Set the rate limit for the logger
        / \param rate_limit The rate limit to use for the logger
        / \note Only calls to the logger that have _rate_limit suffix will be rate limited
        / \sa Logger::set_rate_limit
        """
        pass


####################    </generated_from:base_component.hpp>    ####################


####################    <generated_from:cobs.hpp>    ####################



class Cobs:
    """*
     * @brief COBS (Consistent Overhead Byte Stuffing) encoder/decoder
     *
     * Provides single-packet encoding and decoding using the COBS algorithm
     * with 0 as the delimiter.
     * COBS encoding can add at most ⌈n/254⌉ + 1 bytes overhead. Plus 1 byte for the delimiter
     * COBS changes the size of the packet by at least 1 byte, so it's not possible to encode in
     * place. MAX_BLOCK_SIZE = 254 is the maximum number of non-zero bytes in an encoded block.
     *
     * @see https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing

    """
    @staticmethod
    def max_encoded_size(payload_len: int) -> int:
        """*
           * @brief Calculate maximum encoded size for a given payload length
           *
           * @param payload_len Length of input data
           * @return Maximum number of bytes needed for encoding (including delimiter)

        """
        pass

    @staticmethod
    @overload
    def encode_packet(data: std.span[ int]) -> List[int]:
        """*
           * @brief Encode a single packet
           *
           * @param data Input data to encode
           * @return Encoded data with COBS encoding and delimiter

        """
        pass

    @staticmethod
    @overload
    def encode_packet(data: std.span[ int], output: std.span[int]) -> int:
        """*
           * @brief Encode a single packet to existing buffer
           *
           * @param data Input data to encode
           * @param output Output buffer span (must be large enough)
           * @return Number of bytes written to output

        """
        pass

    @staticmethod
    def max_decoded_size(encoded_len: int) -> int:
        pass

    @staticmethod
    @overload
    def decode_packet(encoded_data: std.span[ int]) -> List[int]:
        """*
           * @brief Decode a single packet from COBS-encoded data
           *
           * @param encoded_data COBS-encoded data
           * @return Decoded packet data, or empty if invalid

        """
        pass

    @staticmethod
    @overload
    def decode_packet(encoded_data: std.span[ int], output: std.span[int]) -> int:
        """*
           * @brief Decode a single packet to existing buffer
           *
           * @param encoded_data COBS-encoded data
           * @param output Output buffer span (must be large enough)
           * @return Number of bytes written to output, or 0 if decoding failed

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass


####################    </generated_from:cobs.hpp>    ####################


####################    <generated_from:cobs_stream.hpp>    ####################



class CobsStreamDecoder:
    """*
     * @brief Streaming decoder for multiple COBS-encoded packets
     *
     * Useful for processing incoming data streams where packets may arrive
     * in fragments or multiple packets may arrive together.

    """
    def __init__(self) -> None:
        pass

    @overload
    def add_data(self, data: std.span[ int]) -> None:
        """*
           * @brief Add encoded data to the decoder buffer
           *
           * @param data New encoded data span

        """
        pass

    @overload
    def add_data(self, data: List[int]) -> None:
        """*
           * @brief Add encoded data to the decoder buffer (move semantics)
           *
           * @param data New encoded data vector (will be moved)

        """
        pass

    def extract_packet(self) -> Optional[List[int]]:
        """*
           * @brief Try to extract the next complete packet. Removes the extracted data from the buffer.
           *
           * @return Decoded packet data, or empty if no complete packet found

        """
        pass

    def remaining_data(self) -> List[int]:
        """*
           * @brief Access remaining unprocessed data for debug purposes
           *
           * @return Const reference to buffered data that hasn't been processed yet

        """
        pass

    def buffer_size(self) -> int:
        """*
           * @brief Get the size of buffered data
           *
           * @return Number of bytes currently buffered

        """
        pass

    def clear(self) -> None:
        """*
           * @brief Clear all buffered data

        """
        pass


class CobsStreamEncoder:
    """*
     * @brief Streaming encoder for multiple packets
     *
     * Useful for batching multiple packets together for transmission
     * or for building up data to send in chunks.

    """
    def __init__(self) -> None:
        pass

    @overload
    def add_packet(self, data: std.span[ int]) -> None:
        """*
           * @brief Add a packet to be encoded
           *
           * @param data Packet data span

        """
        pass

    @overload
    def add_packet(self, data: List[int]) -> None:
        """*
           * @brief Add a packet to be encoded (move semantics)
           *
           * @param data Packet data vector (will be moved)

        """
        pass

    def get_encoded_data(self) -> List[int]:
        """*
           * @brief Get all encoded data as a single buffer for debug purposes
           *
           * @return All encoded packets concatenated, const reference

        """
        pass

    @overload
    def extract_data(self, max_size: int) -> List[int]:
        """*
           * @brief Extract encoded data up to a maximum size
           *
           * @param max_size Maximum number of bytes to extract
           * @return Encoded data up to max_size bytes

        """
        pass

    @overload
    def extract_data(self, output: int, max_size: int) -> int:
        """*
           * @brief Extract encoded data directly to a buffer
           *
           * @param output Output buffer to write data to
           * @param max_size Maximum number of bytes to extract
           * @return Number of bytes actually written to output

        """
        pass

    def buffer_size(self) -> int:
        """*
           * @brief Get the current buffer size
           *
           * @return Number of bytes currently buffered

        """
        pass

    def clear(self) -> None:
        """*
           * @brief Clear all buffered data

        """
        pass



####################    </generated_from:cobs_stream.hpp>    ####################


####################    <generated_from:color.hpp>    ####################




class Rgb:
    """*
     * @brief Class representing a color using RGB color space.

    """
    r: float = float(0)  #/< Red value ∈ [0, 1]
    g: float = float(0)  #/< Green value ∈ [0, 1]
    b: float = float(0)  #/< Blue value ∈ [0, 1]

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, r: float, g: float, b: float) -> None:
        """*
           * @brief Construct an Rgb object from the provided rgb values.
           * @note If provided values outside the range [0,1], it will rescale them to
           *       be within the range [0,1] by dividing by 255.
           * @param r Floating point value for the red channel, should be in range [0,
           *        1]
           * @param g Floating point value for the green channel, should be in range
           *        [0, 1]
           * @param b Floating point value for the blue channel, should be in range
           *        [0, 1]

        """
        pass

    @overload
    def __init__(self, rgb: Rgb) -> None:
        """*
           * @brief Copy-construct an Rgb object from the provided object.
           * @note If provided values outside the range [0,1], it will rescale them to
           *       be within the range [0,1] by dividing by 255.
           * @param rgb Rgb struct containing the values to copy.

        """
        pass

    @overload
    def __init__(self, hsv: Hsv) -> None:
        """*
           * @brief Construct an Rgb object from the provided Hsv object.
           * @note This calls hsv.rgb() on the provided object, which means that invalid
           *       HSV data (not in the ranges [0,360], [0,1], and [0,1]) could lead to
           *       bad RGB data. The Rgb constructor will automatically convert the
           *       values to be in the proper range, but the perceived color will be
           *       changed.
           * @param hsv Hsv object to copy.

        """
        pass

    @overload
    def __init__(self, hex: int) -> None:
        """*
           * @brief Construct an Rgb object from the provided hex value.
           * @param hex Hex value to convert to RGB. The hex value should be in the
           *        format 0xRRGGBB.

        """
        pass



    def __add__(self, rhs: Rgb) -> Rgb:
        """*
           * @brief Perform additive color blending (averaging)
           * @param rhs Other color to add to this color to create the resultant color
           * @return Resultant color from blending this color with the \p rhs color.

        """
        pass

    def __iadd__(self, rhs: Rgb) -> Rgb:
        """*
           * @brief Perform additive color blending (averaging)
           * @param rhs Other color to add to this color

        """
        pass

    def __eq__(self, rhs: Rgb) -> bool:
        pass

    def __ne__(self, rhs: Rgb) -> bool:
        pass

    def hsv(self) -> Hsv:
        """*
           * @brief Get a HSV representation of this RGB color.
           * @return An HSV object containing the HSV representation.

        """
        pass

    def hex(self) -> int:
        """*
           * @brief Get the hex representation of this RGB color.
           * @return The hex representation of this RGB color.

        """
        pass

class Hsv:
    """*
     * @brief Class representing a color using HSV color space.

    """
    h: float = float(0)  #/< Hue ∈ [0, 360]
    s: float = float(0)  #/< Saturation ∈ [0, 1]
    v: float = float(0)  #/< Value ∈ [0, 1]

    @overload
    def __init__(self) -> None:
        pass

    @overload
    def __init__(self, h: float, s: float, v: float) -> None:
        """*
           * @brief Construct a Hsv object from the provided values.
           * @param h Hue - will be clamped to be in range [0, 360]
           * @param s Saturation - will be clamped to be in range [0, 1]
           * @param v Value - will be clamped to be in range [0, 1]

        """
        pass

    @overload
    def __init__(self, hsv: Hsv) -> None:
        """*
           * @brief Copy-construct the Hsv object
           * @param hsv Object to copy from.

        """
        pass

    @overload
    def __init__(self, rgb: Rgb) -> None:
        """*
           * @brief Construct Hsv object from Rgb object. Calls rgb.hsv() to perform
           *        the conversion.
           * @param rgb The Rgb object to convert and copy.

        """
        pass


    def __eq__(self, rhs: Hsv) -> bool:
        pass

    def __ne__(self, rhs: Hsv) -> bool:
        pass


    def rgb(self) -> Rgb:
        """*
           * @brief Get a RGB representation of this HSV color.
           * @return An RGB object containing the RGB representation.

        """
        pass

@overload
def color_code(rgb: Rgb) -> Any:
    """
    (C++ auto return type)
    """
    pass
@overload
def color_code(hsv: Hsv) -> Any:
    """
    (C++ auto return type)
    """
    pass



####################    </generated_from:color.hpp>    ####################


####################    <generated_from:event_manager.hpp>    ####################



class EventManager:
    """*
     * @brief Singleton class for managing events. Provides mechanisms for
     *        anonymous publish / subscribe interactions - enabling one to one,
     *        one to many, many to one, and many to many data distribution with
     *        loose coupling and low overhead. Each topic runs a thread for that
     *        topic's subscribers, executing all the callbacks in sequence and
     *        then going to sleep again until new data is published.
     *
     * @note In c++ objects, it's recommended to call the
     *       add_publisher/add_subscriber functions in the class constructor and
     *       then to call the remove_publisher/remove_subscriber functions in the
     *       class destructor.
     *
     * @note It is recommended (unless you are only interested in events and not
     *       data or are only needing to transmit actual strings) to use a
     *       serialization library (such as espp::serialization - which wraps
     *       alpaca) to serialize your data structures to string when publishing
     *       and then deserialize your data from string in the subscriber
     *       callbacks.
     *
     * \section event_manager_ex1 Event Manager Example
     * \snippet event_manager_example.cpp event manager example

    """

    @staticmethod
    def get() -> EventManager:
        """*
           * @brief Get the singleton instance of the EventManager.
           * @return A reference to the EventManager singleton.

        """
        pass


    def add_publisher(self, topic: str, component: str) -> bool:
        """*
           * @brief Register a publisher for \p component on \p topic.
           * @param topic Topic name for the data being published.
           * @param component Name of the component publishing data.
           * @return True if the publisher was added, False if it was already
           *         registered for that component.

        """
        pass

    @overload
    def add_subscriber(
        self,
        topic: str,
        component: str,
        callback: EventManager.event_callback_fn,
        stack_size_bytes: int = 8192
        ) -> bool:
        """*
           * @brief Register a subscriber for \p component on \p topic.
           * @param topic Topic name for the data being subscribed to.
           * @param component Name of the component publishing data.
           * @param callback The event_callback_fn to be called when receicing data on
           *        \p topic.
           * @param stack_size_bytes The stack size in bytes to use for the subscriber
           * @note The stack size is only used if a subscriber is not already registered
           *       for that topic. If a subscriber is already registered for that topic,
           *       the stack size is ignored.
           * @return True if the subscriber was added, False if it was already
           *         registered for that component.

        """
        pass

    @overload
    def add_subscriber(
        self,
        topic: str,
        component: str,
        callback: EventManager.event_callback_fn,
        task_config: Task.BaseConfig
        ) -> bool:
        """*
           * @brief Register a subscriber for \p component on \p topic.
           * @param topic Topic name for the data being subscribed to.
           * @param component Name of the component publishing data.
           * @param callback The event_callback_fn to be called when receicing data on
           *        \p topic.
           * @param task_config The task configuration to use for the subscriber.
           * @note The task_config is only used if a subscriber is not already
           *       registered for that topic. If a subscriber is already registered for
           *       that topic, the task_config is ignored.
           * @return True if the subscriber was added, False if it was already
           *         registered for that component.

        """
        pass

    def publish(self, topic: str, data: List[int]) -> bool:
        """*
           * @brief Publish \p data on \p topic.
           * @param topic Topic to publish data on.
           * @param data Data to publish, within a vector container.
           * @return True if \p data was successfully published to \p topic, False
           *         otherwise. Publish will not occur (and will return False) if
           *         there are no subscribers for this topic.

        """
        pass

    def remove_publisher(self, topic: str, component: str) -> bool:
        """*
           * @brief Remove \p component's publisher for \p topic.
           * @param topic The topic that \p component was publishing on.
           * @param component The component for which the publisher was registered.
           * @return True if the publisher was removed, False if it was not
           *         registered.

        """
        pass

    def remove_subscriber(self, topic: str, component: str) -> bool:
        """*
           * @brief Remove \p component's subscriber for \p topic.
           * @param topic The topic that \p component was subscribing to.
           * @param component The component for which the subscriber was registered.
           * @return True if the subscriber was removed, False if it was not
           *         registered.

        """
        pass


####################    </generated_from:event_manager.hpp>    ####################


####################    <generated_from:ftp_server.hpp>    ####################





class FtpServer:
    """/ \brief A class that implements a FTP server."""
    def __init__(
        self,
        ip_address: std.string_view,
        port: int,
        root: std.filesystem.path
        ) -> None:
        """/ \brief A class that implements a FTP server.
        / \note The IP Address is not currently used to select the right
        /       interface, but is instead passed to the FtpClientSession so that
        /       it can be used in the PASV command.
        / \param ip_address The IP address to listen on.
        / \param port The port to listen on.
        / \param root The root directory of the FTP server.
        """
        pass


    def start(self) -> bool:
        """/ \brief Start the FTP server.
        / Bind to the port and start accepting connections.
        / \return True if the server was started, False otherwise.
        """
        pass

    def stop(self) -> None:
        """/ \brief Stop the FTP server."""
        pass


####################    </generated_from:ftp_server.hpp>    ####################


####################    <generated_from:logger.hpp>    ####################




# Undefine the logger verbosity levels to avoid conflicts with windows / msvc


class Logger:
    """*
     * @brief Logger provides a wrapper around nicer / more robust formatting than
     * standard ESP_LOG* macros with the ability to change the log level at
     * run-time. Logger currently is a light wrapper around libfmt (future
     * std::format).
     *
     * To save on code size, the logger has the ability to be compiled out based on
     * the log level set in the sdkconfig. This means that if the log level is set to
     * ERROR, all debug, info, and warn logs will be compiled out. This is done by
     * checking the log level at compile time and only compiling in the functions
     * that are needed.
     *
     * The logger can also be compiled with support for cursor commands. This allows
     * the logger to move the cursor up, down, clear the line, clear the screen, and
     * move the cursor to a specific position. This can be useful for creating
     * various types of interactive output or to maintian context with long-running
     * logs.
     *
     * \section logger_ex1 Basic Example
     * \snippet logger_example.cpp Logger example
     * \section logger_ex2 Threaded Logging and Verbosity Example
     * \snippet logger_example.cpp MultiLogger example
     * \section logger_ex3 Cursor Commands Example
     * \snippet logger_example.cpp Cursor Commands example

    """
    class Verbosity(enum.IntEnum):
        """*
           *   Verbosity levels for the logger, in order of increasing priority.

        """
        debug = enum.auto()                                                     # (= 0)  #*< Debug level verbosity.
        info = enum.auto()                                                      # (= 1)  #*< Info level verbosity.
        warn = enum.auto()                                                      # (= 2)  #*< Warn level verbosity.
        error = enum.auto()                                                     # (= 3)  #*< Error level verbosity.
        none = enum.auto()                                                      # (= 4)  #*< No verbosity - logger will not print anything.

    class Config:
        """*
           * @brief Configuration struct for the logger.

        """
        tag: std.string_view                                                    #*< The TAG that will be prepended to all logs.
        include_time: bool = bool(True)                                         #*< Include the time in the log.
        rate_limit: std.chrono.duration[float] = std.chrono.duration<float>(0)  #*< The rate limit for the logger. Optional, if <= 0 no
        rate limit. @note Only calls that have _rate_limited suffixed will be rate limited.
        level: Logger.Verbosity = Logger.Verbosity.warn                         #*< The verbosity level for the logger.
        def __init__(
            self,
            tag: std.string_view = std.string_view(),
            include_time: bool = bool(True),
            rate_limit: std.chrono.duration[float] = std.chrono.duration<float>(0),
            level: Logger.Verbosity = Logger.Verbosity.warn
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass


    def set_verbosity(self, level: Logger.Verbosity) -> None:
        """*
           * @brief Change the verbosity for the logger. \sa Logger::Verbosity
           * @param level new verbosity level

        """
        pass

    def set_tag(self, tag: std.string_view) -> None:
        """*
           * @brief Change the tag for the logger.
           * @param tag The new tag.

        """
        pass

    def get_tag(self) -> str:
        """*
           * @brief Get the current tag for the logger.
           * @return A const reference to the current tag.

        """
        pass

    def set_include_time(self, include_time: bool) -> None:
        """*
           * @brief Whether to include the time in the log.
           * @param include_time Whether to include the time in the log.
           * @note The time is in seconds since boot and is represented as a floating
           *       point number with precision to the millisecond.

        """
        pass

    def set_rate_limit(self, rate_limit: std.chrono.duration[float]) -> None:
        """*
           * @brief Change the rate limit for the logger.
           * @param rate_limit The new rate limit.
           * @note Only calls that have _rate_limited suffixed will be rate limited.

        """
        pass

    def get_rate_limit(self) -> std.chrono.duration[float]:
        """*
           * @brief Get the current rate limit for the logger.
           * @return The current rate limit.

        """
        pass











    @staticmethod
    def get_time() -> str:
        """*
           *   Get the current time in seconds since the start of the logging system.
           *   @return time in seconds since the start of the logging system.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass


####################    </generated_from:logger.hpp>    ####################


####################    <generated_from:bezier.hpp>    ####################


#  ------------------------------------------------------------------------
#      <template specializations for class Bezier>
class Bezier_espp_Vector2f:  # Python specialization for Bezier<espp::Vector2f>
    """*
     * @brief Implements rational / weighted and unweighted cubic bezier curves
     *        between control points.
     * @note See https://pomax.github.io/bezierinfo/ for information on bezier
     *       curves.
     * @note Template class which can be used individually on floating point
     *       values directly or on containers such as Vector2<float>.
     * @tparam T The type of the control points, e.g. float or Vector2<float>.
     * @note The bezier curve is defined by 4 control points, P0, P1, P2, P3.
     *      The curve is defined by the equation:
     *      \f$B(t) = (1-t)^3 * P0 + 3 * (1-t)^2 * t * P1 + 3 * (1-t) * t^2 * P2 + t^3 * P3\f$
     *      where t is the evaluation parameter, [0, 1].
     *
     * @note The weighted bezier curve is defined by 4 control points, P0, P1, P2, P3
     *      and 4 weights, W0, W1, W2, W3.
     *      The curve is defined by the equation:
     *      \f$B(t) = (W0 * (1-t)^3 * P0 + W1 * 3 * (1-t)^2 * t * P1 + W2 * 3 * (1-t) * t^2 * P2 + W3 *
     * t^3 * P3) / (W0 + W1 + W2 + W3)\f$ where t is the evaluation parameter, [0, 1].
     *
     * \section bezier_ex1 Example
     * \snippet math_example.cpp bezier example

    """
    class Config:
        """*
           * @brief Unweighted cubic bezier configuration for 4 control points.

        """
        control_points: List[Vector2f]            #/< Array of 4 control points
        def __init__(self) -> None:
            """Auto-generated default constructor"""
            pass

    class WeightedConfig:
        """*
           * @brief Weighted cubic bezier configuration for 4 control points with
           *        individual weights.

        """
        control_points: List[Vector2f]            #/< Array of 4 control points
        weights: List[float] = List[float](1.0, 1.0, 1.0,
                                            1.0)  #/< Array of 4 weights, default is array of 1.0
        def __init__(self) -> None:
            """Auto-generated default constructor"""
            pass



    def __call__(self, t: float) -> Vector2f:
        """*
           * @brief Evaluate the bezier at \p t.
           * @note Convienience wrapper around the at() method.
           * @param t The evaluation parameter, [0, 1].
           * @return The bezier evaluated at \p t.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass
#      </template specializations for class Bezier>
#  ------------------------------------------------------------------------

####################    </generated_from:bezier.hpp>    ####################


####################    <generated_from:fast_math.hpp>    ####################


def deg_to_rad(degrees: float) -> float:
    """*
     * @brief Convert degrees to radians
     * @param degrees Angle in degrees
     * @return Angle in radians

    """
    pass

def rad_to_deg(radians: float) -> float:
    """*
     * @brief Convert radians to degrees
     * @param radians Angle in radians
     * @return Angle in degrees

    """
    pass

def square(f: float) -> float:
    """*
     * @brief Simple square of the input.
     * @param f Value to square.
     * @return The square of f (f*f).

    """
    pass

def cube(f: float) -> float:
    """*
     * @brief Simple cube of the input.
     * @param f Value to cube.
     * @return The cube of f (f*f*f).

    """
    pass

def fast_inv_sqrt(value: float) -> float:
    """*
     * @brief Fast inverse square root approximation.
     * @note Using https://reprap.org/forum/read.php?147,219210 and
     *       https://en.wikipedia.org/wiki/Fast_inverse_square_root
     * @param value Value to take the inverse square root of.
     * @return Approximation of the inverse square root of value.

    """
    pass

#  ------------------------------------------------------------------------
#      <template specializations for function sgn>
@overload
def sgn(x: int) -> int:
    """*
     * @brief Get the sign of a number (+1, 0, or -1)
     * @param x Value to get the sign of
     * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0

    """
    pass


@overload
def sgn(x: float) -> int:
    """*
     * @brief Get the sign of a number (+1, 0, or -1)
     * @param x Value to get the sign of
     * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0

    """
    pass
#      </template specializations for function sgn>
#  ------------------------------------------------------------------------

def lerp(a: float, b: float, t: float) -> float:
    """*
     * @brief Linear interpolation between two values.
     * @param a First value.
     * @param b Second value.
     * @param t Interpolation factor in the range [0, 1].
     * @return Linear interpolation between a and b.

    """
    pass

def inv_lerp(a: float, b: float, v: float) -> float:
    """*
     * @brief Compute the inverse lerped value.
     * @param a First value (usually the lower of the two).
     * @param b Second value (usually the higher of the two).
     * @param v Value to inverse lerp (usually a value between a and b).
     * @return Inverse lerp value, the factor of v between a and b in the range [0,
     *         1] if v is between a and b, 0 if v == a, or 1 if v == b. If a == b,
     *         0 is returned. If v is outside the range [a, b], the value is
     *         extrapolated linearly (i.e. if v < a, the value is less than 0, if v
     *         > b, the value is greater than 1).

    """
    pass

def piecewise_linear(points: List[Tuple[float, float]], x: float) -> float:
    """*
     * @brief Compute the piecewise linear interpolation between a set of points.
     * @param points Vector of points to interpolate between. The vector should be
     *               sorted by the first value in the pair. The first value in the
     *               pair is the x value and the second value is the y value. The x
     *               values should be unique. The function will interpolate between
     *               the points using linear interpolation. If x is less than the
     *               first x value, the first y value is returned. If x is greater
     *               than the last x value, the last y value is returned. If x is
     *               between two x values, the y value is interpolated between the
     *               two y values.
     * @param x Value to interpolate at. Should be a value from the first
     *          distribution of the points (the domain). If x is outside the domain
     *          of the points, the value returned will be clamped to the first or
     *          last y value.
     * @return Interpolated value at x.

    """
    pass

def round(x: float) -> int:
    """*
     * @brief Round x to the nearest integer.
     * @param x Floating point value to be rounded.
     * @return Nearest integer to x.

    """
    pass

def fast_ln(x: float) -> float:
    """*
     * @brief fast natural log function, ln(x).
     * @note This speed hack comes from:
     *   https://gist.github.com/LingDong-/7e4c4cae5cbbc44400a05ba650623
     * @param x Value to take the natural log of.
     * @return ln(x)

    """
    pass


def fast_sin(angle: float) -> float:
    """*
     * @brief Fast approximation of sin(angle) (radians).
     * @note \p Angle must be in the range [0, 2PI].
     * @param angle Angle in radians [0, 2*PI]
     * @return Approximation of sin(value)

    """
    pass

def fast_cos(angle: float) -> float:
    """*
     * @brief Fast approximation of cos(angle) (radians).
     * @note \p Angle must be in the range [0, 2PI].
     * @param angle Angle in radians [0, 2*PI]
     * @return Approximation of cos(value)

    """
    pass

####################    </generated_from:fast_math.hpp>    ####################


####################    <generated_from:gaussian.hpp>    ####################


class Gaussian:
    """*
     * @brief Implements a gaussian function
     *        \f$y(t)=\alpha\exp(-\frac{(t-\beta)^2}{2\gamma^2})\f$.
     * @details Alows you to store the alpha, beta, and gamma coefficients as well
     *          as update them dynamically.
     *
     * \section gaussian_ex1 Example
     * \snippet math_example.cpp gaussian example
     * \section gaussian_ex2 Fade-In/Fade-Out Example
     * \snippet math_example.cpp gaussian fade in fade out example

    """
    class Config:
        """*
           * @brief Configuration structure for initializing the gaussian.

        """
        gamma: float               #/< Slope of the gaussian, range [0, 1]. 0 is more of a thin spike from 0 up to
        #/< max output (alpha), 1 is more of a small wave around the max output (alpha).
        alpha: float = float(1.0)  #/< Max amplitude of the gaussian output, defautls to 1.0.
        beta: float = float(0.5)   #/< Beta value for the gaussian, default to be symmetric at 0.5 in range [0,1].

        def __eq__(self, rhs: Gaussian.Config) -> bool:
            pass
        def __init__(
            self,
            gamma: float = float(),
            alpha: float = float(1.0),
            beta: float = float(0.5)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass


    def __call__(self, t: float) -> float:
        """*
           * @brief Evaluate the gaussian at \p t.
           * @note Convienience wrapper around the at() method.
           * @param t The evaluation parameter, [0, 1].
           * @return The gaussian evaluated at \p t.

        """
        pass

    def update(self, config: Gaussian.Config) -> None:
        """*
           * @brief Update the gaussian configuration.
           * @param config The new configuration.

        """
        pass

    def set_config(self, config: Gaussian.Config) -> None:
        """*
           * @brief Set the configuration of the gaussian.
           * @param config The new configuration.

        """
        pass

    def get_config(self) -> Gaussian.Config:
        """*
           * @brief Get the current configuration of the gaussian.
           * @return The current configuration.

        """
        pass

    def get_gamma(self) -> float:
        """*
           * @brief Get the gamma value.
           * @return The gamma value.

        """
        pass

    def get_alpha(self) -> float:
        """*
           * @brief Get the alpha value.
           * @return The alpha value.

        """
        pass

    def get_beta(self) -> float:
        """*
           * @brief Get the beta value.
           * @return The beta value.

        """
        pass

    def set_gamma(self, gamma: float) -> None:
        """*
           * @brief Set the gamma value.
           * @param gamma The new gamma value.

        """
        pass

    def set_alpha(self, alpha: float) -> None:
        """*
           * @brief Set the alpha value.
           * @param alpha The new alpha value.

        """
        pass

    def set_beta(self, beta: float) -> None:
        """*
           * @brief Set the beta value.
           * @param beta The new beta value.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:gaussian.hpp>    ####################


####################    <generated_from:range_mapper.hpp>    ####################


#  ------------------------------------------------------------------------
#      <template specializations for class RangeMapper>
class RangeMapper_int:  # Python specialization for RangeMapper<int>
    """*
     * @brief Template class for converting a value from an uncentered [minimum,
     *        maximum] range into a centered output range (default [-1,1]). If
     *        provided a non-zero deadband, it will convert all values within
     *        [center-deadband, center+deadband] to be the configured
     *        output_center (default 0).
     *
     *        The RangeMapper can be optionally configured to invert the input,
     *        so that it will compute the input w.r.t. the configured min/max of
     *        the input range when mapping to the output range - this will mean
     *        that a values within the ranges [minimum, minimum+deadband] and
     *        [maximum-deadband, maximum] will all map to the output_center and
     *        the input center will map to both output_max and output_min
     *        depending on the sign of the input.
     *
     * @note When inverting the input range, you are introducing a discontinuity
     *       between the input distribution and the output distribution at the
     *       input center. Noise around the input's center value will create
     *       oscillations in the output which will jump between output maximum
     *       and output minimum. Therefore it is advised to use \p invert_input
     *       sparignly, and to set the values robustly.
     *
     *        The RangeMapper can be optionally configured to invert the output,
     *        so that after converting from the input range to the output range,
     *        it will flip the sign on the output.
     *
     * \section range_mapper_ex1 Example
     * \snippet math_example.cpp range_mapper example

    """
    class Config:
        """*
           *  @brief Configuration for the input uncentered range with optional
           *  values for the centered output range, default values of 0 output center
           *  and 1 output range provide a default output range between [-1, 1].

        """
        center: int                  #*< Center value for the input range.
        center_deadband: int = 0     #*< Deadband amount around (+-) the center for which output will be 0.
        minimum: int                 #*< Minimum value for the input range.
        maximum: int                 #*< Maximum value for the input range.
        range_deadband: int = 0      #*< Deadband amount around the minimum and maximum for which output will
                                     be min/max output.
        output_center: int = 0       #*< The center for the output. Default 0.
        output_range: int = 1        #*< The range (+/-) from the center for the output. Default 1. @note Will
                                     be passed through std::abs() to ensure it is positive.
        invert_output: bool = False  #*< Whether to invert the output (default False). @note If True will flip the sign
                          of the output after converting from the input distribution.
        def __init__(
            self,
            center: int = int(),
            center_deadband: int = 0,
            minimum: int = int(),
            maximum: int = int(),
            range_deadband: int = 0,
            output_center: int = 0,
            output_range: int = 1,
            invert_output: bool = False
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def __init__(self) -> None:
        pass


    def get_center_deadband(self) -> int:
        """*
           * @brief Return the configured deadband around the center of the input
           *        distribution
           * @return Deadband around the center of the input distribution for this
           *         range mapper.

        """
        pass

    def get_minimum(self) -> int:
        """*
           * @brief Return the configured minimum of the input distribution
           * @return Minimum of the input distribution for this range mapper.

        """
        pass

    def get_maximum(self) -> int:
        """*
           * @brief Return the configured maximum of the input distribution
           * @return Maximum of the input distribution for this range mapper.

        """
        pass

    def get_range(self) -> int:
        """*
           * @brief Return the configured range of the input distribution
           * @note Always positive.
           * @return Range of the input distribution for this range mapper.

        """
        pass

    def get_range_deadband(self) -> int:
        """*
           * @brief Return the configured deadband around the min/max of the input
           *        distribution
           * @return Deadband around the min/max of the input distribution for this
           *         range mapper.

        """
        pass

    def get_output_center(self) -> int:
        """*
           * @brief Return the configured center of the output distribution
           * @return Center of the output distribution for this range mapper.

        """
        pass

    def get_output_range(self) -> int:
        """*
           * @brief Return the configured range of the output distribution
           * @note Always positive.
           * @return Range of the output distribution for this range mapper.

        """
        pass

    def get_output_min(self) -> int:
        """*
           * @brief Return the configured minimum of the output distribution
           * @return Minimum of the output distribution for this range mapper.

        """
        pass

    def get_output_max(self) -> int:
        """*
           * @brief Return the configured maximum of the output distribution
           * @return Maximum of the output distribution for this range mapper.

        """
        pass

    def set_center_deadband(self, deadband: int) -> None:
        """*
           * @brief Set the deadband around the center of the input distribution.
           * @param deadband The deadband to use around the center of the input
           *        distribution.
           * @note The deadband must be non-negative.
           * @note The deadband is applied around the center value of the input
           *       distribution.

        """
        pass

    def set_range_deadband(self, deadband: int) -> None:
        """*
           * @brief Set the deadband around the min/max of the input distribution.
           * @param deadband The deadband to use around the min/max of the input
           *        distribution.
           * @note The deadband must be non-negative.
           * @note The deadband is applied around the min/max values of the input
           *       distribution.

        """
        pass

    def map(self, v: int) -> int:
        """*
           * @brief Map a value \p v from the input distribution into the configured
           *        output range (centered, default [-1,1]).
           * @param v Value from the (possibly uncentered and possibly inverted -
           *        defined by the previously configured Config) input distribution
           * @return Value within the centered output distribution.

        """
        pass

    def unmap(self, v: int) -> int:
        """*
           * @brief Unmap a value \p v from the configured output range (centered,
           *        default [-1,1]) back into the input distribution.
           * @param T&v Value from the centered output distribution.
           * @return Value within the input distribution.

        """
        pass



class RangeMapper_float:  # Python specialization for RangeMapper<float>
    """*
     * @brief Template class for converting a value from an uncentered [minimum,
     *        maximum] range into a centered output range (default [-1,1]). If
     *        provided a non-zero deadband, it will convert all values within
     *        [center-deadband, center+deadband] to be the configured
     *        output_center (default 0).
     *
     *        The RangeMapper can be optionally configured to invert the input,
     *        so that it will compute the input w.r.t. the configured min/max of
     *        the input range when mapping to the output range - this will mean
     *        that a values within the ranges [minimum, minimum+deadband] and
     *        [maximum-deadband, maximum] will all map to the output_center and
     *        the input center will map to both output_max and output_min
     *        depending on the sign of the input.
     *
     * @note When inverting the input range, you are introducing a discontinuity
     *       between the input distribution and the output distribution at the
     *       input center. Noise around the input's center value will create
     *       oscillations in the output which will jump between output maximum
     *       and output minimum. Therefore it is advised to use \p invert_input
     *       sparignly, and to set the values robustly.
     *
     *        The RangeMapper can be optionally configured to invert the output,
     *        so that after converting from the input range to the output range,
     *        it will flip the sign on the output.
     *
     * \section range_mapper_ex1 Example
     * \snippet math_example.cpp range_mapper example

    """
    class Config:
        """*
           *  @brief Configuration for the input uncentered range with optional
           *  values for the centered output range, default values of 0 output center
           *  and 1 output range provide a default output range between [-1, 1].

        """
        center: float                #*< Center value for the input range.
        center_deadband: float = 0   #*< Deadband amount around (+-) the center for which output will be 0.
        minimum: float               #*< Minimum value for the input range.
        maximum: float               #*< Maximum value for the input range.
        range_deadband: float = 0    #*< Deadband amount around the minimum and maximum for which output will
                                     be min/max output.
        output_center: float = 0     #*< The center for the output. Default 0.
        output_range: float = 1      #*< The range (+/-) from the center for the output. Default 1. @note Will
                                     be passed through std::abs() to ensure it is positive.
        invert_output: bool = False  #*< Whether to invert the output (default False). @note If True will flip the sign
                          of the output after converting from the input distribution.
        def __init__(
            self,
            center: float = float(),
            center_deadband: float = 0,
            minimum: float = float(),
            maximum: float = float(),
            range_deadband: float = 0,
            output_center: float = 0,
            output_range: float = 1,
            invert_output: bool = False
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def __init__(self) -> None:
        pass


    def get_center_deadband(self) -> float:
        """*
           * @brief Return the configured deadband around the center of the input
           *        distribution
           * @return Deadband around the center of the input distribution for this
           *         range mapper.

        """
        pass

    def get_minimum(self) -> float:
        """*
           * @brief Return the configured minimum of the input distribution
           * @return Minimum of the input distribution for this range mapper.

        """
        pass

    def get_maximum(self) -> float:
        """*
           * @brief Return the configured maximum of the input distribution
           * @return Maximum of the input distribution for this range mapper.

        """
        pass

    def get_range(self) -> float:
        """*
           * @brief Return the configured range of the input distribution
           * @note Always positive.
           * @return Range of the input distribution for this range mapper.

        """
        pass

    def get_range_deadband(self) -> float:
        """*
           * @brief Return the configured deadband around the min/max of the input
           *        distribution
           * @return Deadband around the min/max of the input distribution for this
           *         range mapper.

        """
        pass

    def get_output_center(self) -> float:
        """*
           * @brief Return the configured center of the output distribution
           * @return Center of the output distribution for this range mapper.

        """
        pass

    def get_output_range(self) -> float:
        """*
           * @brief Return the configured range of the output distribution
           * @note Always positive.
           * @return Range of the output distribution for this range mapper.

        """
        pass

    def get_output_min(self) -> float:
        """*
           * @brief Return the configured minimum of the output distribution
           * @return Minimum of the output distribution for this range mapper.

        """
        pass

    def get_output_max(self) -> float:
        """*
           * @brief Return the configured maximum of the output distribution
           * @return Maximum of the output distribution for this range mapper.

        """
        pass

    def set_center_deadband(self, deadband: float) -> None:
        """*
           * @brief Set the deadband around the center of the input distribution.
           * @param deadband The deadband to use around the center of the input
           *        distribution.
           * @note The deadband must be non-negative.
           * @note The deadband is applied around the center value of the input
           *       distribution.

        """
        pass

    def set_range_deadband(self, deadband: float) -> None:
        """*
           * @brief Set the deadband around the min/max of the input distribution.
           * @param deadband The deadband to use around the min/max of the input
           *        distribution.
           * @note The deadband must be non-negative.
           * @note The deadband is applied around the min/max values of the input
           *       distribution.

        """
        pass

    def map(self, v: float) -> float:
        """*
           * @brief Map a value \p v from the input distribution into the configured
           *        output range (centered, default [-1,1]).
           * @param v Value from the (possibly uncentered and possibly inverted -
           *        defined by the previously configured Config) input distribution
           * @return Value within the centered output distribution.

        """
        pass

    def unmap(self, v: float) -> float:
        """*
           * @brief Unmap a value \p v from the configured output range (centered,
           *        default [-1,1]) back into the input distribution.
           * @param T&v Value from the centered output distribution.
           * @return Value within the input distribution.

        """
        pass

#      </template specializations for class RangeMapper>
#  ------------------------------------------------------------------------




####################    </generated_from:range_mapper.hpp>    ####################


####################    <generated_from:vector2d.hpp>    ####################


















def dot(other: Vector2d) -> T:
    """*
       * @brief Dot product of this vector with another vector.
       * @param other The second vector
       * @return The dot product (x1*x2 + y1*y2)

    """
    pass






# namespace espp

####################    </generated_from:vector2d.hpp>    ####################


####################    <generated_from:ndef.hpp>    ####################



class Ndef:
    """*
     * @brief implements serialization & deserialization logic for NFC Data
     *        Exchange Format (NDEF) records which can be stored on and
     *        transmitted from NFC devices.
     *
     * @details NDEF records can be composed the following way:
     *   @code{.unparsed}
     *   Bit 7     6       5       4       3       2       1       0
     *   ------  ------  ------  ------  ------  ------  ------  ------
     *   [ MB ]  [ ME ]  [ CF ]  [ SR ]  [ IL ]  [        TNF         ]
     *   [                         TYPE LENGTH  (may be 0)            ]
     *   [                       PAYLOAD LENGTH (1B or 4B, see SR)    ]
     *   [                          ID LENGTH   (if IL)               ]
     *   [                         RECORD TYPE  (if TYPE LENGTH > 0)  ]
     *   [                              ID      (if IL)               ]
     *   [                           PAYLOAD    (payload length bytes)]
     *  @endcode
     *
     *  The first byte (Flags) has these bits:
     *  * Bits 0-3: TNF - Type Name Format - describes record type (see TNF class)
     *  * Bit 3: IL - ID Length - indicates if the ID Length Field is present or not
     *  * Bit 4: SR - Short Record - set to 1 if the payload length field is 1 byte (8
     *      bits / 0-255) or less, otherwise the payload length is 4 bytes
     *  * Bit 5: CF - Chunk Flag - indicates if this is the first record chunk or a
     *      middle record chunk, set to 0 for the first record of the message and
     *      for subsequent records set to 1.
     *  * Bit 6: ME - Message End - 1 indicates if this is the last record in the
     *      message
     *  * Bit 7: MB - Message Begin - 1 indicates if this is the first record in the
     *      message
     *
     * @note Some information about NDEF can be found:
     *       * https://www.maskaravivek.com/post/understanding-the-format-of-ndef-messages/
     *       * https://ndeflib.readthedocs.io/en/stable/records/bluetooth.html
     *       * https://developer.android.com/reference/android/nfc/NdefMessage
     *       * https://www.oreilly.com/library/view/beginning-nfc/9781449324094/ch04.html
     *       * https://learn.adafruit.com/adafruit-pn532-rfid-nfc/ndef
     *

    """
    class TNF(enum.IntEnum):
        """*
           * @brief Type Name Format (TNF) field is a 3-bit value that describes the
           *        record type.
           *
           * Some Common TNF::WELL_KNOWN record type strings:
           *   * Text (T)
           *   * URI  (U)
           *   * Smart Poster (Sp)
           *   * Alternative Carrier (ac)
           *   * Handover Carrier (Hc)
           *   * Handover Request (Hr)
           *   * Handover Select (Hs)

        """
        empty = enum.auto()                                                                      # (= 0x00)  #/< Record is empty
        well_known = enum.auto()                                                                 # (= 0x01)  #/< Type field contains a well-known RTD type name
        mime_media = enum.auto()                                                                 # (= 0x02)  #/< Type field contains a media type (RFC 2046)
        absolute_uri = enum.auto()                                                               # (= 0x03)  #/< Type field contains an absolute URI (RFC 3986)
        external_type = enum.auto()                                                              # (= 0x04)  #/< Type field Contains an external type name
        unknown = enum.auto()                                                                    # (= 0x05)  #/< Payload type is unknown, type length must be 0.
        unchanged = enum.auto()                                                                  # (= 0x06)  #/< Indicates the payload is an intermediate or final chunk of a chunked NDEF
        #/< record, type length must be 0.
        reserved = enum.auto()                                                                   # (= 0x07)  #/< Reserved by the NFC forum for future use

    class Uic(enum.IntEnum):
        """*
           * URI Identifier Codes (UIC), See Table A-3 at
           * https://www.oreilly.com/library/view/beginning-nfc/9781449324094/apa.html
           * and https://learn.adafruit.com/adafruit-pn532-rfid-nfc/ndef

        """
        none = enum.auto()                                                                       # (= 0x00)  #/< Exactly as written
        http_www = enum.auto()                                                                   # (= 0x01)  #/< http://www.
        https_www = enum.auto()                                                                  # (= 0x02)  #/< https://www.
        http = enum.auto()                                                                       # (= 0x03)  #/< http://
        https = enum.auto()                                                                      # (= 0x04)  #/< https://
        tel = enum.auto()                                                                        # (= 0x05)  #/< tel:
        mailto = enum.auto()                                                                     # (= 0x06)  #/< mailto:
        ftp_anon = enum.auto()                                                                   # (= 0x07)  #/< ftp://anonymous:anonymous@
        ftp_ftp = enum.auto()                                                                    # (= 0x08)  #/< ftp://ftp.
        ftps = enum.auto()                                                                       # (= 0x09)  #/< ftps://
        sftp = enum.auto()                                                                       # (= 0x0A)  #/< sftp://
        smb = enum.auto()                                                                        # (= 0x0B)  #/< smb://
        nfs = enum.auto()                                                                        # (= 0x0C)  #/< nfs://
        ftp = enum.auto()                                                                        # (= 0x0D)  #/< ftp://
        dav = enum.auto()                                                                        # (= 0x0E)  #/< dav://
        news = enum.auto()                                                                       # (= 0x0F)  #/< news:
        telnet = enum.auto()                                                                     # (= 0x10)  #/< telnet://
        imap = enum.auto()                                                                       # (= 0x11)  #/< imap:
        rstp = enum.auto()                                                                       # (= 0x12)  #/< rtsp://
        urn = enum.auto()                                                                        # (= 0x13)  #/< urn:
        pop = enum.auto()                                                                        # (= 0x14)  #/< pop:
        sip = enum.auto()                                                                        # (= 0x15)  #/< sip:
        sips = enum.auto()                                                                       # (= 0x16)  #/< sips:
        tftp = enum.auto()                                                                       # (= 0x17)  #/< tftp:
        btspp = enum.auto()                                                                      # (= 0x18)  #/< btspp://
        btl2_cap = enum.auto()                                                                   # (= 0x19)  #/< btl2cap://
        btgoep = enum.auto()                                                                     # (= 0x1A)  #/< btgoep://
        tcpobex = enum.auto()                                                                    # (= 0x1B)  #/< tcpobex://
        irdaobex = enum.auto()                                                                   # (= 0x1C)  #/< irdaobex://
        file = enum.auto()                                                                       # (= 0x1D)  #/< file://
        urn_epc_id = enum.auto()                                                                 # (= 0x1E)  #/< urn:epc:id:
        urn_epc_tag = enum.auto()                                                                # (= 0x1F)  #/< urn:epc:tag:
        urn_epc_pat = enum.auto()                                                                # (= 0x20)  #/< urn:epc:pat:
        urn_epc_raw = enum.auto()                                                                # (= 0x21)  #/< urn:epc:raw:
        urn_epc = enum.auto()                                                                    # (= 0x22)  #/< urn:epc:
        urn_nfc = enum.auto()                                                                    # (= 0x23)  #/< urn:nfc:

    class BtType(enum.IntEnum):
        """*
           * @brief Type of Bluetooth radios.

        """
        bredr = enum.auto()                                                                      # (= 0x00)  #/< BT Classic
        ble = enum.auto()                                                                        # (= 0x01)  #/< BT Low Energy

    class BtAppearance(enum.IntEnum):
        """*
           * @brief Some appearance codes for BLE radios.

        """
        unknown = enum.auto()                                                                    # (= 0x0000)  #/< Generic Unknown
        # Generic Phone (b15-b6 = 0x001 << 6 = 0x0040)
        phone = enum.auto()                                                                      # (= 0x0040)  #/< Generic Phone
        # Generic Computer (b15-b6 = 0x002 << 6 = 0x0080)
        computer = enum.auto()                                                                   # (= 0x0080)  #/< Generic Computer
        # Generic Watch (b15-b6 = 0x003 << 6 = 0x00C0)
        watch = enum.auto()                                                                      # (= 0x00C0)  #/< Generic Watch
        # Generic Clock (b15-b6 = 0x004 << 6 = 0x0100)
        clock = enum.auto()                                                                      # (= 0x0100)  #/< Generic Clock
        # Generic Computer (b15-b6 = 0x005 << 6 = 0x0140)
        display = enum.auto()                                                                    # (= 0x0140)  #/< Generic Display
        # Generic Computer (b15-b6 = 0x006 << 6 = 0x0180)
        remote_control = enum.auto()                                                             # (= 0x0180)  #/< Generic Remote Control
        # Generic HID (b15-b6 = 0x00F << 6 = 0x03C0)
        generic_hid = enum.auto()                                                                # (= 0x03C0)  #/< Generic HID
        keyboard = enum.auto()                                                                   # (= 0x03C1)  #/< HID Keyboard
        mouse = enum.auto()                                                                      # (= 0x03C2)  #/< HID Mouse
        joystick = enum.auto()                                                                   # (= 0x03C3)  #/< HID Joystick
        gamepad = enum.auto()                                                                    # (= 0x03C4)  #/< HID Gamepad
        touchpad = enum.auto()                                                                   # (= 0x03C9)  #/< HID Touchpad
        # Generic Gaming (b15-b6 = 0x02A << 6 = 0x0A80)
        gaming = enum.auto()                                                                     # (= 0x0A80)  #/< Generic Gaming group

    class CarrierPowerState(enum.IntEnum):
        """*
           * @brief Power state of a BLE radio.
           * @details Representation of the carrier power state in a Handover Select
           *          message.

        """
        inactive = enum.auto()                                                                   # (= 0x00)  #/< Carrier power is off
        active = enum.auto()                                                                     # (= 0x01)  #/< Carrier power is on
        activating = enum.auto()                                                                 # (= 0x02)  #/< Carrier power is turning on
        unknown = enum.auto()                                                                    # (= 0x03)  #/< Carrier power state is unknown

    class BtEir(enum.IntEnum):
        """*
           * @brief Extended Inquiry Response (EIR) codes for data types in BT and BLE
           *        out of band (OOB) pairing NDEF records.

        """
        flags = enum.auto()                                                                      # (= 0x01)  #/< BT flags: b0: LE limited discoverable mode, b1: LE general discoverable mode,
        #/< b2: BR/EDR not supported, b3: Simultaneous LE & BR/EDR controller, b4:
        #/< simultaneous LE & BR/EDR Host
        uuids_16_bit_partial = enum.auto()                                                       # (= 0x02)  #/< Incomplete list of 16 bit service class UUIDs
        uuids_16_bit_complete = enum.auto()                                                      # (= 0x03)  #/< Complete list of 16 bit service class UUIDs
        uuids_32_bit_partial = enum.auto()                                                       # (= 0x04)  #/< Incomplete list of 32 bit service class UUIDs
        uuids_32_bit_complete = enum.auto()                                                      # (= 0x05)  #/< Complete list of 32 bit service class UUIDs
        uuids_128_bit_partial = enum.auto()                                                      # (= 0x06)  #/< Incomplete list of 128 bit service class UUIDs
        uuids_128_bit_complete = enum.auto()                                                     # (= 0x07)  #/< Complete list of 128 bit service class UUIDs
        short_local_name = enum.auto()                                                           # (= 0x08)  #/< Shortened Bluetooth Local Name
        long_local_name = enum.auto()                                                            # (= 0x09)  #/< Complete Bluetooth Local Name
        tx_power_level = enum.auto()                                                             # (= 0x0A)  #/< TX Power level (1 byte), -127 dBm to +127 dBm
        class_of_device = enum.auto()                                                            # (= 0x0D)  #/< Class of Device
        sp_hash_c192 = enum.auto()                                                               # (= 0x0E)  #/< Simple Pairing Hash C-192
        sp_random_r192 = enum.auto()                                                             # (= 0x0F)  #/< Simple Pairing Randomizer R-192
        security_manager_tk = enum.auto()                                                        # (= 0x10)  #/< Security Manager TK Value (LE Legacy Pairing)
        security_manager_flags = enum.auto()                                                     # (= 0x11)  #/< Flags (1 B), b0: OOB flags field (1 = 00B data present, 0 not), b1: LE Supported
        #/< (host), b2: Simultaneous LE & BR/EDR to same device capable (host), b3: address
        #/< type (0 = public, 1 = random)
        appearance = enum.auto()                                                                 # (= 0x19)  #/< Appearance
        mac = enum.auto()                                                                        # (= 0x1B)  #/< Bluetooth Device Address
        le_role = enum.auto()                                                                    # (= 0x1C)  #/< LE Role
        sp_hash_c256 = enum.auto()                                                               # (= 0x1D)  #/< Simple Pairing Hash C-256
        sp_hash_r256 = enum.auto()                                                               # (= 0x1E)  #/< Simple Pairing Randomizer R-256
        le_sc_confirmation = enum.auto()                                                         # (= 0x22)  #/< LE Secure Connections Confirmation Value
        le_sc_random = enum.auto()                                                               # (= 0x23)  #/< LE Secure Connections Random Value

    class BleRole(enum.IntEnum):
        """*
           * @brief Possible roles for BLE records to indicate support for.

        """
        peripheral_only = enum.auto()                                                            # (= 0x00)  #/< Radio can only act as a peripheral
        central_only = enum.auto()                                                               # (= 0x01)  #/< Radio can only act as a central
        peripheral_central = enum.auto()                                                         # (= 0x02)  #/< Radio can act as both a peripheral and a central, but prefers peripheral
        central_peripheral = enum.auto()                                                         # (= 0x03)  #/< Radio can act as both a peripheral and a central, but prefers central

    class WifiEncryptionType(enum.IntEnum):
        """*
           * @brief Types of configurable encryption for WiFi networks

        """
        none = enum.auto()                                                                       # (= 0x01)  #/< No encryption
        wep = enum.auto()                                                                        # (= 0x02)  #/< WEP
        tkip = enum.auto()                                                                       # (= 0x04)  #/< TKIP
        aes = enum.auto()                                                                        # (= 0x08)  #/< AES

    class WifiAuthenticationType(enum.IntEnum):
        """*
           * @brief WiFi network authentication

        """
        open = enum.auto()                                                                       # (= 0x01)  #/< Open / no security
        wpa_personal = enum.auto()                                                               # (= 0x02)  #/< WPA personal
        shared = enum.auto()                                                                     # (= 0x04)  #/< Shared key
        wpa_enterprise = enum.auto()                                                             # (= 0x08)  #/< WPA enterprise
        wpa2_enterprise = enum.auto()                                                            # (= 0x10)  #/< WPA2 Enterprise
        wpa2_personal = enum.auto()                                                              # (= 0x20)  #/< WPA2 personal
        wpa_wpa2_personal = enum.auto()                                                          # (= 0x22)  #/< Both WPA and WPA2 personal

    handover_version: int = 0x13                                                                 #/< Connection Handover version 1.3 # (C++ static member) # (const)

    def __init__(
        self,
        tnf: Ndef.TNF,
        type: std.string_view,
        payload: std.string_view
        ) -> None:
        """*
           * @brief Makes an NDEF record with header and payload.
           * @param tnf The TNF for this packet.
           * @param type String view for the type of this packet
           * @param payload The payload data for the packet

        """
        pass

    @staticmethod
    def make_text(text: std.string_view) -> Ndef:
        """*
           * @brief Static function to make an NDEF record for transmitting english
           *        text.
           * @param text The text that the NDEF record will hold.
           * @return NDEF record object.

        """
        pass

    @staticmethod
    def make_uri(uri: std.string_view, uic: Ndef.Uic = Ndef.Uic.none) -> Ndef:
        """*
           * @brief Static function to make an NDEF record for loading a URI.
           * @param uri URI for the record to point to.
           * @param uic UIC for the uri - helps shorten the uri text / NDEF record.
           * @return NDEF record object.

        """
        pass

    @staticmethod
    def make_android_launcher(uri: std.string_view) -> Ndef:
        """*
           * @brief Static function to make an NDEF record for launching an Android App.
           * @param uri URI for the android package / app to launch.
           * @return NDEF record object.

        """
        pass

    class WifiConfig:
        """*
           * @brief Configuration structure for wifi configuration ndef structure.

        """
        ssid: std.string_view                                                                    #/< SSID for the network
        key: std.string_view                                                                     #/< Security key / password for the network
        authentication: Ndef.WifiAuthenticationType = Ndef.WifiAuthenticationType.wpa2_personal  #/< Authentication type the network
        #/< uses.
        encryption: Ndef.WifiEncryptionType = Ndef.WifiEncryptionType.aes                        #/< Encryption type the network uses.
        mac_address: int = 0xFFFFFFFFFFFF                                                        #/< Broadcast MAC address FF:FF:FF:FF:FF:FF
        def __init__(
            self,
            ssid: std.string_view = std.string_view(),
            key: std.string_view = std.string_view(),
            authentication: Ndef.WifiAuthenticationType = Ndef.WifiAuthenticationType.wpa2_personal,
            encryption: Ndef.WifiEncryptionType = Ndef.WifiEncryptionType.aes,
            mac_address: int = 0xFFFFFFFFFFFF
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    @staticmethod
    def make_wifi_config(config: Ndef.WifiConfig) -> Ndef:
        """*
           * @brief Create a WiFi credential tag.
           * @param config WifiConfig describing the WiFi network.
           * @return NDEF record object.

        """
        pass

    @staticmethod
    def make_collision_resolution_record(random_number: int) -> Ndef:
        """
           * @brief Create a collision resolution record.
           * @param random_number Random number to use for the collision resolution.
           * @return NDEF record object.

        """
        pass

    @staticmethod
    def make_handover_select(carrier_data_ref: int) -> Ndef:
        """*
           * @brief Create a Handover Select record for a Bluetooth device.
           * @see
           * https://members.nfc-forum.org/apps/group_public/download.php/18688/NFCForum-AD-BTSSP_1_1.pdf
           * @param carrier_data_ref Reference to the carrier data record, which is the
           *        record that contains the actual bluetooth data. This should be the
           *        same as the id of the carrier data record, such as '0'.
           * @return NDEF record object.

        """
        pass

    @staticmethod
    def make_handover_request(carrier_data_ref: int) -> Ndef:
        """*
           * @brief Create a Handover request record for a Bluetooth device.
           * @see
           * https://members.nfc-forum.org/apps/group_public/download.php/18688/NFCForum-AD-BTSSP_1_1.pdf
           * @param carrier_data_ref Reference to the carrier data record, which is the
           *        record that contains the actual bluetooth data. This should be the
           *        same as the id of the carrier data record, such as '0'.
           * @return NDEF record object.

        """
        pass

    @staticmethod
    def make_alternative_carrier(
        power_state: Ndef.CarrierPowerState,
        carrier_data_ref: int
        ) -> Ndef:
        """*
           * @brief Create a Handover Request record for a Bluetooth device.
           * @details See page 18 of https://core.ac.uk/download/pdf/250136576.pdf for more details.
           * @param power_state Power state of the alternative carrier.
           * @param carrier_data_ref Reference to the carrier data record, which is the
           *        record that contains the actual bluetooth data. This should be the
           *        same as the id of the carrier data record, such as '0'.
           * @return NDEF record object.

        """
        pass

    @staticmethod
    def make_oob_pairing(
        mac_addr: int,
        device_class: int,
        name: std.string_view,
        random_value: std.string_view = "",
        confirm_value: std.string_view = ""
        ) -> Ndef:
        """*
           * @brief Static function to make an NDEF record for BT classic OOB Pairing (Android).
           * @param mac_addr 48 bit MAC Address of the BT radio
           * @note If the address is e.g. f4:12:fa:42:fe:9e then the mac_addr should be
           *       0xf412a42e9e.
           * @param device_class The bluetooth device class for this radio.
           * @param name Name of the BT device.
           * @param random_value The Simple pairing randomizer R for the pairing.
           * @param confirm_value The Simple pairing hash C (confirm value) for the
           *                      pairing.
           * @return NDEF record object.

        """
        pass

    @staticmethod
    def make_le_oob_pairing(
        mac_addr: int,
        role: Ndef.BleRole,
        name: std.string_view = "",
        appearance: Ndef.BtAppearance = Ndef.BtAppearance.unknown,
        random_value: std.string_view = "",
        confirm_value: std.string_view = "",
        tk: std.string_view = ""
        ) -> Ndef:
        """*
           * @brief Static function to make an NDEF record for BLE OOB Pairing (Android).
           * @param mac_addr 48 bit MAC Address of the BLE radio.
           * @note If the address is e.g. f4:12:fa:42:fe:9e then the mac_addr should be
           *       0xf412a42e9e.
           * @param role The BLE role of the device (central / peripheral / dual)
           * @param name Name of the BLE device. Optional.
           * @param appearance BtAppearance of the device. Optional.
           * @param random_value The Simple pairing randomizer R for the pairing. (16 bytes, optional)
           * @param confirm_value The Simple pairing hash C (confirm value) for the pairing. (16 bytes,
           * optional)
           * @param tk Temporary key for the pairing (16 bytes, optional)
           * @return NDEF record object.

        """
        pass

    def serialize(self, message_begin: bool = True, message_end: bool = True) -> List[int]:
        """*
           * @brief Serialize the NDEF record into a sequence of bytes.
           * @param message_begin True if this is the first record in the message.
           * @param message_end True if this is the last record in the message.
           * @return The vector<uint8_t> of bytes representing the NDEF record.

        """
        pass

    def payload(self) -> List[int]:
        """*
           * @brief Return just the payload as a vector of bytes.
           * @return Payload of the NDEF record as a vector of bytes.

        """
        pass

    def set_id(self, id: int) -> None:
        """*
           * @brief Set the payload ID of the NDEF record.
           * @param id ID of the NDEF record.

        """
        pass

    def get_id(self) -> int:
        """*
           * @brief Get the ID of the NDEF record.
           * @return ID of the NDEF record.

        """
        pass

    def get_size(self) -> int:
        """*
           * @brief Get the number of bytes needed for the NDEF record.
           * @return Size of the NDEF record (bytes), for serialization.

        """
        pass


####################    </generated_from:ndef.hpp>    ####################


####################    <generated_from:pid.hpp>    ####################



class Pid:
    """*
     *  @brief Simple PID (proportional, integral, derivative) controller class
     *         with integrator clamping, output clamping, and prevention of
     *         integrator windup during output saturation. This class is
     *         thread-safe, so you can update(), clear(), and change_gains() from
     *         multiple threads if needed.
     *
     * \section pid_ex1 Basic PID Example
     * \snippet pid_example.cpp pid example
     * \section pid_ex2 Complex PID Example
     * \snippet pid_example.cpp complex pid example

    """
    class Config:
        kp: float                                                              #*< Proportional gain.
        ki: float                                                              #*< Integral gain. @note should not be pre-multiplied by the time constant.
        kd: float                                                              #*< Derivative gain. @note should not be pre-divided by the time-constant.
        integrator_min: float                                                  #*< Minimum value the integrator can wind down to. @note Operates at the
                                     same scale as \p output_min and \p output_max. Could be 0 or negative.
                                     Can have different magnitude from integrator_max for asymmetric
                                     response.
        integrator_max: float                                                  #*< Maximum value the integrator can wind up to. @note Operates at the
                                     same scale as \p output_min and \p output_max.
        output_min: float                                                      #*< Limit the minimum output value. Can be a different magnitude from output
                                 max for asymmetric output behavior.
        output_max: float                                                      #*< Limit the maximum output value.
        log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)  #*< Verbosity for the adc logger.
        def __init__(
            self,
            kp: float = float(),
            ki: float = float(),
            kd: float = float(),
            integrator_min: float = float(),
            integrator_max: float = float(),
            output_min: float = float(),
            output_max: float = float(),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass


    def set_config(self, config: Pid.Config, reset_state: bool = True) -> None:
        """*
           * @brief Change the gains and other configuration for the PID controller.
           * @param config Configuration struct with new gains and sampling time.
           * @param reset_state Reset / clear the PID controller state.

        """
        pass

    def clear(self) -> None:
        """*
           * @brief Clear the PID controller state.

        """
        pass

    def update(self, error: float) -> float:
        """*
           * @brief Update the PID controller with the latest error measurement,
           *        getting the output control signal in return.
           *
           * @note Tracks invocation timing to better compute time-accurate
           *       integral/derivative signals.
           *
           * @param error Latest error signal.
           * @return The output control signal based on the PID state and error.

        """
        pass

    def __call__(self, error: float) -> float:
        """*
           * @brief Update the PID controller with the latest error measurement,
           *        getting the output control signal in return.
           *
           * @note Tracks invocation timing to better compute time-accurate
           *       integral/derivative signals.
           *
           * @param error Latest error signal.
           * @return The output control signal based on the PID state and error.

        """
        pass

    def get_error(self) -> float:
        """*
           * @brief Get the current error (as of the last time update() or operator()
           *        were called)
           * @return Most recent error.

        """
        pass

    def get_integrator(self) -> float:
        """*
           * @brief Get the current integrator (as of the last time update() or
           *        operator() were called)
           * @return Most recent integrator value.

        """
        pass

    def get_config(self) -> Pid.Config:
        """*
           * @brief Get the configuration for the PID (gains, etc.).
           * @return Config structure containing gains, etc.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass


####################    </generated_from:pid.hpp>    ####################


####################    <generated_from:socket.hpp>    ####################






class Socket:
    """*
     *   @brief Class for a generic socket with some helper functions for
     *          configuring the socket.

    """
    class Type(enum.IntEnum):
        raw = enum.auto()    # (= SOCK_RAW)  #*< Only IP headers, no TCP or UDP headers as well.
        dgram = enum.auto()  # (= SOCK_DGRAM)  #*< UDP/IP socket - datagram.
        stream = enum.auto() # (= SOCK_STREAM)  #*< TCP/IP socket - stream.

    class Info:
        """*
           *  @brief Storage for socket information (address, port) with convenience
           *         functions to convert to/from POSIX structures.

        """
        address: str         #*< IP address of the endpoint as a string.
        port: int            #*< Port of the endpoint as an integer.

        def init_ipv4(self, addr: str, prt: int) -> None:
            """*
                 * @brief Initialize the struct as an ipv4 address/port combo.
                 * @param addr IPv4 address string
                 * @param prt port number

            """
            pass

        def ipv4_ptr(self) -> struct sockaddr_in:
            """*
                 * @brief Gives access to IPv4 sockaddr structure (sockaddr_in) for use
                 *        with low level socket calls like sendto / recvfrom.
                 * @return *sockaddr_in pointer to ipv4 data structure

            """
            pass

        def ipv6_ptr(self) -> struct sockaddr_in6:
            """*
                 * @brief Gives access to IPv6 sockaddr structure (sockaddr_in6) for use
                 *        with low level socket calls like sendto / recvfrom.
                 * @return *sockaddr_in6 pointer to ipv6 data structure

            """
            pass

        def update(self) -> None:
            """*
                 * @brief Will update address and port based on the curent data in raw.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_storage) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_in) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass

        @overload
        def from_sockaddr(self, source_address: struct sockaddr_in6) -> None:
            """*
                 * @brief Fill this Info from the provided sockaddr struct.
                 * @param &source_address sockaddr info filled out by recvfrom.

            """
            pass
        def __init__(self, address: str = "", port: int = int()) -> None:
            """Auto-generated default constructor with named params"""
            pass






    def is_valid(self) -> bool:
        """*
           * @brief Is the socket valid.
           * @return True if the socket file descriptor is >= 0.

        """
        pass

    @staticmethod
    def is_valid_fd(socket_fd: sock_type_t) -> bool:
        """*
           * @brief Is the socket valid.
           * @param socket_fd Socket file descriptor.
           * @return True if the socket file descriptor is >= 0.

        """
        pass

    def get_ipv4_info(self) -> Optional[Socket.Info]:
        """*
           * @brief Get the Socket::Info for the socket.
           * @details This will call getsockname() on the socket to get the
           *          sockaddr_storage structure, and then fill out the Socket::Info
           *          structure.
           * @return Socket::Info for the socket.

        """
        pass

    def set_receive_timeout(self, timeout: std.chrono.duration[float]) -> bool:
        """*
           * @brief Set the receive timeout on the provided socket.
           * @param timeout requested timeout, must be > 0.
           * @return True if SO_RECVTIMEO was successfully set.

        """
        pass

    def enable_reuse(self) -> bool:
        """*
           * @brief Allow others to use this address/port combination after we're done
           *        with it.
           * @return True if SO_REUSEADDR and SO_REUSEPORT were successfully set.

        """
        pass

    def make_multicast(self, time_to_live: int = 1, loopback_enabled: int = True) -> bool:
        """*
           * @brief Configure the socket to be multicast (if time_to_live > 0).
           *        Sets the IP_MULTICAST_TTL (number of multicast hops allowed) and
           *        optionally configures whether this node should receive its own
           *        multicast packets (IP_MULTICAST_LOOP).
           * @param time_to_live number of multicast hops allowed (TTL).
           * @param loopback_enabled Whether to receive our own multicast packets.
           * @return True if IP_MULTICAST_TTL and IP_MULTICAST_LOOP were set.

        """
        pass

    def add_multicast_group(self, multicast_group: str) -> bool:
        """*
           * @brief If this is a server socket, add it to the provided the multicast
           *        group.
           *
           *         @note Multicast groups must be Class D addresses (224.0.0.0 to
           *                239.255.255.255)
           *
           *        See https://en.wikipedia.org/wiki/Multicast_address for more
           *        information.
           * @param multicast_group multicast group to join.
           * @return True if IP_ADD_MEMBERSHIP was successfully set.

        """
        pass

    def select(self, timeout: std.chrono.microseconds) -> int:
        """*
           * @brief Select on the socket for read events.
           * @param timeout how long to wait for an event.
           * @return number of events that occurred.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass


####################    </generated_from:socket.hpp>    ####################


####################    <generated_from:tcp_socket.hpp>    ####################





class TcpSocket:
    """*
     *   @brief Class for managing sending and receiving data using TCP/IP. Can be
     *          used to create client or server sockets.
     *
     * \section tcp_ex1 TCP Client Example
     * \snippet socket_example.cpp TCP Client example
     * \section tcp_ex2 TCP Server Example
     * \snippet socket_example.cpp TCP Server example
     *
     * \section tcp_ex3 TCP Client Response Example
     * \snippet socket_example.cpp TCP Client Response example
     * \section tcp_ex4 TCP Server Response Example
     * \snippet socket_example.cpp TCP Server Response example
     *

    """
    class Config:
        """*
           * @brief Config struct for the TCP socket.

        """
        log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)  #*< Verbosity level for the TCP socket logger.
        def __init__(
            self,
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class ConnectConfig:
        """*
           * @brief Config struct for connecting to a remote TCP server.

        """
        ip_address: str                                                        #*< Address to send data to.
        port: int                                                              #*< Port number to send data to.
        def __init__(self, ip_address: str = "", port: int = int()) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class TransmitConfig:
        """*
           * @brief Config struct for sending data to a remote TCP socket.
           * @note This is only used when waiting for a response from the remote.

        """
        wait_for_response: bool = False                                        #*< Whether to wait for a response from the remote or not.
        response_size: int = 0                                                 #*< If waiting for a response, this is the maximum size response we will receive.
        on_response_callback: Socket.response_callback_fn = None               #*< If waiting for a
                           response, this is an optional handler which is provided the response data.
        response_timeout: std.chrono.duration[float] = std.chrono.duration<float>(
                0.5)                                                           #*< If waiting for a response, this is the maximum timeout to wait.

        @staticmethod
        def default() -> TcpSocket.TransmitConfig:
            pass
        def __init__(
            self,
            wait_for_response: bool = False,
            response_size: int = 0,
            on_response_callback: Socket.response_callback_fn = None,
            response_timeout: std.chrono.duration[float] = std.chrono.duration<float>(
                    0.5)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    def reinit(self) -> None:
        """*
           * @brief Reinitialize the socket, cleaning it up if first it is already
           *        initalized.

        """
        pass

    def close(self) -> None:
        """*
           * @brief Close the socket.

        """
        pass

    def is_connected(self) -> bool:
        """*
           * @brief Check if the socket is connected to a remote endpoint.
           * @return True if the socket is connected to a remote endpoint.

        """
        pass

    def connect(self, connect_config: TcpSocket.ConnectConfig) -> bool:
        """*
           * @brief Open a connection to the remote TCP server.
           * @param connect_config ConnectConfig struct describing the server endpoint.
           * @return True if the client successfully connected to the server.

        """
        pass

    def get_remote_info(self) -> Socket.Info:
        """*
           * @brief Get the remote endpoint info.
           * @return The remote endpoint info.

        """
        pass

    @overload
    def transmit(
        self,
        data: List[int],
        transmit_config: TcpSocket.TransmitConfig = TcpSocket.TransmitConfig.Default()
        ) -> bool:
        """*
           * @brief Send data to the endpoint already connected to by TcpSocket::connect.
           *        Can be configured to block waiting for a response from the remote.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data vector of bytes to send to the remote endpoint.
           * @param transmit_config TransmitConfig struct indicating whether to wait for a
           *        response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def transmit(
        self,
        data: List[char],
        transmit_config: TcpSocket.TransmitConfig = TcpSocket.TransmitConfig.Default()
        ) -> bool:
        """*
           * @brief Send data to the endpoint already connected to by TcpSocket::connect.
           *        Can be configured to block waiting for a response from the remote.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data vector of bytes to send to the remote endpoint.
           * @param transmit_config TransmitConfig struct indicating whether to wait for a
           *        response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def transmit(
        self,
        data: std.string_view,
        transmit_config: TcpSocket.TransmitConfig = TcpSocket.TransmitConfig.Default()
        ) -> bool:
        """*
           * @brief Send data to the endpoint already connected to by TcpSocket::connect.
           *        Can be configured to block waiting for a response from the remote.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data string view of bytes to send to the remote endpoint.
           * @param transmit_config TransmitConfig struct indicating whether to wait for a
           *        response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def transmit(
        self,
        data: std.span[ int],
        transmit_config: TcpSocket.TransmitConfig = TcpSocket.TransmitConfig.Default()
        ) -> bool:
        """*
           * @brief Send data to the endpoint already connected to by TcpSocket::connect.
           *        Can be configured to block waiting for a response from the remote.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data span of bytes to send to the remote endpoint.
           * @param transmit_config TransmitConfig struct indicating whether to wait for a
           *        response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def receive(self, data: List[int], max_num_bytes: int) -> bool:
        """*
           * @brief Call read on the socket, assuming it has already been configured
           *        appropriately.
           *
           * @param data Vector of bytes of received data.
           * @param max_num_bytes Maximum number of bytes to receive.
           * @return True if successfully received, False otherwise.

        """
        pass

    @overload
    def receive(self, data: int, max_num_bytes: int) -> int:
        """*
           * @brief Call read on the socket, assuming it has already been configured
           *        appropriately.
           * @note This function will block until max_num_bytes are received or the
           *       receive timeout is reached.
           * @note The data pointed to by data must be at least max_num_bytes in size.
           * @param data Pointer to buffer to receive data.
           * @param max_num_bytes Maximum number of bytes to receive.
           * @return Number of bytes received.

        """
        pass

    def bind(self, port: int) -> bool:
        """*
           * @brief Bind the socket as a server on \p port.
           * @param port The port to which to bind the socket.
           * @return True if the socket was bound.

        """
        pass

    def listen(self, max_pending_connections: int) -> bool:
        """*
           * @brief Listen for incoming client connections.
           * @note Must be called after bind and before accept.
           * @see bind
           * @see accept
           * @param max_pending_connections Max number of allowed pending connections.
           * @return True if socket was able to start listening.

        """
        pass

    def accept(self) -> TcpSocket:
        """*
           * @brief Accept an incoming connection.
           * @note Blocks until a connection is accepted.
           * @note Must be called after listen.
           * @note This function will block until a connection is accepted.
           * @return A unique pointer to a TcpClientSession if a connection was
           *         accepted, None otherwise.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:tcp_socket.hpp>    ####################


####################    <generated_from:udp_socket.hpp>    ####################




# TODO: should this class _contain_ a socket or just create sockets within each
#       call?

class UdpSocket:
    """*
     *   @brief Class for managing sending and receiving data using UDP/IP. Can be
     *          used to create client or server sockets.
     *
     *   See
     *   https://github.com/espressif/esp-idf/tree/master/examples/protocols/sockets/udp_multicast
     *   for more information on udp multicast sockets.
     *
     * \section udp_ex1 UDP Client Example
     * \snippet socket_example.cpp UDP Client example
     * \section udp_ex2 UDP Server Example
     * \snippet socket_example.cpp UDP Server example
     *
     * \section udp_ex3 UDP Client Response Example
     * \snippet socket_example.cpp UDP Client Response example
     * \section udp_ex4 UDP Server Response Example
     * \snippet socket_example.cpp UDP Server Response example
     *
     * \section udp_ex5 UDP Multicast Client Example
     * \snippet socket_example.cpp UDP Multicast Client example
     * \section udp_ex6 UDP Multicast Server Example
     * \snippet socket_example.cpp UDP Multicast Server example
     *

    """
    class ReceiveConfig:
        port: int                                                                              #*< Port number to bind to / receive from.
        buffer_size: int                                                                       #*< Max size of data we can receive at one time.
        is_multicast_endpoint: bool = bool(False)                                              #*< Whether this should be a multicast endpoint.
        multicast_group: str = str("")                                                         #*< If this is a multicast endpoint, this is the group it belongs to.
        on_receive_callback: Socket.receive_callback_fn = Socket.receive_callback_fn(None)     #*< Function containing business logic to handle data received.
        def __init__(
            self,
            port: int = int(),
            buffer_size: int = int(),
            is_multicast_endpoint: bool = bool(False),
            multicast_group: str = str(""),
            on_receive_callback: Socket.receive_callback_fn = Socket.receive_callback_fn(None)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class SendConfig:
        ip_address: str                                                                        #*< Address to send data to.
        port: int                                                                              #*< Port number to send data to.
        is_multicast_endpoint: bool = bool(False)                                              #*< Whether this should be a multicast endpoint.
        wait_for_response: bool = bool(False)                                                  #*< Whether to wait for a response from the remote or not.
        response_size: int = int(0)                                                            #*< If waiting for a response, this is the maximum size response we will receive.
        on_response_callback: Socket.response_callback_fn = Socket.response_callback_fn(None)  #*< If waiting for a response, this is an optional handler which is provided the
                             response data.
        response_timeout: std.chrono.duration[float] = std.chrono.duration<float>(
                0.5)                                                                           #*< If waiting for a response, this is the maximum timeout to wait.
        def __init__(
            self,
            ip_address: str = "",
            port: int = int(),
            is_multicast_endpoint: bool = bool(False),
            wait_for_response: bool = bool(False),
            response_size: int = int(0),
            on_response_callback: Socket.response_callback_fn = Socket.response_callback_fn(None),
            response_timeout: std.chrono.duration[float] = std.chrono.duration<float>(
                    0.5)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class Config:
        log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)                  #*< Verbosity level for the UDP socket logger.
        def __init__(
            self,
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    @overload
    def send(self, data: List[int], send_config: UdpSocket.SendConfig) -> bool:
        """*
           * @brief Send data to the endpoint specified by the send_config.
           *        Can be configured to multicast (within send_config) and can be
           *        configured to block waiting for a response from the remote.
           *
           *        @note in the case of multicast, it will block only until the first
           *              response.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data vector of bytes to send to the remote endpoint.
           * @param send_config SendConfig struct indicating where to send and whether
           *        to wait for a response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def send(self, data: std.string_view, send_config: UdpSocket.SendConfig) -> bool:
        """*
           * @brief Send data to the endpoint specified by the send_config.
           *        Can be configured to multicast (within send_config) and can be
           *        configured to block waiting for a response from the remote.
           *
           *        @note in the case of multicast, it will block only until the first
           *              response.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data String view of bytes to send to the remote endpoint.
           * @param send_config SendConfig struct indicating where to send and whether
           *        to wait for a response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    @overload
    def send(self, data: std.span[ int], send_config: UdpSocket.SendConfig) -> bool:
        """*
           * @brief Send data to the endpoint specified by the send_config.
           *        Can be configured to multicast (within send_config) and can be
           *        configured to block waiting for a response from the remote.
           *
           *        @note in the case of multicast, it will block only until the first
           *              response.
           *
           *        If response is requested, a callback can be provided in
           *        send_config which will be provided the response data for
           *        processing.
           * @param data std::span of bytes to send to the remote endpoint.
           * @param send_config SendConfig struct indicating where to send and whether
           *        to wait for a response.
           * @return True if the data was sent, False otherwise.

        """
        pass

    def receive(
        self,
        max_num_bytes: int,
        data: List[int],
        remote_info: Socket.Info
        ) -> bool:
        """*
           * @brief Call recvfrom on the socket, assuming it has already been
           *        configured appropriately.
           *
           * @param max_num_bytes Maximum number of bytes to receive.
           * @param data Vector of bytes of received data.
           * @param remote_info Socket::Info containing the sender's information. This
           *        will be populated with the information about the sender.
           * @return True if successfully received, False otherwise.

        """
        pass

    def start_receiving(
        self,
        task_config: Task.BaseConfig,
        receive_config: UdpSocket.ReceiveConfig
        ) -> bool:
        """*
           * @brief Configure a server socket and start a thread to continuously
           *        receive and handle data coming in on that socket.
           *
           * @param task_config Task::BaseConfig struct for configuring the receive task.
           * @param receive_config ReceiveConfig struct with socket and callback info.
           * @return True if the socket was created and task was started, False otherwise.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:udp_socket.hpp>    ####################


####################    <generated_from:task.hpp>    ####################





class Task:
    """*
     * @brief Task provides an abstraction over std::thread which optionally
     * includes memory / priority configuration on ESP systems. It allows users to
     * easily stop the task, and will automatically stop itself if destroyed.
     *
     * There is also a utility function which can be used to get the info for the
     * task of the current context, or for a provided Task object.
     *
     * There is also a helper function to run a lambda on a specific core, which can
     * be used to run a specific function on a specific core, as you might want to
     * do when registering an interrupt driver on a specific core.
     *
     * \section task_ex1 Basic Task Example
     * \snippet task_example.cpp Task example
     * \section task_ex2 Task Watchdog Example
     * \snippet task_example.cpp task watchdog example
     * \section task_ex3 Many Task Example
     * \snippet task_example.cpp ManyTask example
     * \section task_ex4 Long Running Task Example
     * \snippet task_example.cpp LongRunningTask example
     * \section task_ex5 Long Running Task Notified Example (Recommended)
     * \snippet task_example.cpp LongRunningTaskNotified example
     * \section task_ex6 Task Info Example
     * \snippet task_example.cpp Task Info example
     * \section task_ex7 Task Request Stop Example
     * \snippet task_example.cpp Task Request Stop example
     *
     * \section run_on_core_ex1 Run on Core Example
     * \snippet task_example.cpp run on core example
     * \section run_on_core_ex2 Run on Core (Non-Blocking) Example
     * \snippet task_example.cpp run on core nonblocking example

    """





    class BaseConfig:
        """*
           * @brief Base configuration struct for the Task.
           * @note This is designed to be used as a configuration struct in other classes
           *       that may have a Task as a member.

        """
        name: str                                                              #*< Name of the task
        stack_size_bytes: int = int(4096)                                      #*< Stack Size (B) allocated to the task.
        priority: int = int(0)                                                 #*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(-1)                                                 #*< Core ID of the task, -1 means it is not pinned to any core.
        def __init__(
            self,
            name: str = "",
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class Config:
        """*
           * @brief Configuration struct for the Task.
           *        Can be initialized with any of the supported callback function
           *        signatures.

        """
        callback: Task.callback_variant                                        #*< Callback function
        task_config: Task.BaseConfig                                           #*< Base configuration for the task.
        log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)  #*< Log verbosity for the task.
        def __init__(
            self,
            callback: Task.callback_variant = Task.callback_variant(),
            task_config: Task.BaseConfig = Task.BaseConfig(),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass






    def start(self) -> bool:
        """*
           * @brief Start executing the task.
           *
           * @return True if the task started, False if it was already started.

        """
        pass

    def stop(self) -> bool:
        """*
           * @brief Stop the task execution.
           * @details This will request the task to stop, notify the condition variable,
           *          and (if this calling context is not the task context) join the
           *          thread.
           * @return True if the task stopped, False if it was not started / already
           *         stopped.

        """
        pass

    def is_started(self) -> bool:
        """*
           * @brief Has the task been started or not?
           *
           * @return True if the task is started / running, False otherwise.

        """
        pass

    def is_running(self) -> bool:
        """*
           * @brief Is the task running?
           *
           * @return True if the task is running, False otherwise.

        """
        pass


    def get_id(self) -> task_id_t:
        """*
           * @brief Get the ID for this Task's thread / task context.
           * @return ID for this Task's thread / task context.

        """
        pass

    @staticmethod
    def get_current_id() -> task_id_t:
        """*
           * @brief Get the ID for the current thread / task context.
           * @return ID for the current thread / task context.

        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass


####################    </generated_from:task.hpp>    ####################


####################    <generated_from:timer.hpp>    ####################



class Timer:
    """/ @brief A timer that can be used to schedule tasks to run at a later time.
    / @details A timer can be used to schedule a task to run at a later time.
    /          The timer will run in the background and will call the task when
    /          the time is up. The timer can be canceled at any time. A timer
    /          can be configured to run once or to repeat.
    /
    /          The timer uses a task to run in the background. The task will
    /          sleep until the timer is ready to run. When the timer is ready to
    /          run, the task will call the callback function. The callback
    /          function can return True to cancel the timer or False to keep the
    /          timer running. If the timer is configured to repeat, then the
    /          callback function will be called again after the period has
    /          elapsed. If the timer is configured to run once, then the
    /          callback function will only be called once.
    /
    /          The timer can be configured to start automatically when it is
    /          constructed. If the timer is not configured to start
    /          automatically, then the timer can be started by calling start().
    /          The timer can be canceled at any time by calling cancel().
    /
    / @note The timer uses a task to run in the background, so the timer
    /       callback function will be called in the context of the task. The
    /       timer callback function should not block for a long time because it
    /       will block the task. If the timer callback function blocks for a
    /       long time, then the timer will not be able to keep up with the
    /       period.
    /
    / \section timer_ex1 Timer Example 1
    / \snippet timer_example.cpp timer example
    / \section timer_ex2 Timer Watchdog Example
    / \snippet timer_example.cpp timer watchdog example
    / \section timer_ex3 Timer Delay Example
    / \snippet timer_example.cpp timer delay example
    / \section timer_ex4 Oneshot Timer Example
    / \snippet timer_example.cpp timer oneshot example
    / \section timer_ex5 Timer Cancel Itself Example
    / \snippet timer_example.cpp timer cancel itself example
    / \section timer_ex6 Oneshot Timer Cancel Itself Then Start again with Delay Example
    / \snippet timer_example.cpp timer oneshot restart example
    / \section timer_ex7 Timer Update Period Example
    / \snippet timer_example.cpp timer update period example
    / \section timer_ex8 Timer AdvancedConfig Example
    / \snippet timer_example.cpp timer advanced config example
    """

    class Config:
        """/ @brief The configuration for the timer."""
        name: std.string_view                                #/< The name of the timer.
        period: std.chrono.duration[float]                   #/< The period of the timer. If 0, the timer callback will only be called once.
        delay: std.chrono.duration[float] = std.chrono.duration<float>(
                0)                                           #/< The delay before the first execution of the timer callback after start() is called.
        callback: Timer.callback_fn                          #/< The callback function to call when the timer expires.
        auto_start: bool = bool(True)                        #/< If True, the timer will start automatically when constructed.
        stack_size_bytes: int = int(4096)                    #/< The stack size of the task that runs the timer.
        priority: int = int(0)                               #/< Priority of the timer, 0 is lowest priority on ESP / FreeRTOS.
        core_id: int = int(-1)                               #/< Core ID of the timer, -1 means it is not pinned to any core.
        log_level: Logger.Verbosity = Logger.Verbosity.warn  #/< The log level for the timer.
        def __init__(
            self,
            name: std.string_view = std.string_view(),
            period: std.chrono.duration[float] = std.chrono.duration<float>(),
            delay: std.chrono.duration[float] = std.chrono.duration<float>(
                    0),
            callback: Timer.callback_fn = Timer.callback_fn(),
            auto_start: bool = bool(True),
            stack_size_bytes: int = int(4096),
            priority: int = int(0),
            core_id: int = int(-1),
            log_level: Logger.Verbosity = Logger.Verbosity.warn
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class AdvancedConfig:
        """/ @brief Advanced configuration for the timer."""
        period: std.chrono.duration[float]                   #/< The period of the timer. If 0, the timer callback will only be called once.
        delay: std.chrono.duration[float] = std.chrono.duration<float>(
                0)                                           #/< The delay before the first execution of the timer callback after start() is called.
        callback: Timer.callback_fn                          #/< The callback function to call when the timer expires.
        auto_start: bool = bool(True)                        #/< If True, the timer will start automatically when constructed.
        task_config: Task.BaseConfig                         #/< The task configuration for the timer.
        log_level: Logger.Verbosity = Logger.Verbosity.warn  #/< The log level for the timer.
        def __init__(
            self,
            period: std.chrono.duration[float] = std.chrono.duration<float>(),
            delay: std.chrono.duration[float] = std.chrono.duration<float>(
                    0),
            callback: Timer.callback_fn = Timer.callback_fn(),
            auto_start: bool = bool(True),
            task_config: Task.BaseConfig = Task.BaseConfig(),
            log_level: Logger.Verbosity = Logger.Verbosity.warn
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass




    @overload
    def start(self) -> None:
        """/ @brief Start the timer.
        / @details Starts the timer. Does nothing if the timer is already running.
        """
        pass

    @overload
    def start(self, delay: std.chrono.duration[float]) -> None:
        """/ @brief Start the timer with a delay.
        / @details Starts the timer with a delay. If the timer is already running,
        /          this will cancel the timer and start it again with the new
        /          delay. If the timer is not running, this will start the timer
        /          with the delay. Overwrites any previous delay that might have
        /          been set.
        / @param delay The delay before the first execution of the timer callback.
        """
        pass

    def stop(self) -> None:
        """/ @brief Stop the timer, same as cancel().
        / @details Stops the timer, same as cancel().
        """
        pass

    def cancel(self) -> None:
        """/ @brief Cancel the timer.
        / @details Cancels the timer.
        """
        pass


    def set_period(self, period: std.chrono.duration[float]) -> None:
        """/ @brief Set the period of the timer.
        / @details Sets the period of the timer.
        / @param period The period of the timer.
        / @note If the period is 0, the timer will run once.
        / @note If the period is negative, the period will not be set / updated.
        / @note If the timer is running, the period will be updated after the
        /       current period has elapsed.
        """
        pass

    def is_running(self) -> bool:
        """/ @brief Check if the timer is running.
        / @details Checks if the timer is running.
        / @return True if the timer is running, False otherwise.
        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:timer.hpp>    ####################


####################    <generated_from:joystick.hpp>    ####################



class Joystick:
    """*
     *  @brief 2-axis Joystick with axis mapping / calibration.
     *
     * \section joystick_ex1 Basic Circular and Rectangular Joystick Example
     * \snippet joystick_example.cpp circular joystick example
     * \section joystick_ex2 ADC Joystick Example
     * \snippet joystick_example.cpp adc joystick example

    """
    class Type(enum.IntEnum):
        """*
           * @brief Type of the joystick.
           * @note When using a Type::CIRCULAR joystick, it's recommended to set the
           *       individual x/y calibration deadzones to be 0 and to only use the
           *       deadzone_radius field to set the deadzone around the center.

        """
        rectangular = enum.auto()                                              # (= 0)  #/< The default type of joystick. Uses the rangemappers for
        #/  each axis (to convert raw values from input range to be
        #/  [-1,1]) independently which results in x/y deadzones and
        #/  output that are rectangular.
        circular = enum.auto()                                                 # (= 1)  #/< The joystick is configured to have a circular output. This
        #/  means that the x/y < deadzones are circular around the
        #/  input and range and the output is clamped to be on or
        #/  within the unit circle.


    class Config:
        """*
           *  @brief Configuration structure for the joystick.

        """
        x_calibration: FloatRangeMapper.Config                                 #*< Configuration for the x axis.
        y_calibration: FloatRangeMapper.Config                                 #*< Configuration for the y axis.
        type: Joystick.Type = Joystick.Type(Joystick.Type.rectangular)         #*< The type of the joystick. See
                                                         Type enum for more information.
        center_deadzone_radius: float = float(0)                               #*< The radius of the unit circle's deadzone [0, 1.0] around the center, only used
                when the joystick is configured as Type::CIRCULAR.
        range_deadzone: float = float(0)                                       #*< The deadzone around the edge of the unit circle, only used when
                                  the joystick is configured as Type::CIRCULAR. This scales the output so
                                  that the output appears to have magnitude 1 (meaning it appears to be on
                                  the edge of the unit circle) when the joystick value magnitude is within
                                  the range [1-range_deadzone, 1].
        get_values: Joystick.get_values_fn = Joystick.get_values_fn(None)      #*< Function to retrieve the latest
                                                  unmapped joystick values. Required if
                                                  you want to use update(), unused if
                                                  you call update(float raw_x, float
                                                  raw_y).
        log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)  #*< Verbosity for the Joystick logger_.
        def __init__(
            self,
            x_calibration: FloatRangeMapper.Config = FloatRangeMapper.Config(),
            y_calibration: FloatRangeMapper.Config = FloatRangeMapper.Config(),
            type: Joystick.Type = Joystick.Type(Joystick.Type.rectangular),
            center_deadzone_radius: float = float(0),
            range_deadzone: float = float(0),
            get_values: Joystick.get_values_fn = Joystick.get_values_fn(None),
            log_level: Logger.Verbosity = Logger.Verbosity(Logger.Verbosity.warn)
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass


    def set_type(
        self,
        type: Joystick.Type,
        radius: float = 0,
        range_deadzone: float = 0
        ) -> None:
        """*
           *  @brief Set the type of the joystick.
           *  @param type The Type of the joystick.
           *  @param radius Optional radius parameter used when \p type is
           *         Type::CIRCULAR. When the magnitude of the joystick's mapped
           *         position vector is less than this value, the vector is set to
           *         (0,0).
           *  @param range_deadzone Optional deadzone around the edge of the unit circle
           *         when \p type is Type::CIRCULAR. This scales the output so that the
           *         output appears to have magnitude 1 (meaning it appears to be on the
           *         edge of the unit circle) if the magnitude of the mapped position
           *         vector is greater than 1-range_deadzone. Example: if the range
           *         deadzone is 0.1, then the output will be scaled so that the
           *         magnitude of the output is 1 if the magnitude of the mapped
           *         position vector is greater than 0.9.
           *  @note If the Joystick is Type::CIRCULAR, the actual calibrations that are
           *        saved into the joystick will have 0 deadzone around the center value
           *        and range values, so that center and range deadzones are actually
           *        applied on the vector value instead of on the individual axes
           *        independently.
           *  @sa set_center_deadzone_radius
           *  @sa set_range_deadzone
           *  @sa set_calibration

        """
        pass

    def type(self) -> Joystick.Type:
        """*
           * @brief Get the type of the joystick.
           * @return The Type of the joystick.

        """
        pass

    def set_center_deadzone_radius(self, radius: float) -> None:
        """*
           * @brief Sets the center deadzone radius.
           * @note Radius is only applied when \p deadzone is Deadzone::CIRCULAR.
           * @param radius Optional radius parameter used when \p deadzone is
           *        Deadzone::CIRCULAR. When the magnitude of the joystick's mapped
           *        position vector is less than this value, the vector is set to
           *        (0,0).

        """
        pass

    def center_deadzone_radius(self) -> float:
        """*
           * @brief Get the center deadzone radius.
           * @return The center deadzone radius.

        """
        pass

    def set_range_deadzone(self, range_deadzone: float) -> None:
        """*
           * @brief Sets the range deadzone.
           * @note Range deadzone is only applied when \p deadzone is Deadzone::CIRCULAR.
           * @param range_deadzone Optional deadzone around the edge of the unit circle
           *        when \p deadzone is Deadzone::CIRCULAR. This scales the output so
           *        that the output appears to have magnitude 1 (meaning it appears to
           *        be on the edge of the unit circle) if the magnitude of the mapped
           *        position vector is greater than 1-range_deadzone. Example: if the
           *        range deadzone is 0.1, then the output will be scaled so that the
           *        magnitude of the output is 1 if the magnitude of the mapped position
           *        vector is greater than 0.9.

        """
        pass

    def range_deadzone(self) -> float:
        """*
           * @brief Get the range deadzone.
           * @return The range deadzone.

        """
        pass

    def set_calibration(
        self,
        x_calibration: FloatRangeMapper.Config,
        y_calibration: FloatRangeMapper.Config,
        center_deadzone_radius: float = 0,
        range_deadzone: float = 0
        ) -> None:
        """*
           * @brief Update the x and y axis mapping.
           * @param x_calibration New x-axis range mapping configuration to use.
           * @param y_calibration New y-axis range mapping configuration to use.
           * @param center_deadzone_radius The radius of the unit circle's deadzone [0,
           *        1.0] around the center, only used when the joystick is configured
           *        as Type::CIRCULAR.
           *  @param range_deadzone Optional deadzone around the edge of the unit circle
           *         when \p type is Type::CIRCULAR. This scales the output so that the
           *         output appears to have magnitude 1 (meaning it appears to be on the
           *         edge of the unit circle) if the magnitude of the mapped position
           *         vector is greater than 1-range_deadzone. Example: if the range
           *         deadzone is 0.1, then the output will be scaled so that the
           *         magnitude of the output is 1 if the magnitude of the mapped
           *         position vector is greater than 0.9.
           * @note If the Joystick is Type::CIRCULAR, the actual calibrations that are
           *       saved into the joystick will have 0 deadzone around the center and range values,
           *       so that center and range deadzones are actually applied on the vector value.
           * @sa set_center_deadzone_radius
           * @sa set_range_deadzone

        """
        pass

    @overload
    def update(self) -> None:
        """*
           * @brief Read the raw values and use the calibration data to update the
           *        position.
           * @note Requires that the get_values_ function is set.

        """
        pass

    @overload
    def update(self, raw_x: float, raw_y: float) -> None:
        """*
           * @brief Update the joystick's position using the provided raw x and y
           *        values.
           * @param raw_x The raw x-axis value.
           * @param raw_y The raw y-axis value.
           * @note This function is useful when you have the raw values and don't want
           *       to use the get_values_ function.

        """
        pass

    def x(self) -> float:
        """*
           * @brief Get the most recently updated x axis calibrated position.
           * @return The most recent x-axis position (from when update() was last
           *         called).

        """
        pass

    def y(self) -> float:
        """*
           * @brief Get the most recently updated y axis calibrated position.
           * @return The most recent y-axis position (from when update() was last
           *         called).

        """
        pass

    def position(self) -> Vector2f:
        """*
           * @brief Get the most recently updated calibrated position.
           * @return The most recent position (from when update() was last called).
           * @note The returned reference is valid as long as the Joystick object is alive.

        """
        pass

    def raw(self) -> Vector2f:
        """*
           * @brief Get the most recently updated raw / uncalibrated readings. This
           *        function is useful for externally performing a calibration routine
           *        and creating updated calibration / mapper configuration
           *        structures.
           * @return The most recent raw measurements (from when update() was last
           *         called).
           * @note The returned reference is valid as long as the Joystick object is alive.

        """
        pass


    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass


####################    </generated_from:joystick.hpp>    ####################


####################    <generated_from:rtp_jpeg_packet.hpp>    ####################



class RtpJpegPacket:
    """/ RTP packet for JPEG video.
    / The RTP payload for JPEG is defined in RFC 2435.
    """
    @overload
    def __init__(self, data: std.span[ int]) -> None:
        """/ Construct an RTP packet from a buffer.
        / @param data The buffer containing the RTP packet.
        """
        pass

    @overload
    def __init__(
        self,
        type_specific: int,
        frag_type: int,
        q: int,
        width: int,
        height: int,
        q0: std.span[ int],
        q1: std.span[ int],
        scan_data: std.span[ int]
        ) -> None:
        """/ Construct an RTP packet from fields
        / @details This will construct a packet with quantization tables, so it
        /          can only be used for the first packet in a frame.
        / @param type_specific The type-specific field.
        / @param frag_type The fragment type field.
        / @param q The q field.
        / @param width The width field.
        / @param height The height field.
        / @param q0 The first quantization table.
        / @param q1 The second quantization table.
        / @param scan_data The scan data.
        """
        pass

    @overload
    def __init__(
        self,
        type_specific: int,
        offset: int,
        frag_type: int,
        q: int,
        width: int,
        height: int,
        scan_data: std.span[ int]
        ) -> None:
        """/ Construct an RTP packet from fields
        / @details This will construct a packet without quantization tables, so it
        /          cannot be used for the first packet in a frame.
        / @param type_specific The type-specific field.
        / @param offset The offset field.
        / @param frag_type The fragment type field.
        / @param q The q field.
        / @param width The width field.
        / @param height The height field.
        / @param scan_data The scan data.
        """
        pass


    def get_type_specific(self) -> int:
        """/ Get the type-specific field.
        / @return The type-specific field.
        """
        pass

    def get_offset(self) -> int:
        """/ Get the offset field.
        / @return The offset field.
        """
        pass

    def get_q(self) -> int:
        """/ Get the fragment type field.
        / @return The fragment type field.
        """
        pass

    def get_width(self) -> int:
        """/ Get the fragment type field.
        / @return The fragment type field.
        """
        pass

    def get_height(self) -> int:
        """/ Get the fragment type field.
        / @return The fragment type field.
        """
        pass

    def get_mjpeg_header(self) -> std.span[ int]:
        """/ Get the mjepg header.
        / @return The mjepg header.
        """
        pass

    def has_q_tables(self) -> bool:
        """/ Get whether the packet contains quantization tables.
        / @note The quantization tables are optional. If they are present, the
        / number of quantization tables is always 2.
        / @note This check is based on the value of the q field. If the q field
        /       is 128-256, the packet contains quantization tables.
        / @return Whether the packet contains quantization tables.
        """
        pass

    def get_num_q_tables(self) -> int:
        """/ Get the number of quantization tables.
        / @note The quantization tables are optional. If they are present, the
        / number of quantization tables is always 2.
        / @note Only the first packet in a frame contains quantization tables.
        / @return The number of quantization tables.
        """
        pass

    def get_q_table(self, index: int) -> std.span[ int]:
        """/ Get the quantization table at the specified index.
        / @param index The index of the quantization table.
        / @return The quantization table at the specified index.
        """
        pass

    def set_q_table(self, index: int, q_table: std.span[ int]) -> None:
        """/ Set the quantization table at the specified index.
        / @param index The index of the quantization table.
        / @param q_table The quantization table to set.
        / @note This will not change the size of the packet. If the index is out of
        /       bounds, the quantization table will not be set.
        """
        pass

    def get_jpeg_data(self) -> std.span[ int]:
        """/ Get the JPEG data.
        / The jpeg data is the payload minus the mjpeg header and quantization
        / tables.
        / @return The JPEG data.
        """
        pass


####################    </generated_from:rtp_jpeg_packet.hpp>    ####################


####################    <generated_from:jpeg_frame.hpp>    ####################



class JpegFrame:
    """/ A class that represents a complete JPEG frame.
    /
    / This class is used to collect the JPEG scans that are received in RTP
    / packets and to serialize them into a complete JPEG frame.
    """
    @overload
    def __init__(self, packet: RtpJpegPacket) -> None:
        """/ Construct a JpegFrame from a RtpJpegPacket.
        /
        / This constructor will parse the header of the packet and add the JPEG
        / data to the frame.
        /
        / @param packet The packet to parse.
        """
        pass

    @overload
    def __init__(self, data: List[int]) -> None:
        """/ Construct a JpegFrame from a vector of jpeg data.
        / @param data The vector containing the jpeg data.
        / @note The vector must contain the complete JPEG data, including the JPEG
        /       header and EOI marker.
        """
        pass

    @overload
    def __init__(self, data: std.span[ int]) -> None:
        """/ Construct a JpegFrame from a span of jpeg data.
        / @param data The span containing the jpeg data.
        / @note The span must contain the complete JPEG data, including the JPEG
        /       header and EOI marker.
        """
        pass

    @overload
    def __init__(self, data: int, size: int) -> None:
        """/ Construct a JpegFrame from buffer of jpeg data
        / @param data The buffer containing the jpeg data.
        / @param size The size of the buffer.
        """
        pass

    def get_header(self) -> JpegHeader:
        """/ Get a reference to the header.
        / @return A reference to the header.
        """
        pass

    def get_width(self) -> int:
        """/ Get the width of the frame.
        / @return The width of the frame.
        """
        pass

    def get_height(self) -> int:
        """/ Get the height of the frame.
        / @return The height of the frame.
        """
        pass

    def is_complete(self) -> bool:
        """/ Check if the frame is complete.
        / @return True if the frame is complete, False otherwise.
        """
        pass

    def append(self, packet: RtpJpegPacket) -> None:
        """/ Append a RtpJpegPacket to the frame.
        / This will add the JPEG data to the frame.
        / @param packet The packet containing the scan to append.
        """
        pass

    @overload
    def add_scan(self, packet: RtpJpegPacket) -> None:
        """/ Append a JPEG scan to the frame.
        / This will add the JPEG data to the frame.
        / @note If the packet contains the EOI marker, the frame will be
        /       finalized, and no further scans can be added.
        / @param packet The packet containing the scan to append.
        """
        pass

    def get_data(self) -> std.span[ int]:
        """/ Get the serialized data.
        / This will return the serialized data.
        / @return The serialized data.
        """
        pass

    def get_scan_data(self) -> std.span[ int]:
        """/ Get the scan data.
        / This will return the scan data.
        / @return The scan data.
        """
        pass


####################    </generated_from:jpeg_frame.hpp>    ####################


####################    <generated_from:jpeg_header.hpp>    ####################


class JpegHeader:
    """/ A class to generate a JPEG header for a given image size and quantization tables.
    / The header is generated once and then cached for future use.
    / The header is generated according to the JPEG standard and is compatible with
    / the ESP32 camera driver.
    """
    @overload
    def __init__(
        self,
        width: int,
        height: int,
        q0_table: std.span[ int],
        q1_table: std.span[ int]
        ) -> None:
        """/ Create a JPEG header for a given image size and quantization tables.
        / @param width The image width in pixels.
        / @param height The image height in pixels.
        / @param q0_table The quantization table for the Y channel.
        / @param q1_table The quantization table for the Cb and Cr channels.
        """
        pass

    @overload
    def __init__(self, data: std.span[ int]) -> None:
        """/ Create a JPEG header from a given JPEG header data."""
        pass


    def get_width(self) -> int:
        """/ Get the image width.
        / @return The image width in pixels.
        """
        pass

    def get_height(self) -> int:
        """/ Get the image height.
        / @return The image height in pixels.
        """
        pass

    def size(self) -> int:
        """/ Get the size of the JPEG header data.
        / @return The size of the JPEG header data in bytes.
        / @note This is the size of the serialized JPEG header, not the image size.
        """
        pass

    def get_data(self) -> std.span[ int]:
        """/ Get the JPEG header data.
        / @return The JPEG header data.
        """
        pass

    def get_quantization_table(self, index: int) -> std.span[ int]:
        """/ Get the Quantization table at the index.
        / @param index The index of the quantization table.
        / @return The quantization table.
        """
        pass


####################    </generated_from:jpeg_header.hpp>    ####################


####################    <generated_from:rtcp_packet.hpp>    ####################


class RtcpPacket:
    """/ @brief A class to represent a RTCP packet
    / @details This class is used to represent a RTCP packet.
    /          It is used as a base class for all RTCP packet types.
    / @note At the moment, this class is not used.
    """
    def __init__(self) -> None:
        """/ @brief Constructor, default"""
        pass


    def get_data(self) -> std.string_view:
        """/ @brief Get the buffer of the packet
        / @return The buffer of the packet
        """
        pass


####################    </generated_from:rtcp_packet.hpp>    ####################


####################    <generated_from:rtp_packet.hpp>    ####################


class RtpPacket:
    """/ RtpPacket is a class to parse RTP packet.
    / It can be used to parse and serialize RTP packets.
    / The RTP header fields are stored in the class and can be modified.
    / The payload is stored in the packet_ vector and can be modified.
    """
    @overload
    def __init__(self) -> None:
        """/ Construct an empty RtpPacket.
        / The packet_ vector is empty and the header fields are set to 0.
        """
        pass

    @overload
    def __init__(self, payload_size: int) -> None:
        """/ Construct an RtpPacket with a payload of size payload_size.
        / The packet_ vector is resized to RTP_HEADER_SIZE + payload_size.
        """
        pass

    @overload
    def __init__(self, data: std.span[ int]) -> None:
        """/ Construct an RtpPacket from a span of bytes.
        / Stores the bytes in the packet_ vector and parses the header.
        / @param data The span of bytes to parse.
        """
        pass


    # -----------------------------------------------------------------
    # Getters for the RTP header fields.
    # -----------------------------------------------------------------

    def get_version(self) -> int:
        """/ Get the RTP version.
        / @return The RTP version.
        """
        pass

    def get_padding(self) -> bool:
        """/ Get the padding flag.
        / @return The padding flag.
        """
        pass

    def get_extension(self) -> bool:
        """/ Get the extension flag.
        / @return The extension flag.
        """
        pass

    def get_csrc_count(self) -> int:
        """/ Get the CSRC count.
        / @return The CSRC count.
        """
        pass

    def get_marker(self) -> bool:
        """/ Get the marker flag.
        / @return The marker flag.
        """
        pass

    def get_payload_type(self) -> int:
        """/ Get the payload type.
        / @return The payload type.
        """
        pass

    def get_sequence_number(self) -> int:
        """/ Get the sequence number.
        / @return The sequence number.
        """
        pass

    def get_timestamp(self) -> int:
        """/ Get the timestamp.
        / @return The timestamp.
        """
        pass

    def get_ssrc(self) -> int:
        """/ Get the SSRC.
        / @return The SSRC.
        """
        pass

    # -----------------------------------------------------------------
    # Setters for the RTP header fields.
    # -----------------------------------------------------------------

    def set_version(self, version: int) -> None:
        """/ Set the RTP version.
        / @param version The RTP version to set.
        """
        pass

    def set_padding(self, padding: bool) -> None:
        """/ Set the padding flag.
        / @param padding The padding flag to set.
        """
        pass

    def set_extension(self, extension: bool) -> None:
        """/ Set the extension flag.
        / @param extension The extension flag to set.
        """
        pass

    def set_csrc_count(self, csrc_count: int) -> None:
        """/ Set the CSRC count.
        / @param csrc_count The CSRC count to set.
        """
        pass

    def set_marker(self, marker: bool) -> None:
        """/ Set the marker flag.
        / @param marker The marker flag to set.
        """
        pass

    def set_payload_type(self, payload_type: int) -> None:
        """/ Set the payload type.
        / @param payload_type The payload type to set.
        """
        pass

    def set_sequence_number(self, sequence_number: int) -> None:
        """/ Set the sequence number.
        / @param sequence_number The sequence number to set.
        """
        pass

    def set_timestamp(self, timestamp: int) -> None:
        """/ Set the timestamp.
        / @param timestamp The timestamp to set.
        """
        pass

    def set_ssrc(self, ssrc: int) -> None:
        """/ Set the SSRC.
        / @param ssrc The SSRC to set.
        """
        pass

    # -----------------------------------------------------------------
    # Utility methods.
    # -----------------------------------------------------------------

    def serialize(self) -> None:
        """/ Serialize the RTP header.
        / @note This method should be called after modifying the RTP header fields.
        / @note This method does not serialize the payload. To set the payload, use
        /       set_payload().
        /       To get the payload, use get_payload().
        """
        pass

    def get_data(self) -> std.span[ int]:
        """/ Get a span view of the whole packet.
        / @note The span is valid as long as the packet_ vector is not modified.
        / @note If you manually build the packet_ vector, you should make sure that you
        /       call serialize() before calling this method.
        / @return A span of the whole packet.
        """
        pass

    def get_rtp_header_size(self) -> int:
        """/ Get the size of the RTP header.
        / @return The size of the RTP header.
        """
        pass

    def get_rtp_header(self) -> std.span[ int]:
        """/ Get a span of bytes of the RTP header.
        / @return A span of bytes of the RTP header.
        """
        pass

    def get_packet(self) -> List[int]:
        """/ Get a reference to the packet_ vector.
        / @return A reference to the packet_ vector.
        """
        pass

    def get_payload(self) -> std.span[ int]:
        """/ Get a span of bytes of the payload.
        / @return A span of bytes of the payload.
        """
        pass

    def set_payload(self, payload: std.span[ int]) -> None:
        """/ Set the payload.
        / @param payload The payload to set.
        """
        pass


####################    </generated_from:rtp_packet.hpp>    ####################


####################    <generated_from:rtsp_client.hpp>    ####################






class RtspClient:
    """/ A class for interacting with an RTSP server using RTP and RTCP over UDP
    /
    / This class is used to connect to an RTSP server and receive JPEG frames
    / over RTP. It uses the TCP socket to send RTSP requests and receive RTSP
    / responses. It uses the UDP socket to receive RTP and RTCP packets.
    /
    / The RTSP client is designed to be used with the RTSP server in the
    / [camera-streamer]https://github.com/esp-cpp/camera-streamer) project, but it
    / should work with any RTSP server that sends JPEG frames over RTP.
    /
    / \section rtsp_client_ex1 RtspClient Example
    / \snippet rtsp_example.cpp rtsp_client_example
    """

    class Config:
        """/ Configuration for the RTSP client"""
        server_address: str                                  #/< The server IP Address to connect to
        rtsp_port: int = int(8554)                           #/< The port of the RTSP server
        path: str = str("/mjpeg/1")                          #/< The path to the RTSP stream on the server. Will be appended
        #/< to the server address and port to form the full path of the
        #/< form "rtsp://<server_address>:<rtsp_port><path>"
        on_jpeg_frame: RtspClient.jpeg_frame_callback_t      #/< The callback to call when a JPEG frame is received
        log_level: Logger.Verbosity = Logger.Verbosity.info  #/< The verbosity of the logger
        def __init__(
            self,
            server_address: str = "",
            rtsp_port: int = int(8554),
            path: str = str("/mjpeg/1"),
            on_jpeg_frame: RtspClient.jpeg_frame_callback_t = RtspClient.jpeg_frame_callback_t(),
            log_level: Logger.Verbosity = Logger.Verbosity.info
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    def send_request(
        self,
        method: str,
        path: str,
        extra_headers: std.unordered_map[str, str],
        ec: std.error_code
        ) -> str:
        """/ Send an RTSP request to the server
        / \note This is a blocking call
        / \note This will parse the response and set the session ID if it is
        /      present in the response. If the response is not a 200 OK, then
        /      an error code will be set and the response will be returned.
        /      If the response is a 200 OK, then the response will be returned
        /      and the error code will be set to success.
        / \param method The method to use for connecting.
        /       Options are "OPTIONS", "DESCRIBE", "SETUP", "PLAY", and "TEARDOWN"
        / \param path The path to the RTSP stream on the server.
        / \param extra_headers Any extra headers to send with the request. These
        /      will be added to the request after the CSeq and Session headers. The
        /      key is the header name and the value is the header value. For example,
        /      {"Accept": "application/sdp"} will add "Accept: application/sdp" to the
        /      request. The "User-Agent" header will be added automatically. The
        /      "CSeq" and "Session" headers will be added automatically.
        /      The "Accept" header will be added automatically. The "Transport"
        /      header will be added automatically for the "SETUP" method. Defaults to
        /      an empty map.
        / \param ec The error code to set if an error occurs
        / \return The response from the server
        """
        pass

    def connect(self, ec: std.error_code) -> None:
        """/ Connect to the RTSP server
        / Connects to the RTSP server and sends the OPTIONS request.
        / \param ec The error code to set if an error occurs
        """
        pass

    def disconnect(self, ec: std.error_code) -> None:
        """/ Disconnect from the RTSP server
        / Disconnects from the RTSP server and sends the TEARDOWN request.
        / \param ec The error code to set if an error occurs
        """
        pass

    def describe(self, ec: std.error_code) -> None:
        """/ Describe the RTSP stream
        / Sends the DESCRIBE request to the RTSP server and parses the response.
        / \param ec The error code to set if an error occurs
        """
        pass

    @overload
    def setup(self, ec: std.error_code) -> None:
        """/ Setup the RTSP stream
        / \note Starts the RTP and RTCP threads.
        / Sends the SETUP request to the RTSP server and parses the response.
        / \note The default ports are 5000 and 5001 for RTP and RTCP respectively.
        / \note The default receive timeout is 5 seconds.
        / \param ec The error code to set if an error occurs
        """
        pass

    @overload
    def setup(
        self,
        rtp_port: int,
        rtcp_port: int,
        receive_timeout: std.chrono.duration[float],
        ec: std.error_code
        ) -> None:
        """/ Setup the RTSP stream
        / Sends the SETUP request to the RTSP server and parses the response.
        / \note Starts the RTP and RTCP threads.
        / \param rtp_port The RTP client port
        / \param rtcp_port The RTCP client port
        / \param receive_timeout The timeout for receiving RTP and RTCP packets
        / \param ec The error code to set if an error occurs
        """
        pass

    def play(self, ec: std.error_code) -> None:
        """/ Play the RTSP stream
        / Sends the PLAY request to the RTSP server and parses the response.
        / \param ec The error code to set if an error occurs
        """
        pass

    def pause(self, ec: std.error_code) -> None:
        """/ Pause the RTSP stream
        / Sends the PAUSE request to the RTSP server and parses the response.
        / \param ec The error code to set if an error occurs
        """
        pass

    def teardown(self, ec: std.error_code) -> None:
        """/ Teardown the RTSP stream
        / Sends the TEARDOWN request to the RTSP server and parses the response.
        / \param ec The error code to set if an error occurs
        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass


####################    </generated_from:rtsp_client.hpp>    ####################


####################    <generated_from:rtsp_server.hpp>    ####################







class RtspServer:
    """/ Class for streaming MJPEG data from a camera using RTSP + RTP
    / Starts a TCP socket to listen for RTSP connections, and then spawns off a
    / new RTSP session for each connection.
    / @see RtspSession
    / @note This class does not currently send RTCP packets
    /
    / \section rtsp_server_ex1 RtspServer example
    / \snippet rtsp_example.cpp rtsp_server_example
    """
    class Config:
        """/ @brief Configuration for the RTSP server"""
        server_address: str                                  #/< The ip address of the server
        port: int                                            #/< The port to listen on
        path: str                                            #/< The path to the RTSP stream
        max_data_size: int = 1000                            #/< The maximum size of RTP packet data for the MJPEG stream. Frames will be broken
        #/< up into multiple packets if they are larger than this. It seems that 1500 works
        #/< well for sending, but is too large for the esp32 (camera-display) to receive
        #/< properly.
        log_level: Logger.Verbosity = Logger.Verbosity.warn  #/< The log level for the RTSP server
        def __init__(
            self,
            server_address: str = "",
            port: int = int(),
            path: str = "",
            max_data_size: int = 1000,
            log_level: Logger.Verbosity = Logger.Verbosity.warn
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    def set_session_log_level(self, log_level: Logger.Verbosity) -> None:
        """/ @brief Sets the log level for the RTSP sessions created by this server
        / @note This does not affect the log level of the RTSP server itself
        / @note This does not change the log level of any sessions that have
        /       already been created
        / @param log_level The log level to set
        """
        pass

    def start(
        self,
        accept_timeout: std.chrono.duration[float] = std.chrono.seconds(5)
        ) -> bool:
        """/ @brief Start the RTSP server
        / Starts the accept task, session task, and binds the RTSP socket
        / @param accept_timeout The timeout for accepting new connections
        / @return True if the server was started successfully, False otherwise
        """
        pass

    def stop(self) -> None:
        """/ @brief Stop the FTP server
        / Stops the accept task, session task, and closes the RTSP socket
        """
        pass

    def send_frame(self, frame: JpegFrame) -> None:
        """/ @brief Send a frame over the RTSP connection
        / Converts the full JPEG frame into a series of simplified RTP/JPEG
        / packets and stores it to be sent over the RTP socket, but does not
        / actually send it
        / @note Overwrites any existing frame that has not been sent
        / @param frame The frame to send
        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:rtsp_server.hpp>    ####################


####################    <generated_from:rtsp_session.hpp>    ####################






class RtspSession:
    """/ Class that reepresents an RTSP session, which is uniquely identified by a
    / session id and sends frame data over RTP and RTCP to the client
    """
    class Config:
        """/ Configuration for the RTSP session"""
        server_address: str                                                  #/< The address of the server
        rtsp_path: str                                                       #/< The RTSP path of the session
        receive_timeout: std.chrono.duration[float] = std.chrono.seconds(5)  #/< The timeout for receiving data. Should be > 0.
        log_level: Logger.Verbosity = Logger.Verbosity.warn                  #/< The log level of the session
        def __init__(
            self,
            server_address: str = "",
            rtsp_path: str = "",
            receive_timeout: std.chrono.duration[float] = std.chrono.seconds(5),
            log_level: Logger.Verbosity = Logger.Verbosity.warn
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass



    def get_session_id(self) -> int:
        """/ @brief Get the session id
        / @return The session id
        """
        pass

    def is_closed(self) -> bool:
        """/ @brief Check if the session is closed
        / @return True if the session is closed, False otherwise
        """
        pass

    def is_connected(self) -> bool:
        """/ Get whether the session is connected
        / @return True if the session is connected, False otherwise
        """
        pass

    def is_active(self) -> bool:
        """/ Get whether the session is active
        / @return True if the session is active, False otherwise
        """
        pass

    def play(self) -> None:
        """/ Mark the session as active
        / This will cause the server to start sending frames to the client
        """
        pass

    def pause(self) -> None:
        """/ Pause the session
        / This will cause the server to stop sending frames to the client
        / @note This does not stop the session, it just pauses it
        / @note This is useful for when the client is buffering
        """
        pass

    def teardown(self) -> None:
        """/ Teardown the session
        / This will cause the server to stop sending frames to the client
        / and close the connection
        """
        pass

    def send_rtp_packet(self, packet: RtpPacket) -> bool:
        """/ Send an RTP packet to the client
        / @param packet The RTP packet to send
        / @return True if the packet was sent successfully, False otherwise
        """
        pass

    def send_rtcp_packet(self, packet: RtcpPacket) -> bool:
        """/ Send an RTCP packet to the client
        / @param packet The RTCP packet to send
        / @return True if the packet was sent successfully, False otherwise
        """
        pass

    def __init__(self) -> None:
        """Auto-generated default constructor"""
        pass

####################    </generated_from:rtsp_session.hpp>    ####################


####################    <generated_from:lowpass_filter.hpp>    ####################




class LowpassFilter:
    """*
     *  @brief Lowpass infinite impulse response (IIR) filter.

    """
    class Config:
        """*
           *  @brief Configuration for the lowpass filter.

        """
        normalized_cutoff_frequency: float  #*< Filter cutoff frequency in the range [0.0, 0.5] (normalizd
                                                to sample frequency, = 2 * f_cutoff / f_sample).
        q_factor: float                     #*< Quality (Q) factor of the filter. The higher the Q the better the filter.
        def __init__(
            self,
            normalized_cutoff_frequency: float = float(),
            q_factor: float = float()
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def __init__(self) -> None:
        pass


    def configure(self, config: LowpassFilter.Config) -> None:
        """*
           * @brief Set the filter coefficients based on the config.
           * @param config Configuration struct.

        """
        pass

    @overload
    def update(self, input: float, output: float, length: int) -> None:
        """*
           * @brief Filter the input samples, updating internal state, and writing the
           *        filtered values to the data pointed to by output.
           * @param input Pointer to (floating point) array of new samples of the input data
           * @param output Pointer to (floating point) array which will be filled with
           *        the filtered input.
           * @param length Number of samples, should be >= length of input & output memory.
           * @note On ESP32, the input and output arrays must have
           *       __attribute__((aligned(16))) to ensure proper alignment for the ESP32
           *       DSP functions.

        """
        pass

    @overload
    def update(self, input: float) -> float:
        """*
           * @brief Filter the signal sampled by input, updating internal state, and
           *        returning the filtered output.
           * @param input New sample of the input data.
           * @return Filtered output based on input and history.

        """
        pass

    def __call__(self, input: float) -> float:
        """*
           * @brief Filter the signal sampled by input, updating internal state, and
           *        returning the filtered output.
           * @param input New sample of the input data.
           * @return Filtered output based on input and history.

        """
        pass

    def reset(self) -> None:
        """*
           * @brief Reset the filter state to zero.

        """
        pass




####################    </generated_from:lowpass_filter.hpp>    ####################


####################    <generated_from:simple_lowpass_filter.hpp>    ####################




class SimpleLowpassFilter:
    """*
     *  @brief Simple lowpass filter using a time constant and a stored value.

    """
    class Config:
        """*
           *  @brief Configuration for the lowpass filter.

        """
        time_constant: float = 0.0  #*< Time constant of the filter.
        def __init__(self, time_constant: float = 0.0) -> None:
            """Auto-generated default constructor with named params"""
            pass

    def __init__(self) -> None:
        pass


    def set_time_constant(self, time_constant: float) -> None:
        """*
           * @brief Set the time constant of the filter.
           * @param time_constant Time constant of the filter.

        """
        pass

    def get_time_constant(self) -> float:
        """*
           * @brief Get the time constant of the filter.
           * @return Time constant of the filter.

        """
        pass

    def update(self, input: float) -> float:
        """*
           * @brief Filter the signal sampled by input, updating internal state, and
           *        returning the filtered output.
           * @param input New sample of the input data.
           * @return Filtered output based on input, time, and history.

        """
        pass

    def __call__(self, input: float) -> float:
        """*
           * @brief Filter the signal sampled by input, updating internal state, and
           *        returning the filtered output.
           * @param input New sample of the input data.
           * @return Filtered output based on input, time, and history.

        """
        pass

    def reset(self) -> None:
        """*
           * @brief Reset the filter to its initial state.

        """
        pass




####################    </generated_from:simple_lowpass_filter.hpp>    ####################

# </litgen_stub>
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
