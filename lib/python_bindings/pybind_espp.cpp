#include <chrono>
#include <memory>
#include <string>
#include <system_error>
#include <vector>

#include <pybind11/chrono.h>
#include <pybind11/functional.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include "espp.hpp"

namespace py = pybind11;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

void py_init_module_espp(py::module &m) {
  // using namespace espp;  // NON!

  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  // <litgen_pydef> // Autogenerated code below! Do not edit!
  ////////////////////    <generated_from:base_component.hpp>    ////////////////////
  auto pyClassBaseComponent =
      py::class_<espp::BaseComponent>(m, "BaseComponent", py::dynamic_attr(),
                                      "/ Base class for all components\n/ Provides a logger and "
                                      "some basic logging configuration")
          .def("get_name", &espp::BaseComponent::get_name,
               "/ Get the name of the component\n/ \\return A const reference to the name of the "
               "component\n/ \note This is the tag of the logger")
          .def("set_log_tag", &espp::BaseComponent::set_log_tag, py::arg("tag"),
               "/ Set the tag for the logger\n/ \\param tag The tag to use for the logger")
          .def("get_log_level", &espp::BaseComponent::get_log_level,
               "/ Get the log level for the logger\n/ \\return The verbosity level of the "
               "logger\n/ \\sa Logger::Verbosity\n/ \\sa Logger::set_verbosity")
          .def("set_log_level", &espp::BaseComponent::set_log_level, py::arg("level"),
               "/ Set the log level for the logger\n/ \\param level The verbosity level to use for "
               "the logger\n/ \\sa Logger::Verbosity\n/ \\sa Logger::set_verbosity")
          .def("set_log_verbosity", &espp::BaseComponent::set_log_verbosity, py::arg("level"),
               "/ Set the log verbosity for the logger\n/ \\param level The verbosity level to use "
               "for the logger\n/ \note This is a convenience method that calls set_log_level\n/ "
               "\\sa set_log_level\n/ \\sa Logger::Verbosity\n/ \\sa Logger::set_verbosity")
          .def("get_log_verbosity", &espp::BaseComponent::get_log_verbosity,
               "/ Get the log verbosity for the logger\n/ \\return The verbosity level of the "
               "logger\n/ \note This is a convenience method that calls get_log_level\n/ \\sa "
               "get_log_level\n/ \\sa Logger::Verbosity\n/ \\sa Logger::get_verbosity")
          .def("set_log_rate_limit", &espp::BaseComponent::set_log_rate_limit,
               py::arg("rate_limit"),
               "/ Set the rate limit for the logger\n/ \\param rate_limit The rate limit to use "
               "for the logger\n/ \note Only calls to the logger that have _rate_limit suffix will "
               "be rate limited\n/ \\sa Logger::set_rate_limit");
  ////////////////////    </generated_from:base_component.hpp>    ////////////////////

  ////////////////////    <generated_from:color.hpp>    ////////////////////
  auto pyClassRgb =
      py::class_<espp::Rgb>(m, "Rgb", py::dynamic_attr(),
                            "*\n * @brief Class representing a color using RGB color space.\n")
          .def_readwrite("r", &espp::Rgb::r, "/< Red value ∈ [0, 1]")
          .def_readwrite("g", &espp::Rgb::g, "/< Green value ∈ [0, 1]")
          .def_readwrite("b", &espp::Rgb::b, "/< Blue value ∈ [0, 1]")
          .def(py::init<>())
          .def(py::init<const float &, const float &, const float &>(), py::arg("r"), py::arg("g"),
               py::arg("b"),
               "*\n   * @brief Construct an Rgb object from the provided rgb values.\n   * @note "
               "If provided values outside the range [0,1], it will rescale them to\n   *       be "
               "within the range [0,1] by dividing by 255.\n   * @param r Floating point value for "
               "the red channel, should be in range [0,\n   *        1]\n   * @param g Floating "
               "point value for the green channel, should be in range\n   *        [0, 1]\n   * "
               "@param b Floating point value for the blue channel, should be in range\n   *       "
               " [0, 1]\n")
          .def(py::init<const espp::Rgb &>(), py::arg("rgb"),
               "*\n   * @brief Copy-construct an Rgb object from the provided object.\n   * @note "
               "If provided values outside the range [0,1], it will rescale them to\n   *       be "
               "within the range [0,1] by dividing by 255.\n   * @param rgb Rgb struct containing "
               "the values to copy.\n")
          .def(py::init<const espp::Hsv &>(), py::arg("hsv"),
               "*\n   * @brief Construct an Rgb object from the provided Hsv object.\n   * @note "
               "This calls hsv.rgb() on the provided object, which means that invalid\n   *       "
               "HSV data (not in the ranges [0,360], [0,1], and [0,1]) could lead to\n   *       "
               "bad RGB data. The Rgb constructor will automatically convert the\n   *       "
               "values to be in the proper range, but the perceived color will be\n   *       "
               "changed.\n   * @param hsv Hsv object to copy.\n")
          .def(py::init<const uint32_t &>(), py::arg("hex"),
               "*\n   * @brief Construct an Rgb object from the provided hex value.\n   * @param "
               "hex Hex value to convert to RGB. The hex value should be in the\n   *        "
               "format 0xRRGGBB.\n")
          .def("__add__", &espp::Rgb::operator+, py::arg("rhs"),
               "*\n   * @brief Perform additive color blending (averaging)\n   * @param rhs Other "
               "color to add to this color to create the resultant color\n   * @return Resultant "
               "color from blending this color with the \\p rhs color.\n")
          .def("__iadd__", &espp::Rgb::operator+=, py::arg("rhs"),
               "*\n   * @brief Perform additive color blending (averaging)\n   * @param rhs Other "
               "color to add to this color\n")
          .def("__eq__", &espp::Rgb::operator==, py::arg("rhs"))
          .def("__ne__", &espp::Rgb::operator!=, py::arg("rhs"))
          .def("hsv", &espp::Rgb::hsv,
               "*\n   * @brief Get a HSV representation of this RGB color.\n   * @return An HSV "
               "object containing the HSV representation.\n")
          .def("hex", &espp::Rgb::hex,
               "*\n   * @brief Get the hex representation of this RGB color.\n   * @return The hex "
               "representation of this RGB color.\n");

  auto pyClassHsv =
      py::class_<espp::Hsv>(m, "Hsv", py::dynamic_attr(),
                            "*\n * @brief Class representing a color using HSV color space.\n")
          .def_readwrite("h", &espp::Hsv::h, "/< Hue ∈ [0, 360]")
          .def_readwrite("s", &espp::Hsv::s, "/< Saturation ∈ [0, 1]")
          .def_readwrite("v", &espp::Hsv::v, "/< Value ∈ [0, 1]")
          .def(py::init<>())
          .def(py::init<const float &, const float &, const float &>(), py::arg("h"), py::arg("s"),
               py::arg("v"),
               "*\n   * @brief Construct a Hsv object from the provided values.\n   * @param h Hue "
               "- will be clamped to be in range [0, 360]\n   * @param s Saturation - will be "
               "clamped to be in range [0, 1]\n   * @param v Value - will be clamped to be in "
               "range [0, 1]\n")
          .def(py::init<const espp::Hsv &>(), py::arg("hsv"),
               "*\n   * @brief Copy-construct the Hsv object\n   * @param hsv Object to copy "
               "from.\n")
          .def(py::init<const espp::Rgb &>(), py::arg("rgb"),
               "*\n   * @brief Construct Hsv object from Rgb object. Calls rgb.hsv() to perform\n  "
               " *        the conversion.\n   * @param rgb The Rgb object to convert and copy.\n")
          .def("__eq__", &espp::Hsv::operator==, py::arg("rhs"))
          .def("__ne__", &espp::Hsv::operator!=, py::arg("rhs"))
          .def("rgb", &espp::Hsv::rgb,
               "*\n   * @brief Get a RGB representation of this HSV color.\n   * @return An RGB "
               "object containing the RGB representation.\n");

  m.def("color_code", py::overload_cast<const espp::Rgb &>(espp::color_code), py::arg("rgb"),
        "\n(C++ auto return type)");

  m.def("color_code", py::overload_cast<const espp::Hsv &>(espp::color_code), py::arg("hsv"),
        "\n(C++ auto return type)");
  ////////////////////    </generated_from:color.hpp>    ////////////////////

  ////////////////////    <generated_from:event_manager.hpp>    ////////////////////
  auto pyClassEventManager =
      py::class_<espp::EventManager>(
          m, "EventManager", py::dynamic_attr(),
          "*\n * @brief Singleton class for managing events. Provides mechanisms for\n *        "
          "anonymous publish / subscribe interactions - enabling one to one,\n *        one to "
          "many, many to one, and many to many data distribution with\n *        loose coupling "
          "and low overhead. Each topic runs a thread for that\n *        topic's subscribers, "
          "executing all the callbacks in sequence and\n *        then going to sleep again until "
          "new data is published.\n *\n * @note In c++ objects, it's recommended to call the\n *   "
          "    add_publisher/add_subscriber functions in the class constructor and\n *       then "
          "to call the remove_publisher/remove_subscriber functions in the\n *       class "
          "destructor.\n *\n * @note It is recommended (unless you are only interested in events "
          "and not\n *       data or are only needing to transmit actual strings) to use a\n *     "
          "  serialization library (such as espp::serialization - which wraps\n *       alpaca) to "
          "serialize your data structures to string when publishing\n *       and then deserialize "
          "your data from string in the subscriber\n *       callbacks.\n *\n * \\section "
          "event_manager_ex1 Event Manager Example\n * \\snippet event_manager_example.cpp event "
          "manager example\n")
          .def_static("get", &espp::EventManager::get,
                      "*\n   * @brief Get the singleton instance of the EventManager.\n   * "
                      "@return A reference to the EventManager singleton.\n",
                      py::return_value_policy::reference)
          .def("add_publisher", &espp::EventManager::add_publisher, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Register a publisher for \\p component on \\p topic.\n   * @param "
               "topic Topic name for the data being published.\n   * @param component Name of the "
               "component publishing data.\n   * @return True if the publisher was added, False if "
               "it was already\n   *         registered for that component.\n")
          .def("add_subscriber",
               py::overload_cast<const std::string &, const std::string &,
                                 const espp::EventManager::event_callback_fn &, const size_t>(
                   &espp::EventManager::add_subscriber),
               py::arg("topic"), py::arg("component"), py::arg("callback"),
               py::arg("stack_size_bytes") = 8192,
               "*\n   * @brief Register a subscriber for \\p component on \\p topic.\n   * @param "
               "topic Topic name for the data being subscribed to.\n   * @param component Name of "
               "the component publishing data.\n   * @param callback The event_callback_fn to be "
               "called when receicing data on\n   *        \\p topic.\n   * @param "
               "stack_size_bytes The stack size in bytes to use for the subscriber\n   * @note The "
               "stack size is only used if a subscriber is not already registered\n   *       for "
               "that topic. If a subscriber is already registered for that topic,\n   *       the "
               "stack size is ignored.\n   * @return True if the subscriber was added, False if it "
               "was already\n   *         registered for that component.\n")
          .def("add_subscriber",
               py::overload_cast<const std::string &, const std::string &,
                                 const espp::EventManager::event_callback_fn &,
                                 const espp::Task::BaseConfig &>(
                   &espp::EventManager::add_subscriber),
               py::arg("topic"), py::arg("component"), py::arg("callback"), py::arg("task_config"),
               "*\n   * @brief Register a subscriber for \\p component on \\p topic.\n   * @param "
               "topic Topic name for the data being subscribed to.\n   * @param component Name of "
               "the component publishing data.\n   * @param callback The event_callback_fn to be "
               "called when receicing data on\n   *        \\p topic.\n   * @param task_config The "
               "task configuration to use for the subscriber.\n   * @note The task_config is only "
               "used if a subscriber is not already\n   *       registered for that topic. If a "
               "subscriber is already registered for\n   *       that topic, the task_config is "
               "ignored.\n   * @return True if the subscriber was added, False if it was already\n "
               "  *         registered for that component.\n")
          .def("publish", &espp::EventManager::publish, py::arg("topic"), py::arg("data"),
               "*\n   * @brief Publish \\p data on \\p topic.\n   * @param topic Topic to publish "
               "data on.\n   * @param data Data to publish, within a vector container.\n   * "
               "@return True if \\p data was successfully published to \\p topic, False\n   *      "
               "   otherwise. Publish will not occur (and will return False) if\n   *         "
               "there are no subscribers for this topic.\n")
          .def("remove_publisher", &espp::EventManager::remove_publisher, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Remove \\p component's publisher for \\p topic.\n   * @param topic "
               "The topic that \\p component was publishing on.\n   * @param component The "
               "component for which the publisher was registered.\n   * @return True if the "
               "publisher was removed, False if it was not\n   *         registered.\n")
          .def("remove_subscriber", &espp::EventManager::remove_subscriber, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Remove \\p component's subscriber for \\p topic.\n   * @param topic "
               "The topic that \\p component was subscribing to.\n   * @param component The "
               "component for which the subscriber was registered.\n   * @return True if the "
               "subscriber was removed, False if it was not\n   *         registered.\n");
  ////////////////////    </generated_from:event_manager.hpp>    ////////////////////

  ////////////////////    <generated_from:ftp_server.hpp>    ////////////////////
  auto pyClassFtpServer =
      py::class_<espp::FtpServer>(m, "FtpServer", py::dynamic_attr(),
                                  "/ \\brief A class that implements a FTP server.")
          .def(py::init<std::string_view, uint16_t, const std::filesystem::path &>(),
               py::arg("ip_address"), py::arg("port"), py::arg("root"),
               "/ \\brief A class that implements a FTP server.\n/ \note The IP Address is not "
               "currently used to select the right\n/       interface, but is instead passed to "
               "the FtpClientSession so that\n/       it can be used in the PASV command.\n/ "
               "\\param ip_address The IP address to listen on.\n/ \\param port The port to listen "
               "on.\n/ \\param root The root directory of the FTP server.")
          .def("start", &espp::FtpServer::start,
               "/ \\brief Start the FTP server.\n/ Bind to the port and start accepting "
               "connections.\n/ \\return True if the server was started, False otherwise.")
          .def("stop", &espp::FtpServer::stop, "/ \\brief Stop the FTP server.");
  ////////////////////    </generated_from:ftp_server.hpp>    ////////////////////

  ////////////////////    <generated_from:logger.hpp>    ////////////////////
  auto pyClassLogger = py::class_<espp::Logger>(
      m, "Logger", py::dynamic_attr(),
      "*\n * @brief Logger provides a wrapper around nicer / more robust formatting than\n * "
      "standard ESP_LOG* macros with the ability to change the log level at\n * run-time. Logger "
      "currently is a light wrapper around libfmt (future\n * std::format).\n *\n * To save on "
      "code size, the logger has the ability to be compiled out based on\n * the log level set in "
      "the sdkconfig. This means that if the log level is set to\n * ERROR, all debug, info, and "
      "warn logs will be compiled out. This is done by\n * checking the log level at compile time "
      "and only compiling in the functions\n * that are needed.\n *\n * The logger can also be "
      "compiled with support for cursor commands. This allows\n * the logger to move the cursor "
      "up, down, clear the line, clear the screen, and\n * move the cursor to a specific position. "
      "This can be useful for creating\n * various types of interactive output or to maintian "
      "context with long-running\n * logs.\n *\n * \\section logger_ex1 Basic Example\n * "
      "\\snippet logger_example.cpp Logger example\n * \\section logger_ex2 Threaded Logging and "
      "Verbosity Example\n * \\snippet logger_example.cpp MultiLogger example\n * \\section "
      "logger_ex3 Cursor Commands Example\n * \\snippet logger_example.cpp Cursor Commands "
      "example\n");

  { // inner classes & enums of Logger
    auto pyEnumVerbosity =
        py::enum_<espp::Logger::Verbosity>(
            pyClassLogger, "Verbosity", py::arithmetic(),
            "*\n   *   Verbosity levels for the logger, in order of increasing priority.\n")
            .value("debug", espp::Logger::Verbosity::DEBUG, "*< Debug level verbosity.")
            .value("info", espp::Logger::Verbosity::INFO, "*< Info level verbosity.")
            .value("warn", espp::Logger::Verbosity::WARN, "*< Warn level verbosity.")
            .value("error", espp::Logger::Verbosity::ERROR, "*< Error level verbosity.")
            .value("none", espp::Logger::Verbosity::NONE,
                   "*< No verbosity - logger will not print anything.");
    auto pyClassLogger_ClassConfig =
        py::class_<espp::Logger::Config>(pyClassLogger, "Config", py::dynamic_attr(),
                                         "*\n   * @brief Configuration struct for the logger.\n")
            .def(py::init<>(
                     [](std::string_view tag = std::string_view(), bool include_time = {true},
                        std::chrono::duration<float> rate_limit = std::chrono::duration<float>(0),
                        espp::Logger::Verbosity level = espp::Logger::Verbosity::WARN) {
                       auto r = std::make_unique<espp::Logger::Config>();
                       r->tag = tag;
                       r->include_time = include_time;
                       r->rate_limit = rate_limit;
                       r->level = level;
                       return r;
                     }),
                 py::arg("tag") = std::string_view(), py::arg("include_time") = bool{true},
                 py::arg("rate_limit") = std::chrono::duration<float>(0),
                 py::arg("level") = espp::Logger::Verbosity::WARN)
            .def_readwrite("tag", &espp::Logger::Config::tag,
                           "*< The TAG that will be prepended to all logs.")
            .def_readwrite("include_time", &espp::Logger::Config::include_time,
                           "*< Include the time in the log.")
            .def_readwrite(
                "rate_limit", &espp::Logger::Config::rate_limit,
                "*< The rate limit for the logger. Optional, if <= 0 no\nrate limit. @note Only "
                "calls that have _rate_limited suffixed will be rate limited.")
            .def_readwrite("level", &espp::Logger::Config::level,
                           "*< The verbosity level for the logger.");
  } // end of inner classes & enums of Logger

  pyClassLogger.def(py::init<const espp::Logger::Config &>())
      .def("set_verbosity", &espp::Logger::set_verbosity, py::arg("level"),
           "*\n   * @brief Change the verbosity for the logger. \\sa Logger::Verbosity\n   * "
           "@param level new verbosity level\n")
      .def("set_tag", &espp::Logger::set_tag, py::arg("tag"),
           "*\n   * @brief Change the tag for the logger.\n   * @param tag The new tag.\n")
      .def("get_tag", &espp::Logger::get_tag,
           "*\n   * @brief Get the current tag for the logger.\n   * @return A const reference to "
           "the current tag.\n")
      .def("set_include_time", &espp::Logger::set_include_time, py::arg("include_time"),
           "*\n   * @brief Whether to include the time in the log.\n   * @param include_time "
           "Whether to include the time in the log.\n   * @note The time is in seconds since boot "
           "and is represented as a floating\n   *       point number with precision to the "
           "millisecond.\n")
      .def("set_rate_limit", &espp::Logger::set_rate_limit, py::arg("rate_limit"),
           "*\n   * @brief Change the rate limit for the logger.\n   * @param rate_limit The new "
           "rate limit.\n   * @note Only calls that have _rate_limited suffixed will be rate "
           "limited.\n")
      .def("get_rate_limit", &espp::Logger::get_rate_limit,
           "*\n   * @brief Get the current rate limit for the logger.\n   * @return The current "
           "rate limit.\n")
      .def_static(
          "get_time", &espp::Logger::get_time,
          "*\n   *   Get the current time in seconds since the start of the logging system.\n   *  "
          " @return time in seconds since the start of the logging system.\n");
  ////////////////////    </generated_from:logger.hpp>    ////////////////////

  ////////////////////    <generated_from:bezier.hpp>    ////////////////////
  auto pyClassBezier_espp_Vector2f = py::class_<espp::Bezier<espp::Vector2f>>(
      m, "Bezier_espp_Vector2f", py::dynamic_attr(),
      "*\n * @brief Implements rational / weighted and unweighted cubic bezier curves\n *        "
      "between control points.\n * @note See https://pomax.github.io/bezierinfo/ for information "
      "on bezier\n *       curves.\n * @note Template class which can be used individually on "
      "floating point\n *       values directly or on containers such as Vector2<float>.\n * "
      "@tparam T The type of the control points, e.g. float or Vector2<float>.\n * @note The "
      "bezier curve is defined by 4 control points, P0, P1, P2, P3.\n *      The curve is defined "
      "by the equation:\n *      \\f$B(t) = (1-t)^3 * P0 + 3 * (1-t)^2 * t * P1 + 3 * (1-t) * t^2 "
      "* P2 + t^3 * P3\\f$\n *      where t is the evaluation parameter, [0, 1].\n *\n * @note The "
      "weighted bezier curve is defined by 4 control points, P0, P1, P2, P3\n *      and 4 "
      "weights, W0, W1, W2, W3.\n *      The curve is defined by the equation:\n *      \\f$B(t) = "
      "(W0 * (1-t)^3 * P0 + W1 * 3 * (1-t)^2 * t * P1 + W2 * 3 * (1-t) * t^2 * P2 + W3 *\n * t^3 * "
      "P3) / (W0 + W1 + W2 + W3)\\f$ where t is the evaluation parameter, [0, 1].\n *\n * "
      "\\section bezier_ex1 Example\n * \\snippet math_example.cpp bezier example\n");

  { // inner classes & enums of Bezier_espp_Vector2f
    auto pyClassBezier_ClassConfig =
        py::class_<espp::Bezier<espp::Vector2f>::Config>(
            pyClassBezier_espp_Vector2f, "Config", py::dynamic_attr(),
            "*\n   * @brief Unweighted cubic bezier configuration for 4 control points.\n")
            .def(py::init<>()) // implicit default constructor
            .def_readwrite("control_points", &espp::Bezier<espp::Vector2f>::Config::control_points,
                           "/< Array of 4 control points");
    auto pyClassBezier_ClassWeightedConfig =
        py::class_<espp::Bezier<espp::Vector2f>::WeightedConfig>(
            pyClassBezier_espp_Vector2f, "WeightedConfig", py::dynamic_attr(),
            "*\n   * @brief Weighted cubic bezier configuration for 4 control points with\n   *    "
            "    individual weights.\n")
            .def(py::init<>()) // implicit default constructor
            .def_readwrite("control_points",
                           &espp::Bezier<espp::Vector2f>::WeightedConfig::control_points,
                           "/< Array of 4 control points")
            .def_readwrite("weights", &espp::Bezier<espp::Vector2f>::WeightedConfig::weights,
                           "/< Array of 4 weights, default is array of 1.0");
  } // end of inner classes & enums of Bezier_espp_Vector2f

  pyClassBezier_espp_Vector2f.def(py::init<const espp::Bezier<espp::Vector2f>::Config &>())
      .def(py::init<const espp::Bezier<espp::Vector2f>::WeightedConfig &>())
      .def("__call__", &espp::Bezier<espp::Vector2f>::operator(), py::arg("t"),
           "*\n   * @brief Evaluate the bezier at \\p t.\n   * @note Convienience wrapper around "
           "the at() method.\n   * @param t The evaluation parameter, [0, 1].\n   * @return The "
           "bezier evaluated at \\p t.\n");
  ////////////////////    </generated_from:bezier.hpp>    ////////////////////

  ////////////////////    <generated_from:fast_math.hpp>    ////////////////////
  m.def("square", espp::square, py::arg("f"),
        "*\n * @brief Simple square of the input.\n * @param f Value to square.\n * @return The "
        "square of f (f*f).\n");

  m.def("cube", espp::cube, py::arg("f"),
        "*\n * @brief Simple cube of the input.\n * @param f Value to cube.\n * @return The cube "
        "of f (f*f*f).\n");

  m.def("fast_sqrt", espp::fast_sqrt, py::arg("value"),
        "*\n * @brief Fast square root approximation.\n * @note Using "
        "https://reprap.org/forum/read.php?147,219210 and\n *       "
        "https://en.wikipedia.org/wiki/Fast_inverse_square_root\n * @param value Value to take the "
        "square root of.\n * @return Approximation of the square root of value.\n");

  m.def("sgn", py::overload_cast<int>(espp::sgn<int>), py::arg("x"),
        "*\n * @brief Get the sign of a number (+1, 0, or -1)\n * @param x Value to get the sign "
        "of\n * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0\n");
  m.def("sgn", py::overload_cast<float>(espp::sgn<float>), py::arg("x"),
        "*\n * @brief Get the sign of a number (+1, 0, or -1)\n * @param x Value to get the sign "
        "of\n * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0\n");

  m.def("lerp", espp::lerp, py::arg("a"), py::arg("b"), py::arg("t"),
        "*\n * @brief Linear interpolation between two values.\n * @param a First value.\n * "
        "@param b Second value.\n * @param t Interpolation factor in the range [0, 1].\n * @return "
        "Linear interpolation between a and b.\n");

  m.def("inv_lerp", espp::inv_lerp, py::arg("a"), py::arg("b"), py::arg("v"),
        "*\n * @brief Compute the inverse lerped value.\n * @param a First value (usually the "
        "lower of the two).\n * @param b Second value (usually the higher of the two).\n * @param "
        "v Value to inverse lerp (usually a value between a and b).\n * @return Inverse lerp "
        "value, the factor of v between a and b in the range [0,\n *         1] if v is between a "
        "and b, 0 if v == a, or 1 if v == b. If a == b,\n *         0 is returned. If v is outside "
        "the range [a, b], the value is\n *         extrapolated linearly (i.e. if v < a, the "
        "value is less than 0, if v\n *         > b, the value is greater than 1).\n");

  m.def(
      "piecewise_linear", espp::piecewise_linear, py::arg("points"), py::arg("x"),
      "*\n * @brief Compute the piecewise linear interpolation between a set of points.\n * @param "
      "points Vector of points to interpolate between. The vector should be\n *               "
      "sorted by the first value in the pair. The first value in the\n *               pair is the "
      "x value and the second value is the y value. The x\n *               values should be "
      "unique. The function will interpolate between\n *               the points using linear "
      "interpolation. If x is less than the\n *               first x value, the first y value is "
      "returned. If x is greater\n *               than the last x value, the last y value is "
      "returned. If x is\n *               between two x values, the y value is interpolated "
      "between the\n *               two y values.\n * @param x Value to interpolate at. Should be "
      "a value from the first\n *          distribution of the points (the domain). If x is "
      "outside the domain\n *          of the points, the value returned will be clamped to the "
      "first or\n *          last y value.\n * @return Interpolated value at x.\n");

  m.def("round", espp::round, py::arg("x"),
        "*\n * @brief Round x to the nearest integer.\n * @param x Floating point value to be "
        "rounded.\n * @return Nearest integer to x.\n");

  m.def("fast_ln", espp::fast_ln, py::arg("x"),
        "*\n * @brief fast natural log function, ln(x).\n * @note This speed hack comes from:\n *  "
        " https://gist.github.com/LingDong-/7e4c4cae5cbbc44400a05ba650623\n * @param x Value to "
        "take the natural log of.\n * @return ln(x)\n");

  m.def("fast_sin", espp::fast_sin, py::arg("angle"),
        "*\n * @brief Fast approximation of sin(angle) (radians).\n * @note \\p Angle must be in "
        "the range [0, 2PI].\n * @param angle Angle in radians [0, 2*PI]\n * @return Approximation "
        "of sin(value)\n");

  m.def("fast_cos", espp::fast_cos, py::arg("angle"),
        "*\n * @brief Fast approximation of cos(angle) (radians).\n * @note \\p Angle must be in "
        "the range [0, 2PI].\n * @param angle Angle in radians [0, 2*PI]\n * @return Approximation "
        "of cos(value)\n");
  ////////////////////    </generated_from:fast_math.hpp>    ////////////////////

  ////////////////////    <generated_from:gaussian.hpp>    ////////////////////
  auto pyClassGaussian = py::class_<espp::Gaussian>(
      m, "Gaussian", py::dynamic_attr(),
      "*\n * @brief Implements a gaussian function\n *        "
      "\\f$y(t)=\\alpha\\exp(-\\frac{(t-\\beta)^2}{2\\gamma^2})\\f$.\n * @details Alows you to "
      "store the alpha, beta, and gamma coefficients as well\n *          as update them "
      "dynamically.\n *\n * \\section gaussian_ex1 Example\n * \\snippet math_example.cpp gaussian "
      "example\n * \\section gaussian_ex2 Fade-In/Fade-Out Example\n * \\snippet math_example.cpp "
      "gaussian fade in fade out example\n");

  { // inner classes & enums of Gaussian
    auto pyClassGaussian_ClassConfig =
        py::class_<espp::Gaussian::Config>(
            pyClassGaussian, "Config", py::dynamic_attr(),
            "*\n   * @brief Configuration structure for initializing the gaussian.\n")
            .def(py::init<>([](float gamma = float(), float alpha = {1.0f}, float beta = {0.5f}) {
                   auto r = std::make_unique<espp::Gaussian::Config>();
                   r->gamma = gamma;
                   r->alpha = alpha;
                   r->beta = beta;
                   return r;
                 }),
                 py::arg("gamma") = float(), py::arg("alpha") = float{1.0f},
                 py::arg("beta") = float{0.5f})
            .def_readwrite(
                "gamma", &espp::Gaussian::Config::gamma,
                "/< Slope of the gaussian, range [0, 1]. 0 is more of a thin spike from 0 up to")
            .def_readwrite("alpha", &espp::Gaussian::Config::alpha,
                           "/< Max amplitude of the gaussian output, defautls to 1.0.")
            .def_readwrite(
                "beta", &espp::Gaussian::Config::beta,
                "/< Beta value for the gaussian, default to be symmetric at 0.5 in range [0,1].")
            .def("__eq__", &espp::Gaussian::Config::operator==, py::arg("rhs"));
  } // end of inner classes & enums of Gaussian

  pyClassGaussian.def(py::init<const espp::Gaussian::Config &>())
      .def("__call__", &espp::Gaussian::operator(), py::arg("t"),
           "*\n   * @brief Evaluate the gaussian at \\p t.\n   * @note Convienience wrapper around "
           "the at() method.\n   * @param t The evaluation parameter, [0, 1].\n   * @return The "
           "gaussian evaluated at \\p t.\n")
      .def("update", &espp::Gaussian::update, py::arg("config"),
           "*\n   * @brief Update the gaussian configuration.\n   * @param config The new "
           "configuration.\n")
      .def("set_config", &espp::Gaussian::set_config, py::arg("config"),
           "*\n   * @brief Set the configuration of the gaussian.\n   * @param config The new "
           "configuration.\n")
      .def("get_config", &espp::Gaussian::get_config,
           "*\n   * @brief Get the current configuration of the gaussian.\n   * @return The "
           "current configuration.\n")
      .def("get_gamma", &espp::Gaussian::get_gamma,
           "*\n   * @brief Get the gamma value.\n   * @return The gamma value.\n")
      .def("get_alpha", &espp::Gaussian::get_alpha,
           "*\n   * @brief Get the alpha value.\n   * @return The alpha value.\n")
      .def("get_beta", &espp::Gaussian::get_beta,
           "*\n   * @brief Get the beta value.\n   * @return The beta value.\n")
      .def("set_gamma", &espp::Gaussian::set_gamma, py::arg("gamma"),
           "*\n   * @brief Set the gamma value.\n   * @param gamma The new gamma value.\n")
      .def("set_alpha", &espp::Gaussian::set_alpha, py::arg("alpha"),
           "*\n   * @brief Set the alpha value.\n   * @param alpha The new alpha value.\n")
      .def("set_beta", &espp::Gaussian::set_beta, py::arg("beta"),
           "*\n   * @brief Set the beta value.\n   * @param beta The new beta value.\n");
  ////////////////////    </generated_from:gaussian.hpp>    ////////////////////

  ////////////////////    <generated_from:range_mapper.hpp>    ////////////////////
  auto pyClassRangeMapper_int = py::class_<espp::RangeMapper<int>>(
      m, "RangeMapper_int", py::dynamic_attr(),
      "*\n * @brief Template class for converting a value from an uncentered [minimum,\n *        "
      "maximum] range into a centered output range (default [-1,1]). If\n *        provided a "
      "non-zero deadband, it will convert all values within\n *        [center-deadband, "
      "center+deadband] to be the configured\n *        output_center (default 0).\n *\n *        "
      "The RangeMapper can be optionally configured to invert the input,\n *        so that it "
      "will compute the input w.r.t. the configured min/max of\n *        the input range when "
      "mapping to the output range - this will mean\n *        that a values within the ranges "
      "[minimum, minimum+deadband] and\n *        [maximum-deadband, maximum] will all map to the "
      "output_center and\n *        the input center will map to both output_max and output_min\n "
      "*        depending on the sign of the input.\n *\n * @note When inverting the input range, "
      "you are introducing a discontinuity\n *       between the input distribution and the output "
      "distribution at the\n *       input center. Noise around the input's center value will "
      "create\n *       oscillations in the output which will jump between output maximum\n *      "
      " and output minimum. Therefore it is advised to use \\p invert_input\n *       sparignly, "
      "and to set the values robustly.\n *\n *        The RangeMapper can be optionally configured "
      "to invert the output,\n *        so that after converting from the input range to the "
      "output range,\n *        it will flip the sign on the output.\n *\n * \\section "
      "range_mapper_ex1 Example\n * \\snippet math_example.cpp range_mapper example\n");

  { // inner classes & enums of RangeMapper_int
    auto pyClassRangeMapper_ClassConfig =
        py::class_<espp::RangeMapper<int>::Config>(
            pyClassRangeMapper_int, "Config", py::dynamic_attr(),
            "*\n   *  @brief Configuration for the input uncentered range with optional\n   *  "
            "values for the centered output range, default values of 0 output center\n   *  and 1 "
            "output range provide a default output range between [-1, 1].\n")
            .def(py::init<>([](int center = int(), int center_deadband = 0, int minimum = int(),
                               int maximum = int(), int range_deadband = 0, int output_center = 0,
                               int output_range = 1, bool invert_output = false) {
                   auto r = std::make_unique<espp::RangeMapper<int>::Config>();
                   r->center = center;
                   r->center_deadband = center_deadband;
                   r->minimum = minimum;
                   r->maximum = maximum;
                   r->range_deadband = range_deadband;
                   r->output_center = output_center;
                   r->output_range = output_range;
                   r->invert_output = invert_output;
                   return r;
                 }),
                 py::arg("center") = int(), py::arg("center_deadband") = 0,
                 py::arg("minimum") = int(), py::arg("maximum") = int(),
                 py::arg("range_deadband") = 0, py::arg("output_center") = 0,
                 py::arg("output_range") = 1, py::arg("invert_output") = false)
            .def_readwrite("center", &espp::RangeMapper<int>::Config::center,
                           "*< Center value for the input range.")
            .def_readwrite("center_deadband", &espp::RangeMapper<int>::Config::center_deadband,
                           "*< Deadband amount around (+-) the center for which output will be 0.")
            .def_readwrite("minimum", &espp::RangeMapper<int>::Config::minimum,
                           "*< Minimum value for the input range.")
            .def_readwrite("maximum", &espp::RangeMapper<int>::Config::maximum,
                           "*< Maximum value for the input range.")
            .def_readwrite("range_deadband", &espp::RangeMapper<int>::Config::range_deadband,
                           "*< Deadband amount around the minimum and maximum for which output "
                           "will\n                             be min/max output.")
            .def_readwrite("output_center", &espp::RangeMapper<int>::Config::output_center,
                           "*< The center for the output. Default 0.")
            .def_readwrite(
                "output_range", &espp::RangeMapper<int>::Config::output_range,
                "*< The range (+/-) from the center for the output. Default 1. @note Will\n        "
                "                     be passed through std::abs() to ensure it is positive.")
            .def_readwrite("invert_output", &espp::RangeMapper<int>::Config::invert_output,
                           "*< Whether to invert the output (default False). @note If True will "
                           "flip the sign\n                  of the output after converting from "
                           "the input distribution.");
  } // end of inner classes & enums of RangeMapper_int

  pyClassRangeMapper_int.def(py::init<>())
      .def("get_center_deadband", &espp::RangeMapper<int>::get_center_deadband,
           "*\n   * @brief Return the configured deadband around the center of the input\n   *     "
           "   distribution\n   * @return Deadband around the center of the input distribution for "
           "this\n   *         range mapper.\n")
      .def("get_minimum", &espp::RangeMapper<int>::get_minimum,
           "*\n   * @brief Return the configured minimum of the input distribution\n   * @return "
           "Minimum of the input distribution for this range mapper.\n")
      .def("get_maximum", &espp::RangeMapper<int>::get_maximum,
           "*\n   * @brief Return the configured maximum of the input distribution\n   * @return "
           "Maximum of the input distribution for this range mapper.\n")
      .def(
          "get_range", &espp::RangeMapper<int>::get_range,
          "*\n   * @brief Return the configured range of the input distribution\n   * @note Always "
          "positive.\n   * @return Range of the input distribution for this range mapper.\n")
      .def("get_range_deadband", &espp::RangeMapper<int>::get_range_deadband,
           "*\n   * @brief Return the configured deadband around the min/max of the input\n   *    "
           "    distribution\n   * @return Deadband around the min/max of the input distribution "
           "for this\n   *         range mapper.\n")
      .def("get_output_center", &espp::RangeMapper<int>::get_output_center,
           "*\n   * @brief Return the configured center of the output distribution\n   * @return "
           "Center of the output distribution for this range mapper.\n")
      .def("get_output_range", &espp::RangeMapper<int>::get_output_range,
           "*\n   * @brief Return the configured range of the output distribution\n   * @note "
           "Always positive.\n   * @return Range of the output distribution for this range "
           "mapper.\n")
      .def("get_output_min", &espp::RangeMapper<int>::get_output_min,
           "*\n   * @brief Return the configured minimum of the output distribution\n   * @return "
           "Minimum of the output distribution for this range mapper.\n")
      .def("get_output_max", &espp::RangeMapper<int>::get_output_max,
           "*\n   * @brief Return the configured maximum of the output distribution\n   * @return "
           "Maximum of the output distribution for this range mapper.\n")
      .def("set_center_deadband", &espp::RangeMapper<int>::set_center_deadband, py::arg("deadband"),
           "*\n   * @brief Set the deadband around the center of the input distribution.\n   * "
           "@param deadband The deadband to use around the center of the input\n   *        "
           "distribution.\n   * @note The deadband must be non-negative.\n   * @note The deadband "
           "is applied around the center value of the input\n   *       distribution.\n")
      .def("set_range_deadband", &espp::RangeMapper<int>::set_range_deadband, py::arg("deadband"),
           "*\n   * @brief Set the deadband around the min/max of the input distribution.\n   * "
           "@param deadband The deadband to use around the min/max of the input\n   *        "
           "distribution.\n   * @note The deadband must be non-negative.\n   * @note The deadband "
           "is applied around the min/max values of the input\n   *       distribution.\n")
      .def("map", &espp::RangeMapper<int>::map, py::arg("v"),
           "*\n   * @brief Map a value \\p v from the input distribution into the configured\n   * "
           "       output range (centered, default [-1,1]).\n   * @param v Value from the "
           "(possibly uncentered and possibly inverted -\n   *        defined by the previously "
           "configured Config) input distribution\n   * @return Value within the centered output "
           "distribution.\n")
      .def("unmap", &espp::RangeMapper<int>::unmap, py::arg("v"),
           "*\n   * @brief Unmap a value \\p v from the configured output range (centered,\n   *   "
           "     default [-1,1]) back into the input distribution.\n   * @param T&v Value from the "
           "centered output distribution.\n   * @return Value within the input distribution.\n");
  auto pyClassRangeMapper_float = py::class_<espp::RangeMapper<float>>(
      m, "RangeMapper_float", py::dynamic_attr(),
      "*\n * @brief Template class for converting a value from an uncentered [minimum,\n *        "
      "maximum] range into a centered output range (default [-1,1]). If\n *        provided a "
      "non-zero deadband, it will convert all values within\n *        [center-deadband, "
      "center+deadband] to be the configured\n *        output_center (default 0).\n *\n *        "
      "The RangeMapper can be optionally configured to invert the input,\n *        so that it "
      "will compute the input w.r.t. the configured min/max of\n *        the input range when "
      "mapping to the output range - this will mean\n *        that a values within the ranges "
      "[minimum, minimum+deadband] and\n *        [maximum-deadband, maximum] will all map to the "
      "output_center and\n *        the input center will map to both output_max and output_min\n "
      "*        depending on the sign of the input.\n *\n * @note When inverting the input range, "
      "you are introducing a discontinuity\n *       between the input distribution and the output "
      "distribution at the\n *       input center. Noise around the input's center value will "
      "create\n *       oscillations in the output which will jump between output maximum\n *      "
      " and output minimum. Therefore it is advised to use \\p invert_input\n *       sparignly, "
      "and to set the values robustly.\n *\n *        The RangeMapper can be optionally configured "
      "to invert the output,\n *        so that after converting from the input range to the "
      "output range,\n *        it will flip the sign on the output.\n *\n * \\section "
      "range_mapper_ex1 Example\n * \\snippet math_example.cpp range_mapper example\n");

  { // inner classes & enums of RangeMapper_float
    auto pyClassRangeMapper_ClassConfig =
        py::class_<espp::RangeMapper<float>::Config>(
            pyClassRangeMapper_float, "Config", py::dynamic_attr(),
            "*\n   *  @brief Configuration for the input uncentered range with optional\n   *  "
            "values for the centered output range, default values of 0 output center\n   *  and 1 "
            "output range provide a default output range between [-1, 1].\n")
            .def(py::init<>([](float center = float(), float center_deadband = 0,
                               float minimum = float(), float maximum = float(),
                               float range_deadband = 0, float output_center = 0,
                               float output_range = 1, bool invert_output = false) {
                   auto r = std::make_unique<espp::RangeMapper<float>::Config>();
                   r->center = center;
                   r->center_deadband = center_deadband;
                   r->minimum = minimum;
                   r->maximum = maximum;
                   r->range_deadband = range_deadband;
                   r->output_center = output_center;
                   r->output_range = output_range;
                   r->invert_output = invert_output;
                   return r;
                 }),
                 py::arg("center") = float(), py::arg("center_deadband") = 0,
                 py::arg("minimum") = float(), py::arg("maximum") = float(),
                 py::arg("range_deadband") = 0, py::arg("output_center") = 0,
                 py::arg("output_range") = 1, py::arg("invert_output") = false)
            .def_readwrite("center", &espp::RangeMapper<float>::Config::center,
                           "*< Center value for the input range.")
            .def_readwrite("center_deadband", &espp::RangeMapper<float>::Config::center_deadband,
                           "*< Deadband amount around (+-) the center for which output will be 0.")
            .def_readwrite("minimum", &espp::RangeMapper<float>::Config::minimum,
                           "*< Minimum value for the input range.")
            .def_readwrite("maximum", &espp::RangeMapper<float>::Config::maximum,
                           "*< Maximum value for the input range.")
            .def_readwrite("range_deadband", &espp::RangeMapper<float>::Config::range_deadband,
                           "*< Deadband amount around the minimum and maximum for which output "
                           "will\n                             be min/max output.")
            .def_readwrite("output_center", &espp::RangeMapper<float>::Config::output_center,
                           "*< The center for the output. Default 0.")
            .def_readwrite(
                "output_range", &espp::RangeMapper<float>::Config::output_range,
                "*< The range (+/-) from the center for the output. Default 1. @note Will\n        "
                "                     be passed through std::abs() to ensure it is positive.")
            .def_readwrite("invert_output", &espp::RangeMapper<float>::Config::invert_output,
                           "*< Whether to invert the output (default False). @note If True will "
                           "flip the sign\n                  of the output after converting from "
                           "the input distribution.");
  } // end of inner classes & enums of RangeMapper_float

  pyClassRangeMapper_float.def(py::init<>())
      .def("get_center_deadband", &espp::RangeMapper<float>::get_center_deadband,
           "*\n   * @brief Return the configured deadband around the center of the input\n   *     "
           "   distribution\n   * @return Deadband around the center of the input distribution for "
           "this\n   *         range mapper.\n")
      .def("get_minimum", &espp::RangeMapper<float>::get_minimum,
           "*\n   * @brief Return the configured minimum of the input distribution\n   * @return "
           "Minimum of the input distribution for this range mapper.\n")
      .def("get_maximum", &espp::RangeMapper<float>::get_maximum,
           "*\n   * @brief Return the configured maximum of the input distribution\n   * @return "
           "Maximum of the input distribution for this range mapper.\n")
      .def(
          "get_range", &espp::RangeMapper<float>::get_range,
          "*\n   * @brief Return the configured range of the input distribution\n   * @note Always "
          "positive.\n   * @return Range of the input distribution for this range mapper.\n")
      .def("get_range_deadband", &espp::RangeMapper<float>::get_range_deadband,
           "*\n   * @brief Return the configured deadband around the min/max of the input\n   *    "
           "    distribution\n   * @return Deadband around the min/max of the input distribution "
           "for this\n   *         range mapper.\n")
      .def("get_output_center", &espp::RangeMapper<float>::get_output_center,
           "*\n   * @brief Return the configured center of the output distribution\n   * @return "
           "Center of the output distribution for this range mapper.\n")
      .def("get_output_range", &espp::RangeMapper<float>::get_output_range,
           "*\n   * @brief Return the configured range of the output distribution\n   * @note "
           "Always positive.\n   * @return Range of the output distribution for this range "
           "mapper.\n")
      .def("get_output_min", &espp::RangeMapper<float>::get_output_min,
           "*\n   * @brief Return the configured minimum of the output distribution\n   * @return "
           "Minimum of the output distribution for this range mapper.\n")
      .def("get_output_max", &espp::RangeMapper<float>::get_output_max,
           "*\n   * @brief Return the configured maximum of the output distribution\n   * @return "
           "Maximum of the output distribution for this range mapper.\n")
      .def("set_center_deadband", &espp::RangeMapper<float>::set_center_deadband,
           py::arg("deadband"),
           "*\n   * @brief Set the deadband around the center of the input distribution.\n   * "
           "@param deadband The deadband to use around the center of the input\n   *        "
           "distribution.\n   * @note The deadband must be non-negative.\n   * @note The deadband "
           "is applied around the center value of the input\n   *       distribution.\n")
      .def("set_range_deadband", &espp::RangeMapper<float>::set_range_deadband, py::arg("deadband"),
           "*\n   * @brief Set the deadband around the min/max of the input distribution.\n   * "
           "@param deadband The deadband to use around the min/max of the input\n   *        "
           "distribution.\n   * @note The deadband must be non-negative.\n   * @note The deadband "
           "is applied around the min/max values of the input\n   *       distribution.\n")
      .def("map", &espp::RangeMapper<float>::map, py::arg("v"),
           "*\n   * @brief Map a value \\p v from the input distribution into the configured\n   * "
           "       output range (centered, default [-1,1]).\n   * @param v Value from the "
           "(possibly uncentered and possibly inverted -\n   *        defined by the previously "
           "configured Config) input distribution\n   * @return Value within the centered output "
           "distribution.\n")
      .def("unmap", &espp::RangeMapper<float>::unmap, py::arg("v"),
           "*\n   * @brief Unmap a value \\p v from the configured output range (centered,\n   *   "
           "     default [-1,1]) back into the input distribution.\n   * @param T&v Value from the "
           "centered output distribution.\n   * @return Value within the input distribution.\n");
  ////////////////////    </generated_from:range_mapper.hpp>    ////////////////////

  ////////////////////    <generated_from:vector2d.hpp>    ////////////////////
  auto pyClassVector2d_int =
      py::class_<espp::Vector2d<int>>(
          m, "Vector2d_int", py::dynamic_attr(),
          "*\n * @brief Container representing a 2 dimensional vector.\n *\n * Provides "
          "getters/setters, index operator, and vector / scalar math\n * utilities.\n *\n * "
          "\\section vector_ex1 Example\n * \\snippet math_example.cpp vector2 example\n")
          .def(py::init<int, int>(), py::arg("x") = 0, py::arg("y") = 0,
               "*\n   * @brief Constructor for the vector, defaults to 0,0.\n   * @param x The "
               "starting X value.\n   * @param y The starting Y value.\n")
          .def(py::init<const espp::Vector2d<int> &>(), py::arg("other"),
               "*\n   * @brief Vector copy constructor.\n   * @param other Vector to copy.\n")
          .def("magnitude", &espp::Vector2d<int>::magnitude,
               "*\n   * @brief Returns vector magnitude: ||v||.\n   * @return The magnitude.\n")
          .def("magnitude_squared", &espp::Vector2d<int>::magnitude_squared,
               "*\n   * @brief Returns vector magnitude squared: ||v||^2.\n   * @return The "
               "magnitude squared.\n")
          .def(
              "x", [](espp::Vector2d<int> &self) { return self.x(); },
              "*\n   * @brief Getter for the x value.\n   * @return The current x value.\n")
          .def("x", py::overload_cast<int>(&espp::Vector2d<int>::x), py::arg("v"),
               "*\n   * @brief Setter for the x value.\n   * @param v New value for \\c x.\n")
          .def(
              "y", [](espp::Vector2d<int> &self) { return self.y(); },
              "*\n   * @brief Getter for the y value.\n   * @return The current y value.\n")
          .def("y", py::overload_cast<int>(&espp::Vector2d<int>::y), py::arg("v"),
               "*\n   * @brief Setter for the y value.\n   * @param v New value for \\c y.\n")
          .def(
              "__lt__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) < 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__le__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) <= 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__eq__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) == 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__ge__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) >= 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__gt__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) > 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def("__eq__", &espp::Vector2d<int>::operator==, py::arg("other"),
               "*\n   * @brief Equality operator for comparing two vectors.\n   * @param other The "
               "vector to compare against.\n   * @return True if the vectors are equal, False "
               "otherwise.\n")
          .def("__getitem__", &espp::Vector2d<int>::operator[], py::arg("index"),
               "*\n   * @brief Index operator for vector elements.\n   * @note Returns a mutable "
               "reference to the element.\n   * @param index The index to return.\n   * @return "
               "Mutable reference to the element at \\p index.\n")
          .def(
              "__neg__", [](espp::Vector2d<int> &self) { return self.operator-(); },
              "*\n   * @brief Negate the vector.\n   * @return The new vector which is the "
              "negative.\n")
          .def("__sub__",
               py::overload_cast<const espp::Vector2d<int> &>(&espp::Vector2d<int>::operator-,
                                                              py::const_),
               py::arg("rhs"),
               "*\n   * @brief Return a new vector which is the provided vector subtracted from\n  "
               " *        this vector.\n   * @param rhs The vector to subtract from this vector.\n "
               "  * @return Resultant vector subtraction.\n")
          .def("__isub__", &espp::Vector2d<int>::operator-=, py::arg("rhs"),
               "*\n   * @brief Return the provided vector subtracted from this vector.\n   * "
               "@param rhs The vector to subtract from this vector.\n   * @return Resultant vector "
               "subtraction.\n")
          .def("__add__", &espp::Vector2d<int>::operator+, py::arg("rhs"),
               "*\n   * @brief Return a new vector, which is the addition of this vector and the\n "
               "  *        provided vector.\n   * @param rhs The vector to add to this vector.\n   "
               "* @return Resultant vector addition.\n")
          .def("__iadd__", &espp::Vector2d<int>::operator+=, py::arg("rhs"),
               "*\n   * @brief Return the vector added with the provided vector.\n   * @param rhs "
               "The vector to add to this vector.\n   * @return Resultant vector addition.\n")
          .def("__mul__", &espp::Vector2d<int>::operator*, py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, multiplied by the provided\n "
               "  *        value.\n   * @param v Value the vector should be multiplied by.\n   * "
               "@return Resultant scaled vector.\n")
          .def("__imul__", &espp::Vector2d<int>::operator*=, py::arg("v"),
               "*\n   * @brief Return the vector multiplied by the provided value.\n   * @param v "
               "Value the vector should be scaled by.\n   * @return Resultant scaled vector.\n")
          .def("__truediv__",
               py::overload_cast<const int &>(&espp::Vector2d<int>::operator/, py::const_),
               py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, divided by the provided\n   "
               "*        value.\n   * @param v Value the vector should be divided by.\n   * "
               "@return Resultant scaled vector.\n")
          .def("__itruediv__", py::overload_cast<const int &>(&espp::Vector2d<int>::operator/=),
               py::arg("v"),
               "*\n   * @brief Return the vector divided by the provided value.\n   * @param v "
               "Value the vector should be divided by.\n   * @return Resultant scaled vector.\n")
          .def("__truediv__",
               py::overload_cast<const espp::Vector2d<int> &>(&espp::Vector2d<int>::operator/,
                                                              py::const_),
               py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, divided by the provided\n   "
               "*        vector value. Scales x and y independently.\n   * @param v Vector values "
               "the vector should be divided by.\n   * @return Resultant scaled vector.\n")
          .def("__itruediv__",
               py::overload_cast<const espp::Vector2d<int> &>(&espp::Vector2d<int>::operator/=),
               py::arg("v"),
               "*\n   * @brief Return the vector divided by the provided vector values.\n   * "
               "@param v Vector of values the vector should be divided by.\n   * @return Resultant "
               "scaled vector.\n")
          .def("dot", &espp::Vector2d<int>::dot, py::arg("other"),
               "*\n   * @brief Dot product of this vector with another vector.\n   * @param other "
               "The second vector\n   * @return The dot product (x1*x2 + y1*y2)\n")
          .def("normalized", &espp::Vector2d<int>::normalized,
               "*\n   * @brief Return normalized (unit length) version of the vector.\n   * "
               "@return The normalized vector.\n");
  auto pyClassVector2d_float =
      py::class_<espp::Vector2d<float>>(
          m, "Vector2d_float", py::dynamic_attr(),
          "*\n * @brief Container representing a 2 dimensional vector.\n *\n * Provides "
          "getters/setters, index operator, and vector / scalar math\n * utilities.\n *\n * "
          "\\section vector_ex1 Example\n * \\snippet math_example.cpp vector2 example\n")
          .def(py::init<float, float>(), py::arg("x") = 0, py::arg("y") = 0,
               "*\n   * @brief Constructor for the vector, defaults to 0,0.\n   * @param x The "
               "starting X value.\n   * @param y The starting Y value.\n")
          .def(py::init<const espp::Vector2d<float> &>(), py::arg("other"),
               "*\n   * @brief Vector copy constructor.\n   * @param other Vector to copy.\n")
          .def("magnitude", &espp::Vector2d<float>::magnitude,
               "*\n   * @brief Returns vector magnitude: ||v||.\n   * @return The magnitude.\n")
          .def("magnitude_squared", &espp::Vector2d<float>::magnitude_squared,
               "*\n   * @brief Returns vector magnitude squared: ||v||^2.\n   * @return The "
               "magnitude squared.\n")
          .def(
              "x", [](espp::Vector2d<float> &self) { return self.x(); },
              "*\n   * @brief Getter for the x value.\n   * @return The current x value.\n")
          .def("x", py::overload_cast<float>(&espp::Vector2d<float>::x), py::arg("v"),
               "*\n   * @brief Setter for the x value.\n   * @param v New value for \\c x.\n")
          .def(
              "y", [](espp::Vector2d<float> &self) { return self.y(); },
              "*\n   * @brief Getter for the y value.\n   * @return The current y value.\n")
          .def("y", py::overload_cast<float>(&espp::Vector2d<float>::y), py::arg("v"),
               "*\n   * @brief Setter for the y value.\n   * @param v New value for \\c y.\n")
          .def(
              "__lt__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) < 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__le__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) <= 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__eq__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) == 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__ge__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) >= 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__gt__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) > 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def("__eq__", &espp::Vector2d<float>::operator==, py::arg("other"),
               "*\n   * @brief Equality operator for comparing two vectors.\n   * @param other The "
               "vector to compare against.\n   * @return True if the vectors are equal, False "
               "otherwise.\n")
          .def("__getitem__", &espp::Vector2d<float>::operator[], py::arg("index"),
               "*\n   * @brief Index operator for vector elements.\n   * @note Returns a mutable "
               "reference to the element.\n   * @param index The index to return.\n   * @return "
               "Mutable reference to the element at \\p index.\n")
          .def(
              "__neg__", [](espp::Vector2d<float> &self) { return self.operator-(); },
              "*\n   * @brief Negate the vector.\n   * @return The new vector which is the "
              "negative.\n")
          .def("__sub__",
               py::overload_cast<const espp::Vector2d<float> &>(&espp::Vector2d<float>::operator-,
                                                                py::const_),
               py::arg("rhs"),
               "*\n   * @brief Return a new vector which is the provided vector subtracted from\n  "
               " *        this vector.\n   * @param rhs The vector to subtract from this vector.\n "
               "  * @return Resultant vector subtraction.\n")
          .def("__isub__", &espp::Vector2d<float>::operator-=, py::arg("rhs"),
               "*\n   * @brief Return the provided vector subtracted from this vector.\n   * "
               "@param rhs The vector to subtract from this vector.\n   * @return Resultant vector "
               "subtraction.\n")
          .def("__add__", &espp::Vector2d<float>::operator+, py::arg("rhs"),
               "*\n   * @brief Return a new vector, which is the addition of this vector and the\n "
               "  *        provided vector.\n   * @param rhs The vector to add to this vector.\n   "
               "* @return Resultant vector addition.\n")
          .def("__iadd__", &espp::Vector2d<float>::operator+=, py::arg("rhs"),
               "*\n   * @brief Return the vector added with the provided vector.\n   * @param rhs "
               "The vector to add to this vector.\n   * @return Resultant vector addition.\n")
          .def("__mul__", &espp::Vector2d<float>::operator*, py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, multiplied by the provided\n "
               "  *        value.\n   * @param v Value the vector should be multiplied by.\n   * "
               "@return Resultant scaled vector.\n")
          .def("__imul__", &espp::Vector2d<float>::operator*=, py::arg("v"),
               "*\n   * @brief Return the vector multiplied by the provided value.\n   * @param v "
               "Value the vector should be scaled by.\n   * @return Resultant scaled vector.\n")
          .def("__truediv__",
               py::overload_cast<const float &>(&espp::Vector2d<float>::operator/, py::const_),
               py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, divided by the provided\n   "
               "*        value.\n   * @param v Value the vector should be divided by.\n   * "
               "@return Resultant scaled vector.\n")
          .def("__itruediv__", py::overload_cast<const float &>(&espp::Vector2d<float>::operator/=),
               py::arg("v"),
               "*\n   * @brief Return the vector divided by the provided value.\n   * @param v "
               "Value the vector should be divided by.\n   * @return Resultant scaled vector.\n")
          .def("__truediv__",
               py::overload_cast<const espp::Vector2d<float> &>(&espp::Vector2d<float>::operator/,
                                                                py::const_),
               py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, divided by the provided\n   "
               "*        vector value. Scales x and y independently.\n   * @param v Vector values "
               "the vector should be divided by.\n   * @return Resultant scaled vector.\n")
          .def("__itruediv__",
               py::overload_cast<const espp::Vector2d<float> &>(&espp::Vector2d<float>::operator/=),
               py::arg("v"),
               "*\n   * @brief Return the vector divided by the provided vector values.\n   * "
               "@param v Vector of values the vector should be divided by.\n   * @return Resultant "
               "scaled vector.\n")
          .def("dot", &espp::Vector2d<float>::dot, py::arg("other"),
               "*\n   * @brief Dot product of this vector with another vector.\n   * @param other "
               "The second vector\n   * @return The dot product (x1*x2 + y1*y2)\n")
          .def("normalized", &espp::Vector2d<float>::normalized,
               "*\n   * @brief Return normalized (unit length) version of the vector.\n   * "
               "@return The normalized vector.\n");
  ////////////////////    </generated_from:vector2d.hpp>    ////////////////////

  ////////////////////    <generated_from:ndef.hpp>    ////////////////////
  auto pyClassNdef = py::class_<espp::Ndef>(
      m, "Ndef", py::dynamic_attr(),
      "*\n * @brief implements serialization & deserialization logic for NFC Data\n *        "
      "Exchange Format (NDEF) records which can be stored on and\n *        transmitted from NFC "
      "devices.\n *\n * @details NDEF records can be composed the following way:\n *   "
      "@code{.unparsed}\n *   Bit 7     6       5       4       3       2       1       0\n *   "
      "------  ------  ------  ------  ------  ------  ------  ------\n *   [ MB ]  [ ME ]  [ CF ] "
      " [ SR ]  [ IL ]  [        TNF         ]\n *   [                         TYPE LENGTH  (may "
      "be 0)            ]\n *   [                       PAYLOAD LENGTH (1B or 4B, see SR)    ]\n * "
      "  [                          ID LENGTH   (if IL)               ]\n *   [                    "
      "     RECORD TYPE  (if TYPE LENGTH > 0)  ]\n *   [                              ID      (if "
      "IL)               ]\n *   [                           PAYLOAD    (payload length bytes)]\n "
      "*  @endcode\n *\n *  The first byte (Flags) has these bits:\n *  * Bits 0-3: TNF - Type "
      "Name Format - describes record type (see TNF class)\n *  * Bit 3: IL - ID Length - "
      "indicates if the ID Length Field is present or not\n *  * Bit 4: SR - Short Record - set to "
      "1 if the payload length field is 1 byte (8\n *      bits / 0-255) or less, otherwise the "
      "payload length is 4 bytes\n *  * Bit 5: CF - Chunk Flag - indicates if this is the first "
      "record chunk or a\n *      middle record chunk, set to 0 for the first record of the "
      "message and\n *      for subsequent records set to 1.\n *  * Bit 6: ME - Message End - 1 "
      "indicates if this is the last record in the\n *      message\n *  * Bit 7: MB - Message "
      "Begin - 1 indicates if this is the first record in the\n *      message\n *\n * @note Some "
      "information about NDEF can be found:\n *       * "
      "https://www.maskaravivek.com/post/understanding-the-format-of-ndef-messages/\n *       * "
      "https://ndeflib.readthedocs.io/en/stable/records/bluetooth.html\n *       * "
      "https://developer.android.com/reference/android/nfc/NdefMessage\n *       * "
      "https://www.oreilly.com/library/view/beginning-nfc/9781449324094/ch04.html\n *       * "
      "https://learn.adafruit.com/adafruit-pn532-rfid-nfc/ndef\n *\n");

  { // inner classes & enums of Ndef
    auto pyEnumTNF =
        py::enum_<espp::Ndef::TNF>(
            pyClassNdef, "TNF", py::arithmetic(),
            "*\n   * @brief Type Name Format (TNF) field is a 3-bit value that describes the\n   * "
            "       record type.\n   *\n   * Some Common TNF::WELL_KNOWN record type strings:\n   "
            "*   * Text (T)\n   *   * URI  (U)\n   *   * Smart Poster (Sp)\n   *   * Alternative "
            "Carrier (ac)\n   *   * Handover Carrier (Hc)\n   *   * Handover Request (Hr)\n   *   "
            "* Handover Select (Hs)\n")
            .value("empty", espp::Ndef::TNF::EMPTY, "/< Record is empty")
            .value("well_known", espp::Ndef::TNF::WELL_KNOWN,
                   "/< Type field contains a well-known RTD type name")
            .value("mime_media", espp::Ndef::TNF::MIME_MEDIA,
                   "/< Type field contains a media type (RFC 2046)")
            .value("absolute_uri", espp::Ndef::TNF::ABSOLUTE_URI,
                   "/< Type field contains an absolute URI (RFC 3986)")
            .value("external_type", espp::Ndef::TNF::EXTERNAL_TYPE,
                   "/< Type field Contains an external type name")
            .value("unknown", espp::Ndef::TNF::UNKNOWN,
                   "/< Payload type is unknown, type length must be 0.")
            .value("unchanged", espp::Ndef::TNF::UNCHANGED,
                   "/< Indicates the payload is an intermediate or final chunk of a chunked NDEF")
            .value("reserved", espp::Ndef::TNF::RESERVED,
                   "/< Reserved by the NFC forum for future use");
    auto pyEnumUic =
        py::enum_<espp::Ndef::Uic>(
            pyClassNdef, "Uic", py::arithmetic(),
            "*\n   * URI Identifier Codes (UIC), See Table A-3 at\n   * "
            "https://www.oreilly.com/library/view/beginning-nfc/9781449324094/apa.html\n   * and "
            "https://learn.adafruit.com/adafruit-pn532-rfid-nfc/ndef\n")
            .value("none", espp::Ndef::Uic::NONE, "/< Exactly as written")
            .value("http_www", espp::Ndef::Uic::HTTP_WWW, "/< http://www.")
            .value("https_www", espp::Ndef::Uic::HTTPS_WWW, "/< https://www.")
            .value("http", espp::Ndef::Uic::HTTP, "/< http://")
            .value("https", espp::Ndef::Uic::HTTPS, "/< https://")
            .value("tel", espp::Ndef::Uic::TEL, "/< tel:")
            .value("mailto", espp::Ndef::Uic::MAILTO, "/< mailto:")
            .value("ftp_anon", espp::Ndef::Uic::FTP_ANON, "/< ftp://anonymous:anonymous@")
            .value("ftp_ftp", espp::Ndef::Uic::FTP_FTP, "/< ftp://ftp.")
            .value("ftps", espp::Ndef::Uic::FTPS, "/< ftps://")
            .value("sftp", espp::Ndef::Uic::SFTP, "/< sftp://")
            .value("smb", espp::Ndef::Uic::SMB, "/< smb://")
            .value("nfs", espp::Ndef::Uic::NFS, "/< nfs://")
            .value("ftp", espp::Ndef::Uic::FTP, "/< ftp://")
            .value("dav", espp::Ndef::Uic::DAV, "/< dav://")
            .value("news", espp::Ndef::Uic::NEWS, "/< news:")
            .value("telnet", espp::Ndef::Uic::TELNET, "/< telnet://")
            .value("imap", espp::Ndef::Uic::IMAP, "/< imap:")
            .value("rstp", espp::Ndef::Uic::RSTP, "/< rtsp://")
            .value("urn", espp::Ndef::Uic::URN, "/< urn:")
            .value("pop", espp::Ndef::Uic::POP, "/< pop:")
            .value("sip", espp::Ndef::Uic::SIP, "/< sip:")
            .value("sips", espp::Ndef::Uic::SIPS, "/< sips:")
            .value("tftp", espp::Ndef::Uic::TFTP, "/< tftp:")
            .value("btspp", espp::Ndef::Uic::BTSPP, "/< btspp://")
            .value("btl2_cap", espp::Ndef::Uic::BTL2CAP, "/< btl2cap://")
            .value("btgoep", espp::Ndef::Uic::BTGOEP, "/< btgoep://")
            .value("tcpobex", espp::Ndef::Uic::TCPOBEX, "/< tcpobex://")
            .value("irdaobex", espp::Ndef::Uic::IRDAOBEX, "/< irdaobex://")
            .value("file", espp::Ndef::Uic::FILE, "/< file://")
            .value("urn_epc_id", espp::Ndef::Uic::URN_EPC_ID, "/< urn:epc:id:")
            .value("urn_epc_tag", espp::Ndef::Uic::URN_EPC_TAG, "/< urn:epc:tag:")
            .value("urn_epc_pat", espp::Ndef::Uic::URN_EPC_PAT, "/< urn:epc:pat:")
            .value("urn_epc_raw", espp::Ndef::Uic::URN_EPC_RAW, "/< urn:epc:raw:")
            .value("urn_epc", espp::Ndef::Uic::URN_EPC, "/< urn:epc:")
            .value("urn_nfc", espp::Ndef::Uic::URN_NFC, "/< urn:nfc:");
    auto pyEnumBtType = py::enum_<espp::Ndef::BtType>(pyClassNdef, "BtType", py::arithmetic(),
                                                      "*\n   * @brief Type of Bluetooth radios.\n")
                            .value("bredr", espp::Ndef::BtType::BREDR, "/< BT Classic")
                            .value("ble", espp::Ndef::BtType::BLE, "/< BT Low Energy");
    auto pyEnumBtAppearance =
        py::enum_<espp::Ndef::BtAppearance>(
            pyClassNdef, "BtAppearance", py::arithmetic(),
            "*\n   * @brief Some appearance codes for BLE radios.\n")
            .value("unknown", espp::Ndef::BtAppearance::UNKNOWN, "/< Generic Unknown")
            .value("phone", espp::Ndef::BtAppearance::PHONE, "/< Generic Phone")
            .value("computer", espp::Ndef::BtAppearance::COMPUTER, "/< Generic Computer")
            .value("watch", espp::Ndef::BtAppearance::WATCH, "/< Generic Watch")
            .value("clock", espp::Ndef::BtAppearance::CLOCK, "/< Generic Clock")
            .value("display", espp::Ndef::BtAppearance::DISPLAY, "/< Generic Display")
            .value("remote_control", espp::Ndef::BtAppearance::REMOTE_CONTROL,
                   "/< Generic Remote Control")
            .value("generic_hid", espp::Ndef::BtAppearance::GENERIC_HID, "/< Generic HID")
            .value("keyboard", espp::Ndef::BtAppearance::KEYBOARD, "/< HID Keyboard")
            .value("mouse", espp::Ndef::BtAppearance::MOUSE, "/< HID Mouse")
            .value("joystick", espp::Ndef::BtAppearance::JOYSTICK, "/< HID Joystick")
            .value("gamepad", espp::Ndef::BtAppearance::GAMEPAD, "/< HID Gamepad")
            .value("touchpad", espp::Ndef::BtAppearance::TOUCHPAD, "/< HID Touchpad")
            .value("gaming", espp::Ndef::BtAppearance::GAMING, "/< Generic Gaming group");
    auto pyEnumCarrierPowerState =
        py::enum_<espp::Ndef::CarrierPowerState>(
            pyClassNdef, "CarrierPowerState", py::arithmetic(),
            "*\n   * @brief Power state of a BLE radio.\n   * @details Representation of the "
            "carrier power state in a Handover Select\n   *          message.\n")
            .value("inactive", espp::Ndef::CarrierPowerState::INACTIVE, "/< Carrier power is off")
            .value("active", espp::Ndef::CarrierPowerState::ACTIVE, "/< Carrier power is on")
            .value("activating", espp::Ndef::CarrierPowerState::ACTIVATING,
                   "/< Carrier power is turning on")
            .value("unknown", espp::Ndef::CarrierPowerState::UNKNOWN,
                   "/< Carrier power state is unknown");
    auto pyEnumBtEir =
        py::enum_<espp::Ndef::BtEir>(
            pyClassNdef, "BtEir", py::arithmetic(),
            "*\n   * @brief Extended Inquiry Response (EIR) codes for data types in BT and BLE\n   "
            "*        out of band (OOB) pairing NDEF records.\n")
            .value(
                "flags", espp::Ndef::BtEir::FLAGS,
                "/< BT flags: b0: LE limited discoverable mode, b1: LE general discoverable mode,")
            .value("uuids_16_bit_partial", espp::Ndef::BtEir::UUIDS_16_BIT_PARTIAL,
                   "/< Incomplete list of 16 bit service class UUIDs")
            .value("uuids_16_bit_complete", espp::Ndef::BtEir::UUIDS_16_BIT_COMPLETE,
                   "/< Complete list of 16 bit service class UUIDs")
            .value("uuids_32_bit_partial", espp::Ndef::BtEir::UUIDS_32_BIT_PARTIAL,
                   "/< Incomplete list of 32 bit service class UUIDs")
            .value("uuids_32_bit_complete", espp::Ndef::BtEir::UUIDS_32_BIT_COMPLETE,
                   "/< Complete list of 32 bit service class UUIDs")
            .value("uuids_128_bit_partial", espp::Ndef::BtEir::UUIDS_128_BIT_PARTIAL,
                   "/< Incomplete list of 128 bit service class UUIDs")
            .value("uuids_128_bit_complete", espp::Ndef::BtEir::UUIDS_128_BIT_COMPLETE,
                   "/< Complete list of 128 bit service class UUIDs")
            .value("short_local_name", espp::Ndef::BtEir::SHORT_LOCAL_NAME,
                   "/< Shortened Bluetooth Local Name")
            .value("long_local_name", espp::Ndef::BtEir::LONG_LOCAL_NAME,
                   "/< Complete Bluetooth Local Name")
            .value("tx_power_level", espp::Ndef::BtEir::TX_POWER_LEVEL,
                   "/< TX Power level (1 byte), -127 dBm to +127 dBm")
            .value("class_of_device", espp::Ndef::BtEir::CLASS_OF_DEVICE, "/< Class of Device")
            .value("sp_hash_c192", espp::Ndef::BtEir::SP_HASH_C192, "/< Simple Pairing Hash C-192")
            .value("sp_random_r192", espp::Ndef::BtEir::SP_RANDOM_R192,
                   "/< Simple Pairing Randomizer R-192")
            .value("security_manager_tk", espp::Ndef::BtEir::SECURITY_MANAGER_TK,
                   "/< Security Manager TK Value (LE Legacy Pairing)")
            .value("security_manager_flags", espp::Ndef::BtEir::SECURITY_MANAGER_FLAGS,
                   "/< Flags (1 B), b0: OOB flags field (1 = 00B data present, 0 not), b1: LE "
                   "Supported")
            .value("appearance", espp::Ndef::BtEir::APPEARANCE, "/< Appearance")
            .value("mac", espp::Ndef::BtEir::MAC, "/< Bluetooth Device Address")
            .value("le_role", espp::Ndef::BtEir::LE_ROLE, "/< LE Role")
            .value("sp_hash_c256", espp::Ndef::BtEir::SP_HASH_C256, "/< Simple Pairing Hash C-256")
            .value("sp_hash_r256", espp::Ndef::BtEir::SP_HASH_R256,
                   "/< Simple Pairing Randomizer R-256")
            .value("le_sc_confirmation", espp::Ndef::BtEir::LE_SC_CONFIRMATION,
                   "/< LE Secure Connections Confirmation Value")
            .value("le_sc_random", espp::Ndef::BtEir::LE_SC_RANDOM,
                   "/< LE Secure Connections Random Value");
    auto pyEnumBleRole =
        py::enum_<espp::Ndef::BleRole>(
            pyClassNdef, "BleRole", py::arithmetic(),
            "*\n   * @brief Possible roles for BLE records to indicate support for.\n")
            .value("peripheral_only", espp::Ndef::BleRole::PERIPHERAL_ONLY,
                   "/< Radio can only act as a peripheral")
            .value("central_only", espp::Ndef::BleRole::CENTRAL_ONLY,
                   "/< Radio can only act as a central")
            .value("peripheral_central", espp::Ndef::BleRole::PERIPHERAL_CENTRAL,
                   "/< Radio can act as both a peripheral and a central, but prefers peripheral")
            .value("central_peripheral", espp::Ndef::BleRole::CENTRAL_PERIPHERAL,
                   "/< Radio can act as both a peripheral and a central, but prefers central");
    auto pyEnumWifiEncryptionType =
        py::enum_<espp::Ndef::WifiEncryptionType>(
            pyClassNdef, "WifiEncryptionType", py::arithmetic(),
            "*\n   * @brief Types of configurable encryption for WiFi networks\n")
            .value("none", espp::Ndef::WifiEncryptionType::NONE, "/< No encryption")
            .value("wep", espp::Ndef::WifiEncryptionType::WEP, "/< WEP")
            .value("tkip", espp::Ndef::WifiEncryptionType::TKIP, "/< TKIP")
            .value("aes", espp::Ndef::WifiEncryptionType::AES, "/< AES");
    auto pyEnumWifiAuthenticationType =
        py::enum_<espp::Ndef::WifiAuthenticationType>(
            pyClassNdef, "WifiAuthenticationType", py::arithmetic(),
            "*\n   * @brief WiFi network authentication\n")
            .value("open", espp::Ndef::WifiAuthenticationType::OPEN, "/< Open / no security")
            .value("wpa_personal", espp::Ndef::WifiAuthenticationType::WPA_PERSONAL,
                   "/< WPA personal")
            .value("shared", espp::Ndef::WifiAuthenticationType::SHARED, "/< Shared key")
            .value("wpa_enterprise", espp::Ndef::WifiAuthenticationType::WPA_ENTERPRISE,
                   "/< WPA enterprise")
            .value("wpa2_enterprise", espp::Ndef::WifiAuthenticationType::WPA2_ENTERPRISE,
                   "/< WPA2 Enterprise")
            .value("wpa2_personal", espp::Ndef::WifiAuthenticationType::WPA2_PERSONAL,
                   "/< WPA2 personal")
            .value("wpa_wpa2_personal", espp::Ndef::WifiAuthenticationType::WPA_WPA2_PERSONAL,
                   "/< Both WPA and WPA2 personal");
    auto pyClassNdef_ClassWifiConfig =
        py::class_<espp::Ndef::WifiConfig>(
            pyClassNdef, "WifiConfig", py::dynamic_attr(),
            "*\n   * @brief Configuration structure for wifi configuration ndef structure.\n")
            .def(py::init<>([](std::string_view ssid = std::string_view(),
                               std::string_view key = std::string_view(),
                               espp::Ndef::WifiAuthenticationType authentication =
                                   espp::Ndef::WifiAuthenticationType::WPA2_PERSONAL,
                               espp::Ndef::WifiEncryptionType encryption =
                                   espp::Ndef::WifiEncryptionType::AES,
                               uint64_t mac_address = 0xFFFFFFFFFFFF) {
                   auto r = std::make_unique<espp::Ndef::WifiConfig>();
                   r->ssid = ssid;
                   r->key = key;
                   r->authentication = authentication;
                   r->encryption = encryption;
                   r->mac_address = mac_address;
                   return r;
                 }),
                 py::arg("ssid") = std::string_view(), py::arg("key") = std::string_view(),
                 py::arg("authentication") = espp::Ndef::WifiAuthenticationType::WPA2_PERSONAL,
                 py::arg("encryption") = espp::Ndef::WifiEncryptionType::AES,
                 py::arg("mac_address") = 0xFFFFFFFFFFFF)
            .def_readwrite("ssid", &espp::Ndef::WifiConfig::ssid, "/< SSID for the network")
            .def_readwrite("key", &espp::Ndef::WifiConfig::key,
                           "/< Security key / password for the network")
            .def_readwrite("authentication", &espp::Ndef::WifiConfig::authentication,
                           "/< Authentication type the network")
            .def_readwrite("encryption", &espp::Ndef::WifiConfig::encryption,
                           "/< Encryption type the network uses.")
            .def_readwrite("mac_address", &espp::Ndef::WifiConfig::mac_address,
                           "/< Broadcast MAC address FF:FF:FF:FF:FF:FF");
  } // end of inner classes & enums of Ndef

  pyClassNdef
      .def_readonly_static("handover_version", &espp::Ndef::HANDOVER_VERSION,
                           "/< Connection Handover version 1.3")
      .def(py::init<espp::Ndef::TNF, std::string_view, std::string_view>(), py::arg("tnf"),
           py::arg("type"), py::arg("payload"),
           "*\n   * @brief Makes an NDEF record with header and payload.\n   * @param tnf The TNF "
           "for this packet.\n   * @param type String view for the type of this packet\n   * "
           "@param payload The payload data for the packet\n")
      .def_static("make_text", &espp::Ndef::make_text, py::arg("text"),
                  "*\n   * @brief Static function to make an NDEF record for transmitting "
                  "english\n   *        text.\n   * @param text The text that the NDEF record will "
                  "hold.\n   * @return NDEF record object.\n")
      .def_static("make_uri", &espp::Ndef::make_uri, py::arg("uri"),
                  py::arg("uic") = espp::Ndef::Uic::NONE,
                  "*\n   * @brief Static function to make an NDEF record for loading a URI.\n   * "
                  "@param uri URI for the record to point to.\n   * @param uic UIC for the uri - "
                  "helps shorten the uri text / NDEF record.\n   * @return NDEF record object.\n")
      .def_static("make_android_launcher", &espp::Ndef::make_android_launcher, py::arg("uri"),
                  "*\n   * @brief Static function to make an NDEF record for launching an Android "
                  "App.\n   * @param uri URI for the android package / app to launch.\n   * "
                  "@return NDEF record object.\n")
      .def_static("make_wifi_config", &espp::Ndef::make_wifi_config, py::arg("config"),
                  "*\n   * @brief Create a WiFi credential tag.\n   * @param config WifiConfig "
                  "describing the WiFi network.\n   * @return NDEF record object.\n")
      .def_static(
          "make_collision_resolution_record", &espp::Ndef::make_collision_resolution_record,
          py::arg("random_number"),
          "\n   * @brief Create a collision resolution record.\n   * @param random_number Random "
          "number to use for the collision resolution.\n   * @return NDEF record object.\n")
      .def_static(
          "make_handover_select", &espp::Ndef::make_handover_select, py::arg("carrier_data_ref"),
          "*\n   * @brief Create a Handover Select record for a Bluetooth device.\n   * @see\n   * "
          "https://members.nfc-forum.org/apps/group_public/download.php/18688/"
          "NFCForum-AD-BTSSP_1_1.pdf\n   * @param carrier_data_ref Reference to the carrier data "
          "record, which is the\n   *        record that contains the actual bluetooth data. This "
          "should be the\n   *        same as the id of the carrier data record, such as '0'.\n   "
          "* @return NDEF record object.\n")
      .def_static("make_handover_request", &espp::Ndef::make_handover_request,
                  py::arg("carrier_data_ref"),
                  "*\n   * @brief Create a Handover request record for a Bluetooth device.\n   * "
                  "@see\n   * "
                  "https://members.nfc-forum.org/apps/group_public/download.php/18688/"
                  "NFCForum-AD-BTSSP_1_1.pdf\n   * @param carrier_data_ref Reference to the "
                  "carrier data record, which is the\n   *        record that contains the actual "
                  "bluetooth data. This should be the\n   *        same as the id of the carrier "
                  "data record, such as '0'.\n   * @return NDEF record object.\n")
      .def_static(
          "make_alternative_carrier", &espp::Ndef::make_alternative_carrier, py::arg("power_state"),
          py::arg("carrier_data_ref"),
          "*\n   * @brief Create a Handover Request record for a Bluetooth device.\n   * @details "
          "See page 18 of https://core.ac.uk/download/pdf/250136576.pdf for more details.\n   * "
          "@param power_state Power state of the alternative carrier.\n   * @param "
          "carrier_data_ref Reference to the carrier data record, which is the\n   *        record "
          "that contains the actual bluetooth data. This should be the\n   *        same as the id "
          "of the carrier data record, such as '0'.\n   * @return NDEF record object.\n")
      .def_static("make_oob_pairing", &espp::Ndef::make_oob_pairing, py::arg("mac_addr"),
                  py::arg("device_class"), py::arg("name"), py::arg("random_value") = "",
                  py::arg("confirm_value") = "",
                  "*\n   * @brief Static function to make an NDEF record for BT classic OOB "
                  "Pairing (Android).\n   * @param mac_addr 48 bit MAC Address of the BT radio\n   "
                  "* @note If the address is e.g. f4:12:fa:42:fe:9e then the mac_addr should be\n  "
                  " *       0xf412a42e9e.\n   * @param device_class The bluetooth device class for "
                  "this radio.\n   * @param name Name of the BT device.\n   * @param random_value "
                  "The Simple pairing randomizer R for the pairing.\n   * @param confirm_value The "
                  "Simple pairing hash C (confirm value) for the\n   *                      "
                  "pairing.\n   * @return NDEF record object.\n")
      .def_static(
          "make_le_oob_pairing", &espp::Ndef::make_le_oob_pairing, py::arg("mac_addr"),
          py::arg("role"), py::arg("name") = "",
          py::arg("appearance") = espp::Ndef::BtAppearance::UNKNOWN, py::arg("random_value") = "",
          py::arg("confirm_value") = "", py::arg("tk") = "",
          "*\n   * @brief Static function to make an NDEF record for BLE OOB Pairing (Android).\n  "
          " * @param mac_addr 48 bit MAC Address of the BLE radio.\n   * @note If the address is "
          "e.g. f4:12:fa:42:fe:9e then the mac_addr should be\n   *       0xf412a42e9e.\n   * "
          "@param role The BLE role of the device (central / peripheral / dual)\n   * @param name "
          "Name of the BLE device. Optional.\n   * @param appearance BtAppearance of the device. "
          "Optional.\n   * @param random_value The Simple pairing randomizer R for the pairing. "
          "(16 bytes, optional)\n   * @param confirm_value The Simple pairing hash C (confirm "
          "value) for the pairing. (16 bytes,\n   * optional)\n   * @param tk Temporary key for "
          "the pairing (16 bytes, optional)\n   * @return NDEF record object.\n")
      .def("serialize", &espp::Ndef::serialize, py::arg("message_begin") = true,
           py::arg("message_end") = true,
           "*\n   * @brief Serialize the NDEF record into a sequence of bytes.\n   * @param "
           "message_begin True if this is the first record in the message.\n   * @param "
           "message_end True if this is the last record in the message.\n   * @return The "
           "vector<uint8_t> of bytes representing the NDEF record.\n")
      .def("payload", &espp::Ndef::payload,
           "*\n   * @brief Return just the payload as a vector of bytes.\n   * @return Payload of "
           "the NDEF record as a vector of bytes.\n")
      .def("set_id", &espp::Ndef::set_id, py::arg("id"),
           "*\n   * @brief Set the payload ID of the NDEF record.\n   * @param id ID of the NDEF "
           "record.\n")
      .def("get_id", &espp::Ndef::get_id,
           "*\n   * @brief Get the ID of the NDEF record.\n   * @return ID of the NDEF record.\n")
      .def("get_size", &espp::Ndef::get_size,
           "*\n   * @brief Get the number of bytes needed for the NDEF record.\n   * @return Size "
           "of the NDEF record (bytes), for serialization.\n");
  ////////////////////    </generated_from:ndef.hpp>    ////////////////////

  ////////////////////    <generated_from:pid.hpp>    ////////////////////
  auto pyClassPid = py::class_<espp::Pid>(
      m, "Pid", py::dynamic_attr(),
      "*\n *  @brief Simple PID (proportional, integral, derivative) controller class\n *         "
      "with integrator clamping, output clamping, and prevention of\n *         integrator windup "
      "during output saturation. This class is\n *         thread-safe, so you can update(), "
      "clear(), and change_gains() from\n *         multiple threads if needed.\n *\n * \\section "
      "pid_ex1 Basic PID Example\n * \\snippet pid_example.cpp pid example\n * \\section pid_ex2 "
      "Complex PID Example\n * \\snippet pid_example.cpp complex pid example\n");

  { // inner classes & enums of Pid
    auto pyClassPid_ClassConfig =
        py::class_<espp::Pid::Config>(pyClassPid, "Config", py::dynamic_attr(), "")
            .def(
                py::init<>([](float kp = float(), float ki = float(), float kd = float(),
                              float integrator_min = float(), float integrator_max = float(),
                              float output_min = float(), float output_max = float(),
                              espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                  auto r = std::make_unique<espp::Pid::Config>();
                  r->kp = kp;
                  r->ki = ki;
                  r->kd = kd;
                  r->integrator_min = integrator_min;
                  r->integrator_max = integrator_max;
                  r->output_min = output_min;
                  r->output_max = output_max;
                  r->log_level = log_level;
                  return r;
                }),
                py::arg("kp") = float(), py::arg("ki") = float(), py::arg("kd") = float(),
                py::arg("integrator_min") = float(), py::arg("integrator_max") = float(),
                py::arg("output_min") = float(), py::arg("output_max") = float(),
                py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("kp", &espp::Pid::Config::kp, "*< Proportional gain.")
            .def_readwrite(
                "ki", &espp::Pid::Config::ki,
                "*< Integral gain. @note should not be pre-multiplied by the time constant.")
            .def_readwrite(
                "kd", &espp::Pid::Config::kd,
                "*< Derivative gain. @note should not be pre-divided by the time-constant.")
            .def_readwrite(
                "integrator_min", &espp::Pid::Config::integrator_min,
                "*< Minimum value the integrator can wind down to. @note Operates at the\n         "
                "                    same scale as \\p output_min and \\p output_max. Could be 0 "
                "or negative.\n                             Can have different magnitude from "
                "integrator_max for asymmetric\n                             response.")
            .def_readwrite(
                "integrator_max", &espp::Pid::Config::integrator_max,
                "*< Maximum value the integrator can wind up to. @note Operates at the\n           "
                "                  same scale as \\p output_min and \\p output_max.")
            .def_readwrite("output_min", &espp::Pid::Config::output_min,
                           "*< Limit the minimum output value. Can be a different magnitude from "
                           "output\n                         max for asymmetric output behavior.")
            .def_readwrite("output_max", &espp::Pid::Config::output_max,
                           "*< Limit the maximum output value.")
            .def_readwrite("log_level", &espp::Pid::Config::log_level,
                           "*< Verbosity for the adc logger.");
  } // end of inner classes & enums of Pid

  pyClassPid.def(py::init<const espp::Pid::Config &>())
      .def("set_config", &espp::Pid::set_config, py::arg("config"), py::arg("reset_state") = true,
           "*\n   * @brief Change the gains and other configuration for the PID controller.\n   * "
           "@param config Configuration struct with new gains and sampling time.\n   * @param "
           "reset_state Reset / clear the PID controller state.\n")
      .def("clear", &espp::Pid::clear, "*\n   * @brief Clear the PID controller state.\n")
      .def("update", &espp::Pid::update, py::arg("error"),
           "*\n   * @brief Update the PID controller with the latest error measurement,\n   *      "
           "  getting the output control signal in return.\n   *\n   * @note Tracks invocation "
           "timing to better compute time-accurate\n   *       integral/derivative signals.\n   "
           "*\n   * @param error Latest error signal.\n   * @return The output control signal "
           "based on the PID state and error.\n")
      .def("__call__", &espp::Pid::operator(), py::arg("error"),
           "*\n   * @brief Update the PID controller with the latest error measurement,\n   *      "
           "  getting the output control signal in return.\n   *\n   * @note Tracks invocation "
           "timing to better compute time-accurate\n   *       integral/derivative signals.\n   "
           "*\n   * @param error Latest error signal.\n   * @return The output control signal "
           "based on the PID state and error.\n")
      .def("get_error", &espp::Pid::get_error,
           "*\n   * @brief Get the current error (as of the last time update() or operator()\n   * "
           "       were called)\n   * @return Most recent error.\n")
      .def("get_integrator", &espp::Pid::get_integrator,
           "*\n   * @brief Get the current integrator (as of the last time update() or\n   *       "
           " operator() were called)\n   * @return Most recent integrator value.\n")
      .def("get_config", &espp::Pid::get_config,
           "*\n   * @brief Get the configuration for the PID (gains, etc.).\n   * @return Config "
           "structure containing gains, etc.\n");
  ////////////////////    </generated_from:pid.hpp>    ////////////////////

  ////////////////////    <generated_from:socket.hpp>    ////////////////////
  auto pyClassSocket =
      py::class_<espp::Socket>(m, "Socket", py::dynamic_attr(),
                               "*\n *   @brief Class for a generic socket with some helper "
                               "functions for\n *          configuring the socket.\n");

  { // inner classes & enums of Socket
    auto pyEnumType =
        py::enum_<espp::Socket::Type>(pyClassSocket, "Type", py::arithmetic(), "")
            .value("raw", espp::Socket::Type::RAW,
                   "*< Only IP headers, no TCP or UDP headers as well.")
            .value("dgram", espp::Socket::Type::DGRAM, "*< UDP/IP socket - datagram.")
            .value("stream", espp::Socket::Type::STREAM, "*< TCP/IP socket - stream.");
    auto pyClassSocket_ClassInfo =
        py::class_<espp::Socket::Info>(
            pyClassSocket, "Info", py::dynamic_attr(),
            "*\n   *  @brief Storage for socket information (address, port) with convenience\n   * "
            "        functions to convert to/from POSIX structures.\n")
            .def(py::init<>([](std::string address = std::string(), size_t port = size_t()) {
                   auto r = std::make_unique<espp::Socket::Info>();
                   r->address = address;
                   r->port = port;
                   return r;
                 }),
                 py::arg("address") = std::string(), py::arg("port") = size_t())
            .def_readwrite("address", &espp::Socket::Info::address,
                           "*< IP address of the endpoint as a string.")
            .def_readwrite("port", &espp::Socket::Info::port,
                           "*< Port of the endpoint as an integer.")
            .def("init_ipv4", &espp::Socket::Info::init_ipv4, py::arg("addr"), py::arg("prt"),
                 "*\n     * @brief Initialize the struct as an ipv4 address/port combo.\n     * "
                 "@param addr IPv4 address string\n     * @param prt port number\n")
            .def("ipv4_ptr", &espp::Socket::Info::ipv4_ptr,
                 "*\n     * @brief Gives access to IPv4 sockaddr structure (sockaddr_in) for use\n "
                 "    *        with low level socket calls like sendto / recvfrom.\n     * @return "
                 "*sockaddr_in pointer to ipv4 data structure\n")
            .def("ipv6_ptr", &espp::Socket::Info::ipv6_ptr,
                 "*\n     * @brief Gives access to IPv6 sockaddr structure (sockaddr_in6) for "
                 "use\n     *        with low level socket calls like sendto / recvfrom.\n     * "
                 "@return *sockaddr_in6 pointer to ipv6 data structure\n")
            .def("update", &espp::Socket::Info::update,
                 "*\n     * @brief Will update address and port based on the curent data in raw.\n")
            .def("from_sockaddr",
                 py::overload_cast<const struct sockaddr_storage &>(
                     &espp::Socket::Info::from_sockaddr),
                 py::arg("source_address"),
                 "*\n     * @brief Fill this Info from the provided sockaddr struct.\n     * "
                 "@param &source_address sockaddr info filled out by recvfrom.\n")
            .def("from_sockaddr",
                 py::overload_cast<const struct sockaddr_in &>(&espp::Socket::Info::from_sockaddr),
                 py::arg("source_address"),
                 "*\n     * @brief Fill this Info from the provided sockaddr struct.\n     * "
                 "@param &source_address sockaddr info filled out by recvfrom.\n")
            .def("from_sockaddr",
                 py::overload_cast<const struct sockaddr_in6 &>(&espp::Socket::Info::from_sockaddr),
                 py::arg("source_address"),
                 "*\n     * @brief Fill this Info from the provided sockaddr struct.\n     * "
                 "@param &source_address sockaddr info filled out by recvfrom.\n");
  } // end of inner classes & enums of Socket

  pyClassSocket
      .def("is_valid", &espp::Socket::is_valid,
           "*\n   * @brief Is the socket valid.\n   * @return True if the socket file descriptor "
           "is >= 0.\n")
      .def_static("is_valid_fd", &espp::Socket::is_valid_fd, py::arg("socket_fd"),
                  "*\n   * @brief Is the socket valid.\n   * @param socket_fd Socket file "
                  "descriptor.\n   * @return True if the socket file descriptor is >= 0.\n")
      .def("get_ipv4_info", &espp::Socket::get_ipv4_info,
           "*\n   * @brief Get the Socket::Info for the socket.\n   * @details This will call "
           "getsockname() on the socket to get the\n   *          sockaddr_storage structure, and "
           "then fill out the Socket::Info\n   *          structure.\n   * @return Socket::Info "
           "for the socket.\n")
      .def("set_receive_timeout", &espp::Socket::set_receive_timeout, py::arg("timeout"),
           "*\n   * @brief Set the receive timeout on the provided socket.\n   * @param timeout "
           "requested timeout, must be > 0.\n   * @return True if SO_RECVTIMEO was successfully "
           "set.\n")
      .def("enable_reuse", &espp::Socket::enable_reuse,
           "*\n   * @brief Allow others to use this address/port combination after we're done\n   "
           "*        with it.\n   * @return True if SO_REUSEADDR and SO_REUSEPORT were "
           "successfully set.\n")
      .def("make_multicast", &espp::Socket::make_multicast, py::arg("time_to_live") = 1,
           py::arg("loopback_enabled") = true,
           "*\n   * @brief Configure the socket to be multicast (if time_to_live > 0).\n   *       "
           " Sets the IP_MULTICAST_TTL (number of multicast hops allowed) and\n   *        "
           "optionally configures whether this node should receive its own\n   *        multicast "
           "packets (IP_MULTICAST_LOOP).\n   * @param time_to_live number of multicast hops "
           "allowed (TTL).\n   * @param loopback_enabled Whether to receive our own multicast "
           "packets.\n   * @return True if IP_MULTICAST_TTL and IP_MULTICAST_LOOP were set.\n")
      .def("add_multicast_group", &espp::Socket::add_multicast_group, py::arg("multicast_group"),
           "*\n   * @brief If this is a server socket, add it to the provided the multicast\n   *  "
           "      group.\n   *\n   *         @note Multicast groups must be Class D addresses "
           "(224.0.0.0 to\n   *                239.255.255.255)\n   *\n   *        See "
           "https://en.wikipedia.org/wiki/Multicast_address for more\n   *        information.\n   "
           "* @param multicast_group multicast group to join.\n   * @return True if "
           "IP_ADD_MEMBERSHIP was successfully set.\n")
      .def("select", &espp::Socket::select, py::arg("timeout"),
           "*\n   * @brief Select on the socket for read events.\n   * @param timeout how long to "
           "wait for an event.\n   * @return number of events that occurred.\n");
  ////////////////////    </generated_from:socket.hpp>    ////////////////////

  ////////////////////    <generated_from:tcp_socket.hpp>    ////////////////////
  auto pyClassTcpSocket = py::class_<espp::TcpSocket>(
      m, "TcpSocket", py::dynamic_attr(),
      "*\n *   @brief Class for managing sending and receiving data using TCP/IP. Can be\n *       "
      "   used to create client or server sockets.\n *\n * \\section tcp_ex1 TCP Client Example\n "
      "* \\snippet socket_example.cpp TCP Client example\n * \\section tcp_ex2 TCP Server "
      "Example\n * \\snippet socket_example.cpp TCP Server example\n *\n * \\section tcp_ex3 TCP "
      "Client Response Example\n * \\snippet socket_example.cpp TCP Client Response example\n * "
      "\\section tcp_ex4 TCP Server Response Example\n * \\snippet socket_example.cpp TCP Server "
      "Response example\n *\n");

  { // inner classes & enums of TcpSocket
    auto pyClassTcpSocket_ClassConfig =
        py::class_<espp::TcpSocket::Config>(pyClassTcpSocket, "Config", py::dynamic_attr(),
                                            "*\n   * @brief Config struct for the TCP socket.\n")
            .def(
                py::init<>([](espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                  auto r = std::make_unique<espp::TcpSocket::Config>();
                  r->log_level = log_level;
                  return r;
                }),
                py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("log_level", &espp::TcpSocket::Config::log_level,
                           "*< Verbosity level for the TCP socket logger.");
    auto pyClassTcpSocket_ClassConnectConfig =
        py::class_<espp::TcpSocket::ConnectConfig>(
            pyClassTcpSocket, "ConnectConfig", py::dynamic_attr(),
            "*\n   * @brief Config struct for connecting to a remote TCP server.\n")
            .def(py::init<>([](std::string ip_address = std::string(), size_t port = size_t()) {
                   auto r = std::make_unique<espp::TcpSocket::ConnectConfig>();
                   r->ip_address = ip_address;
                   r->port = port;
                   return r;
                 }),
                 py::arg("ip_address") = std::string(), py::arg("port") = size_t())
            .def_readwrite("ip_address", &espp::TcpSocket::ConnectConfig::ip_address,
                           "*< Address to send data to.")
            .def_readwrite("port", &espp::TcpSocket::ConnectConfig::port,
                           "*< Port number to send data to.");
    auto pyClassTcpSocket_ClassTransmitConfig =
        py::class_<espp::TcpSocket::TransmitConfig>(
            pyClassTcpSocket, "TransmitConfig", py::dynamic_attr(),
            "*\n   * @brief Config struct for sending data to a remote TCP socket.\n   * @note "
            "This is only used when waiting for a response from the remote.\n")
            .def(py::init<>([](bool wait_for_response = false, size_t response_size = 0,
                               espp::Socket::response_callback_fn on_response_callback = nullptr,
                               std::chrono::duration<float> response_timeout =
                                   std::chrono::duration<float>(0.5f)) {
                   auto r = std::make_unique<espp::TcpSocket::TransmitConfig>();
                   r->wait_for_response = wait_for_response;
                   r->response_size = response_size;
                   r->on_response_callback = on_response_callback;
                   r->response_timeout = response_timeout;
                   return r;
                 }),
                 py::arg("wait_for_response") = false, py::arg("response_size") = 0,
                 py::arg("on_response_callback") = py::none(),
                 py::arg("response_timeout") = std::chrono::duration<float>(0.5f))
            .def_readwrite("wait_for_response", &espp::TcpSocket::TransmitConfig::wait_for_response,
                           "*< Whether to wait for a response from the remote or not.")
            .def_readwrite(
                "response_size", &espp::TcpSocket::TransmitConfig::response_size,
                "*< If waiting for a response, this is the maximum size response we will receive.")
            .def_readwrite("on_response_callback",
                           &espp::TcpSocket::TransmitConfig::on_response_callback,
                           "*< If waiting for a\n                   response, this is an optional "
                           "handler which is provided the response data.")
            .def_readwrite("response_timeout", &espp::TcpSocket::TransmitConfig::response_timeout,
                           "*< If waiting for a response, this is the maximum timeout to wait.")
            .def_static("default", &espp::TcpSocket::TransmitConfig::Default);
  } // end of inner classes & enums of TcpSocket

  pyClassTcpSocket.def(py::init<const espp::TcpSocket::Config &>())
      .def("reinit", &espp::TcpSocket::reinit,
           "*\n   * @brief Reinitialize the socket, cleaning it up if first it is already\n   *    "
           "    initalized.\n")
      .def("close", &espp::TcpSocket::close, "*\n   * @brief Close the socket.\n")
      .def("is_connected", &espp::TcpSocket::is_connected,
           "*\n   * @brief Check if the socket is connected to a remote endpoint.\n   * @return "
           "True if the socket is connected to a remote endpoint.\n")
      .def("connect", &espp::TcpSocket::connect, py::arg("connect_config"),
           "*\n   * @brief Open a connection to the remote TCP server.\n   * @param connect_config "
           "ConnectConfig struct describing the server endpoint.\n   * @return True if the client "
           "successfully connected to the server.\n")
      .def("get_remote_info", &espp::TcpSocket::get_remote_info,
           "*\n   * @brief Get the remote endpoint info.\n   * @return The remote endpoint info.\n")
      .def("transmit",
           py::overload_cast<const std::vector<uint8_t> &, const espp::TcpSocket::TransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::TcpSocket::TransmitConfig::Default(),
           "*\n   * @brief Send data to the endpoint already connected to by TcpSocket::connect.\n "
           "  *        Can be configured to block waiting for a response from the remote.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data vector of bytes to send to the remote endpoint.\n   * @param "
           "transmit_config TransmitConfig struct indicating whether to wait for a\n   *        "
           "response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("transmit",
           py::overload_cast<const std::vector<char> &, const espp::TcpSocket::TransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::TcpSocket::TransmitConfig::Default(),
           "*\n   * @brief Send data to the endpoint already connected to by TcpSocket::connect.\n "
           "  *        Can be configured to block waiting for a response from the remote.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data vector of bytes to send to the remote endpoint.\n   * @param "
           "transmit_config TransmitConfig struct indicating whether to wait for a\n   *        "
           "response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("transmit",
           py::overload_cast<std::string_view, const espp::TcpSocket::TransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::TcpSocket::TransmitConfig::Default(),
           "*\n   * @brief Send data to the endpoint already connected to by TcpSocket::connect.\n "
           "  *        Can be configured to block waiting for a response from the remote.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data string view of bytes to send to the remote endpoint.\n   * @param "
           "transmit_config TransmitConfig struct indicating whether to wait for a\n   *        "
           "response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("receive", py::overload_cast<std::vector<uint8_t> &, size_t>(&espp::TcpSocket::receive),
           py::arg("data"), py::arg("max_num_bytes"),
           "*\n   * @brief Call read on the socket, assuming it has already been configured\n   *  "
           "      appropriately.\n   *\n   * @param data Vector of bytes of received data.\n   * "
           "@param max_num_bytes Maximum number of bytes to receive.\n   * @return True if "
           "successfully received, False otherwise.\n")
      .def("receive", py::overload_cast<uint8_t *, size_t>(&espp::TcpSocket::receive),
           py::arg("data"), py::arg("max_num_bytes"),
           "*\n   * @brief Call read on the socket, assuming it has already been configured\n   *  "
           "      appropriately.\n   * @note This function will block until max_num_bytes are "
           "received or the\n   *       receive timeout is reached.\n   * @note The data pointed "
           "to by data must be at least max_num_bytes in size.\n   * @param data Pointer to buffer "
           "to receive data.\n   * @param max_num_bytes Maximum number of bytes to receive.\n   * "
           "@return Number of bytes received.\n")
      .def("bind", &espp::TcpSocket::bind, py::arg("port"),
           "*\n   * @brief Bind the socket as a server on \\p port.\n   * @param port The port to "
           "which to bind the socket.\n   * @return True if the socket was bound.\n")
      .def("listen", &espp::TcpSocket::listen, py::arg("max_pending_connections"),
           "*\n   * @brief Listen for incoming client connections.\n   * @note Must be called "
           "after bind and before accept.\n   * @see bind\n   * @see accept\n   * @param "
           "max_pending_connections Max number of allowed pending connections.\n   * @return True "
           "if socket was able to start listening.\n")
      .def("accept", &espp::TcpSocket::accept,
           "*\n   * @brief Accept an incoming connection.\n   * @note Blocks until a connection is "
           "accepted.\n   * @note Must be called after listen.\n   * @note This function will "
           "block until a connection is accepted.\n   * @return A unique pointer to a "
           "TcpClientSession if a connection was\n   *         accepted, None otherwise.\n");
  ////////////////////    </generated_from:tcp_socket.hpp>    ////////////////////

  ////////////////////    <generated_from:udp_socket.hpp>    ////////////////////
  auto pyClassUdpSocket = py::class_<espp::UdpSocket>(
      m, "UdpSocket", py::dynamic_attr(),
      "*\n *   @brief Class for managing sending and receiving data using UDP/IP. Can be\n *       "
      "   used to create client or server sockets.\n *\n *   See\n *   "
      "https://github.com/espressif/esp-idf/tree/master/examples/protocols/sockets/udp_multicast\n "
      "*   for more information on udp multicast sockets.\n *\n * \\section udp_ex1 UDP Client "
      "Example\n * \\snippet socket_example.cpp UDP Client example\n * \\section udp_ex2 UDP "
      "Server Example\n * \\snippet socket_example.cpp UDP Server example\n *\n * \\section "
      "udp_ex3 UDP Client Response Example\n * \\snippet socket_example.cpp UDP Client Response "
      "example\n * \\section udp_ex4 UDP Server Response Example\n * \\snippet socket_example.cpp "
      "UDP Server Response example\n *\n * \\section udp_ex5 UDP Multicast Client Example\n * "
      "\\snippet socket_example.cpp UDP Multicast Client example\n * \\section udp_ex6 UDP "
      "Multicast Server Example\n * \\snippet socket_example.cpp UDP Multicast Server example\n "
      "*\n");

  { // inner classes & enums of UdpSocket
    auto pyClassUdpSocket_ClassReceiveConfig =
        py::class_<espp::UdpSocket::ReceiveConfig>(pyClassUdpSocket, "ReceiveConfig",
                                                   py::dynamic_attr(), "")
            .def(py::init<>([](size_t port = size_t(), size_t buffer_size = size_t(),
                               bool is_multicast_endpoint = {false},
                               std::string multicast_group = {""},
                               espp::Socket::receive_callback_fn on_receive_callback = {nullptr}) {
                   auto r = std::make_unique<espp::UdpSocket::ReceiveConfig>();
                   r->port = port;
                   r->buffer_size = buffer_size;
                   r->is_multicast_endpoint = is_multicast_endpoint;
                   r->multicast_group = multicast_group;
                   r->on_receive_callback = on_receive_callback;
                   return r;
                 }),
                 py::arg("port") = size_t(), py::arg("buffer_size") = size_t(),
                 py::arg("is_multicast_endpoint") = bool{false},
                 py::arg("multicast_group") = std::string{""},
                 py::arg("on_receive_callback") = espp::Socket::receive_callback_fn{nullptr})
            .def_readwrite("port", &espp::UdpSocket::ReceiveConfig::port,
                           "*< Port number to bind to / receive from.")
            .def_readwrite("buffer_size", &espp::UdpSocket::ReceiveConfig::buffer_size,
                           "*< Max size of data we can receive at one time.")
            .def_readwrite("is_multicast_endpoint",
                           &espp::UdpSocket::ReceiveConfig::is_multicast_endpoint,
                           "*< Whether this should be a multicast endpoint.")
            .def_readwrite("multicast_group", &espp::UdpSocket::ReceiveConfig::multicast_group,
                           "*< If this is a multicast endpoint, this is the group it belongs to.")
            .def_readwrite("on_receive_callback",
                           &espp::UdpSocket::ReceiveConfig::on_receive_callback,
                           "*< Function containing business logic to handle data received.");
    auto pyClassUdpSocket_ClassSendConfig =
        py::class_<espp::UdpSocket::SendConfig>(pyClassUdpSocket, "SendConfig", py::dynamic_attr(),
                                                "")
            .def(py::init<>([](std::string ip_address = std::string(), size_t port = size_t(),
                               bool is_multicast_endpoint = {false},
                               bool wait_for_response = {false}, size_t response_size = {0},
                               espp::Socket::response_callback_fn on_response_callback = {nullptr},
                               std::chrono::duration<float> response_timeout =
                                   std::chrono::duration<float>(0.5f)) {
                   auto r = std::make_unique<espp::UdpSocket::SendConfig>();
                   r->ip_address = ip_address;
                   r->port = port;
                   r->is_multicast_endpoint = is_multicast_endpoint;
                   r->wait_for_response = wait_for_response;
                   r->response_size = response_size;
                   r->on_response_callback = on_response_callback;
                   r->response_timeout = response_timeout;
                   return r;
                 }),
                 py::arg("ip_address") = std::string(), py::arg("port") = size_t(),
                 py::arg("is_multicast_endpoint") = bool{false},
                 py::arg("wait_for_response") = bool{false}, py::arg("response_size") = size_t{0},
                 py::arg("on_response_callback") = espp::Socket::response_callback_fn{nullptr},
                 py::arg("response_timeout") = std::chrono::duration<float>(0.5f))
            .def_readwrite("ip_address", &espp::UdpSocket::SendConfig::ip_address,
                           "*< Address to send data to.")
            .def_readwrite("port", &espp::UdpSocket::SendConfig::port,
                           "*< Port number to send data to.")
            .def_readwrite("is_multicast_endpoint",
                           &espp::UdpSocket::SendConfig::is_multicast_endpoint,
                           "*< Whether this should be a multicast endpoint.")
            .def_readwrite("wait_for_response", &espp::UdpSocket::SendConfig::wait_for_response,
                           "*< Whether to wait for a response from the remote or not.")
            .def_readwrite(
                "response_size", &espp::UdpSocket::SendConfig::response_size,
                "*< If waiting for a response, this is the maximum size response we will receive.")
            .def_readwrite("on_response_callback",
                           &espp::UdpSocket::SendConfig::on_response_callback,
                           "*< If waiting for a response, this is an optional handler which is "
                           "provided the\n                     response data.")
            .def_readwrite("response_timeout", &espp::UdpSocket::SendConfig::response_timeout,
                           "*< If waiting for a response, this is the maximum timeout to wait.");
    auto pyClassUdpSocket_ClassConfig =
        py::class_<espp::UdpSocket::Config>(pyClassUdpSocket, "Config", py::dynamic_attr(), "")
            .def(
                py::init<>([](espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                  auto r = std::make_unique<espp::UdpSocket::Config>();
                  r->log_level = log_level;
                  return r;
                }),
                py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("log_level", &espp::UdpSocket::Config::log_level,
                           "*< Verbosity level for the UDP socket logger.");
  } // end of inner classes & enums of UdpSocket

  pyClassUdpSocket.def(py::init<const espp::UdpSocket::Config &>())
      .def("send",
           py::overload_cast<const std::vector<uint8_t> &, const espp::UdpSocket::SendConfig &>(
               &espp::UdpSocket::send),
           py::arg("data"), py::arg("send_config"),
           "*\n   * @brief Send data to the endpoint specified by the send_config.\n   *        "
           "Can be configured to multicast (within send_config) and can be\n   *        configured "
           "to block waiting for a response from the remote.\n   *\n   *        @note in the case "
           "of multicast, it will block only until the first\n   *              response.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data vector of bytes to send to the remote endpoint.\n   * @param send_config "
           "SendConfig struct indicating where to send and whether\n   *        to wait for a "
           "response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("send",
           py::overload_cast<std::string_view, const espp::UdpSocket::SendConfig &>(
               &espp::UdpSocket::send),
           py::arg("data"), py::arg("send_config"),
           "*\n   * @brief Send data to the endpoint specified by the send_config.\n   *        "
           "Can be configured to multicast (within send_config) and can be\n   *        configured "
           "to block waiting for a response from the remote.\n   *\n   *        @note in the case "
           "of multicast, it will block only until the first\n   *              response.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data String view of bytes to send to the remote endpoint.\n   * @param "
           "send_config SendConfig struct indicating where to send and whether\n   *        to "
           "wait for a response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("receive", &espp::UdpSocket::receive, py::arg("max_num_bytes"), py::arg("data"),
           py::arg("remote_info"),
           "*\n   * @brief Call recvfrom on the socket, assuming it has already been\n   *        "
           "configured appropriately.\n   *\n   * @param max_num_bytes Maximum number of bytes to "
           "receive.\n   * @param data Vector of bytes of received data.\n   * @param remote_info "
           "Socket::Info containing the sender's information. This\n   *        will be populated "
           "with the information about the sender.\n   * @return True if successfully received, "
           "False otherwise.\n")
      .def("start_receiving", &espp::UdpSocket::start_receiving, py::arg("task_config"),
           py::arg("receive_config"),
           "*\n   * @brief Configure a server socket and start a thread to continuously\n   *      "
           "  receive and handle data coming in on that socket.\n   *\n   * @param task_config "
           "Task::Config struct for configuring the receive task.\n   * @param receive_config "
           "ReceiveConfig struct with socket and callback info.\n   * @return True if the socket "
           "was created and task was started, False otherwise.\n");
  ////////////////////    </generated_from:udp_socket.hpp>    ////////////////////

  ////////////////////    <generated_from:task.hpp>    ////////////////////
  auto pyClassTask = py::class_<espp::Task>(
      m, "Task", py::dynamic_attr(),
      "*\n * @brief Task provides an abstraction over std::thread which optionally\n * includes "
      "memory / priority configuration on ESP systems. It allows users to\n * easily stop the "
      "task, and will automatically stop itself if destroyed.\n *\n * There is also a utility "
      "function which can be used to get the info for the\n * task of the current context, or for "
      "a provided Task object.\n *\n * There is also a helper function to run a lambda on a "
      "specific core, which can\n * be used to run a specific function on a specific core, as you "
      "might want to\n * do when registering an interrupt driver on a specific core.\n *\n * "
      "\\section task_ex1 Basic Task Example\n * \\snippet task_example.cpp Task example\n * "
      "\\section task_ex2 Task Watchdog Example\n * \\snippet task_example.cpp task watchdog "
      "example\n * \\section task_ex3 Many Task Example\n * \\snippet task_example.cpp ManyTask "
      "example\n * \\section task_ex4 Long Running Task Example\n * \\snippet task_example.cpp "
      "LongRunningTask example\n * \\section task_ex4 Long Running Task Example using notification "
      "flag (recommended to avoid\n * spurious wakeups) \\snippet task_example.cpp "
      "LongRunningTaskNotified example \\section task_ex5\n * Task Info Example \\snippet "
      "task_example.cpp Task Info example \\section task_ex6 Task Request Stop\n * Example "
      "\\snippet task_example.cpp Task Request Stop example\n *\n * \\section run_on_core_ex1 Run "
      "on Core Example\n * \\snippet task_example.cpp run on core example\n * \\section "
      "run_on_core_ex2 Run on Core (Non-Blocking) Example\n * \\snippet task_example.cpp run on "
      "core nonblocking example\n");

  { // inner classes & enums of Task
    auto pyClassTask_ClassBaseConfig =
        py::class_<espp::Task::BaseConfig>(
            pyClassTask, "BaseConfig", py::dynamic_attr(),
            "*\n   * @brief Base configuration struct for the Task.\n   * @note This is designed "
            "to be used as a configuration struct in other classes\n   *       that may have a "
            "Task as a member.\n")
            .def(py::init<>([](std::string name = std::string(), size_t stack_size_bytes = {4096},
                               size_t priority = {0}, int core_id = {-1}) {
                   auto r = std::make_unique<espp::Task::BaseConfig>();
                   r->name = name;
                   r->stack_size_bytes = stack_size_bytes;
                   r->priority = priority;
                   r->core_id = core_id;
                   return r;
                 }),
                 py::arg("name") = std::string(), py::arg("stack_size_bytes") = size_t{4096},
                 py::arg("priority") = size_t{0}, py::arg("core_id") = int{-1})
            .def_readwrite("name", &espp::Task::BaseConfig::name, "*< Name of the task")
            .def_readwrite("stack_size_bytes", &espp::Task::BaseConfig::stack_size_bytes,
                           "*< Stack Size (B) allocated to the task.")
            .def_readwrite("priority", &espp::Task::BaseConfig::priority,
                           "*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.")
            .def_readwrite("core_id", &espp::Task::BaseConfig::core_id,
                           "*< Core ID of the task, -1 means it is not pinned to any core.");
    auto pyClassTask_ClassConfig =
        py::class_<espp::Task::Config>(
            pyClassTask, "Config", py::dynamic_attr(),
            "*\n   * @brief Configuration struct for the Task.\n   * @note This is the recommended "
            "way to configure the Task, and allows you to\n   *       use the condition variable "
            "and mutex from the task to wait_for and\n   *       wait_until.\n   * @note This is "
            "an older configuration struct, and is kept for backwards\n   *       compatibility. "
            "It is recommended to use the AdvancedConfig struct\n   *       instead.\n")
            .def(py::init<>(
                     [](std::string name = std::string(),
                        espp::Task::callback_variant callback = espp::Task::callback_variant(),
                        size_t stack_size_bytes = {4096}, size_t priority = {0}, int core_id = {-1},
                        espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                       auto r = std::make_unique<espp::Task::Config>();
                       r->name = name;
                       r->callback = callback;
                       r->stack_size_bytes = stack_size_bytes;
                       r->priority = priority;
                       r->core_id = core_id;
                       r->log_level = log_level;
                       return r;
                     }),
                 py::arg("name") = std::string(),
                 py::arg("callback") = espp::Task::callback_variant(),
                 py::arg("stack_size_bytes") = size_t{4096}, py::arg("priority") = size_t{0},
                 py::arg("core_id") = int{-1},
                 py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("name", &espp::Task::Config::name, "*< Name of the task")
            .def_readwrite("callback", &espp::Task::Config::callback, "*< Callback function")
            .def_readwrite("stack_size_bytes", &espp::Task::Config::stack_size_bytes,
                           "*< Stack Size (B) allocated to the task.")
            .def_readwrite("priority", &espp::Task::Config::priority,
                           "*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.")
            .def_readwrite("core_id", &espp::Task::Config::core_id,
                           "*< Core ID of the task, -1 means it is not pinned to any core.")
            .def_readwrite("log_level", &espp::Task::Config::log_level,
                           "*< Log verbosity for the task.");
    auto pyClassTask_ClassSimpleConfig =
        py::class_<espp::Task::SimpleConfig>(
            pyClassTask, "SimpleConfig", py::dynamic_attr(),
            "*\n   * @brief Simple configuration struct for the Task.\n   * @note This is useful "
            "for when you don't need to use the condition variable\n   *       or mutex in the "
            "callback.\n")
            .def(
                py::init<>([](espp::Task::callback_no_params_fn callback =
                                  espp::Task::callback_no_params_fn(),
                              espp::Task::BaseConfig task_config = espp::Task::BaseConfig(),
                              espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                  auto r = std::make_unique<espp::Task::SimpleConfig>();
                  r->callback = callback;
                  r->task_config = task_config;
                  r->log_level = log_level;
                  return r;
                }),
                py::arg("callback") = espp::Task::callback_no_params_fn(),
                py::arg("task_config") = espp::Task::BaseConfig(),
                py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("callback", &espp::Task::SimpleConfig::callback, "*< Callback function")
            .def_readwrite("task_config", &espp::Task::SimpleConfig::task_config,
                           "*< Base configuration for the task.")
            .def_readwrite("log_level", &espp::Task::SimpleConfig::log_level,
                           "*< Log verbosity for the task.");
    auto pyClassTask_ClassAdvancedConfig =
        py::class_<espp::Task::AdvancedConfig>(
            pyClassTask, "AdvancedConfig", py::dynamic_attr(),
            "*\n   * @brief Advanced configuration struct for the Task.\n   * @note This is the "
            "recommended way to configure the Task, and allows you to\n   *       use the "
            "condition variable and mutex from the task to wait_for and\n   *       wait_until.\n")
            .def(py::init<>(
                     [](espp::Task::callback_variant callback = espp::Task::callback_variant(),
                        espp::Task::BaseConfig task_config = espp::Task::BaseConfig(),
                        espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                       auto r = std::make_unique<espp::Task::AdvancedConfig>();
                       r->callback = callback;
                       r->task_config = task_config;
                       r->log_level = log_level;
                       return r;
                     }),
                 py::arg("callback") = espp::Task::callback_variant(),
                 py::arg("task_config") = espp::Task::BaseConfig(),
                 py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("callback", &espp::Task::AdvancedConfig::callback,
                           "*< Callback function")
            .def_readwrite("task_config", &espp::Task::AdvancedConfig::task_config,
                           "*< Base configuration for the task.")
            .def_readwrite("log_level", &espp::Task::AdvancedConfig::log_level,
                           "*< Log verbosity for the task.");
  } // end of inner classes & enums of Task

  pyClassTask.def(py::init<const espp::Task::Config &>())
      .def(py::init<const espp::Task::SimpleConfig &>())
      .def(py::init<const espp::Task::AdvancedConfig &>())
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::Config &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config Config struct to initialize the Task with.\n   * @return "
                  "std::unique_ptr<Task> pointer to the newly created task.\n")
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::SimpleConfig &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config SimpleConfig struct to initialize the Task with.\n   * @return "
                  "std::unique_ptr<Task> pointer to the newly created task.\n")
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::AdvancedConfig &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config AdvancedConfig struct to initialize the Task with.\n   * "
                  "@return std::unique_ptr<Task> pointer to the newly created task.\n")
      .def("start", &espp::Task::start,
           "*\n   * @brief Start executing the task.\n   *\n   * @return True if the task started, "
           "False if it was already started.\n")
      .def("stop", &espp::Task::stop,
           "*\n   * @brief Stop the task execution.\n   * @details This will request the task to "
           "stop, notify the condition variable,\n   *          and (if this calling context is "
           "not the task context) join the\n   *          thread.\n   * @return True if the task "
           "stopped, False if it was not started / already\n   *         stopped.\n")
      .def("is_started", &espp::Task::is_started,
           "*\n   * @brief Has the task been started or not?\n   *\n   * @return True if the task "
           "is started / running, False otherwise.\n")
      .def("is_running", &espp::Task::is_running,
           "*\n   * @brief Is the task running?\n   *\n   * @return True if the task is running, "
           "False otherwise.\n")
      .def("get_id", &espp::Task::get_id,
           "*\n   * @brief Get the ID for this Task's thread / task context.\n   * @return ID for "
           "this Task's thread / task context.\n")
      .def_static("get_current_id", &espp::Task::get_current_id,
                  "*\n   * @brief Get the ID for the current thread / task context.\n   * @return "
                  "ID for the current thread / task context.\n");
  ////////////////////    </generated_from:task.hpp>    ////////////////////

  ////////////////////    <generated_from:timer.hpp>    ////////////////////
  auto pyClassTimer = py::class_<espp::Timer>(
      m, "Timer", py::dynamic_attr(),
      "/ @brief A timer that can be used to schedule tasks to run at a later time.\n/ @details A "
      "timer can be used to schedule a task to run at a later time.\n/          The timer will run "
      "in the background and will call the task when\n/          the time is up. The timer can be "
      "canceled at any time. A timer\n/          can be configured to run once or to repeat.\n/\n/ "
      "         The timer uses a task to run in the background. The task will\n/          sleep "
      "until the timer is ready to run. When the timer is ready to\n/          run, the task will "
      "call the callback function. The callback\n/          function can return True to cancel the "
      "timer or False to keep the\n/          timer running. If the timer is configured to repeat, "
      "then the\n/          callback function will be called again after the period has\n/         "
      " elapsed. If the timer is configured to run once, then the\n/          callback function "
      "will only be called once.\n/\n/          The timer can be configured to start automatically "
      "when it is\n/          constructed. If the timer is not configured to start\n/          "
      "automatically, then the timer can be started by calling start().\n/          The timer can "
      "be canceled at any time by calling cancel().\n/\n/ @note The timer uses a task to run in "
      "the background, so the timer\n/       callback function will be called in the context of "
      "the task. The\n/       timer callback function should not block for a long time because "
      "it\n/       will block the task. If the timer callback function blocks for a\n/       long "
      "time, then the timer will not be able to keep up with the\n/       period.\n/\n/ \\section "
      "timer_ex1 Timer Example 1\n/ \\snippet timer_example.cpp timer example\n/ \\section "
      "timer_ex2 Timer Watchdog Example\n/ \\snippet timer_example.cpp timer watchdog example\n/ "
      "\\section timer_ex3 Timer Delay Example\n/ \\snippet timer_example.cpp timer delay "
      "example\n/ \\section timer_ex4 Oneshot Timer Example\n/ \\snippet timer_example.cpp timer "
      "oneshot example\n/ \\section timer_ex5 Timer Cancel Itself Example\n/ \\snippet "
      "timer_example.cpp timer cancel itself example\n/ \\section timer_ex6 Oneshot Timer Cancel "
      "Itself Then Start again with Delay Example\n/ \\snippet timer_example.cpp timer oneshot "
      "restart example\n/ \\section timer_ex7 Timer Update Period Example\n/ \\snippet "
      "timer_example.cpp timer update period example\n/ \\section timer_ex8 Timer AdvancedConfig "
      "Example\n/ \\snippet timer_example.cpp timer advanced config example");

  { // inner classes & enums of Timer
    auto pyClassTimer_ClassConfig =
        py::class_<espp::Timer::Config>(pyClassTimer, "Config", py::dynamic_attr(),
                                        "/ @brief The configuration for the timer.")
            .def(py::init<>([](std::string_view name = std::string_view(),
                               std::chrono::duration<float> period = std::chrono::duration<float>(),
                               std::chrono::duration<float> delay = std::chrono::duration<float>(0),
                               espp::Timer::callback_fn callback = espp::Timer::callback_fn(),
                               bool auto_start = {true}, size_t stack_size_bytes = {4096},
                               size_t priority = {0}, int core_id = {-1},
                               espp::Logger::Verbosity log_level = espp::Logger::Verbosity::WARN) {
                   auto r = std::make_unique<espp::Timer::Config>();
                   r->name = name;
                   r->period = period;
                   r->delay = delay;
                   r->callback = callback;
                   r->auto_start = auto_start;
                   r->stack_size_bytes = stack_size_bytes;
                   r->priority = priority;
                   r->core_id = core_id;
                   r->log_level = log_level;
                   return r;
                 }),
                 py::arg("name") = std::string_view(),
                 py::arg("period") = std::chrono::duration<float>(),
                 py::arg("delay") = std::chrono::duration<float>(0),
                 py::arg("callback") = espp::Timer::callback_fn(),
                 py::arg("auto_start") = bool{true}, py::arg("stack_size_bytes") = size_t{4096},
                 py::arg("priority") = size_t{0}, py::arg("core_id") = int{-1},
                 py::arg("log_level") = espp::Logger::Verbosity::WARN)
            .def_readwrite("name", &espp::Timer::Config::name, "/< The name of the timer.")
            .def_readwrite(
                "period", &espp::Timer::Config::period,
                "/< The period of the timer. If 0, the timer callback will only be called once.")
            .def_readwrite("delay", &espp::Timer::Config::delay,
                           "/< The delay before the first execution of the timer callback after "
                           "start() is called.")
            .def_readwrite("callback", &espp::Timer::Config::callback,
                           "/< The callback function to call when the timer expires.")
            .def_readwrite("auto_start", &espp::Timer::Config::auto_start,
                           "/< If True, the timer will start automatically when constructed.")
            .def_readwrite("stack_size_bytes", &espp::Timer::Config::stack_size_bytes,
                           "/< The stack size of the task that runs the timer.")
            .def_readwrite("priority", &espp::Timer::Config::priority,
                           "/< Priority of the timer, 0 is lowest priority on ESP / FreeRTOS.")
            .def_readwrite("core_id", &espp::Timer::Config::core_id,
                           "/< Core ID of the timer, -1 means it is not pinned to any core.")
            .def_readwrite("log_level", &espp::Timer::Config::log_level,
                           "/< The log level for the timer.");
    auto pyClassTimer_ClassAdvancedConfig =
        py::class_<espp::Timer::AdvancedConfig>(pyClassTimer, "AdvancedConfig", py::dynamic_attr(),
                                                "/ @brief Advanced configuration for the timer.")
            .def(py::init<>([](std::chrono::duration<float> period = std::chrono::duration<float>(),
                               std::chrono::duration<float> delay = std::chrono::duration<float>(0),
                               espp::Timer::callback_fn callback = espp::Timer::callback_fn(),
                               bool auto_start = {true},
                               espp::Task::BaseConfig task_config = espp::Task::BaseConfig(),
                               espp::Logger::Verbosity log_level = espp::Logger::Verbosity::WARN) {
                   auto r = std::make_unique<espp::Timer::AdvancedConfig>();
                   r->period = period;
                   r->delay = delay;
                   r->callback = callback;
                   r->auto_start = auto_start;
                   r->task_config = task_config;
                   r->log_level = log_level;
                   return r;
                 }),
                 py::arg("period") = std::chrono::duration<float>(),
                 py::arg("delay") = std::chrono::duration<float>(0),
                 py::arg("callback") = espp::Timer::callback_fn(),
                 py::arg("auto_start") = bool{true},
                 py::arg("task_config") = espp::Task::BaseConfig(),
                 py::arg("log_level") = espp::Logger::Verbosity::WARN)
            .def_readwrite(
                "period", &espp::Timer::AdvancedConfig::period,
                "/< The period of the timer. If 0, the timer callback will only be called once.")
            .def_readwrite("delay", &espp::Timer::AdvancedConfig::delay,
                           "/< The delay before the first execution of the timer callback after "
                           "start() is called.")
            .def_readwrite("callback", &espp::Timer::AdvancedConfig::callback,
                           "/< The callback function to call when the timer expires.")
            .def_readwrite("auto_start", &espp::Timer::AdvancedConfig::auto_start,
                           "/< If True, the timer will start automatically when constructed.")
            .def_readwrite("task_config", &espp::Timer::AdvancedConfig::task_config,
                           "/< The task configuration for the timer.")
            .def_readwrite("log_level", &espp::Timer::AdvancedConfig::log_level,
                           "/< The log level for the timer.");
  } // end of inner classes & enums of Timer

  pyClassTimer.def(py::init<const espp::Timer::Config &>())
      .def(py::init<const espp::Timer::AdvancedConfig &>())
      .def(
          "start", [](espp::Timer &self) { return self.start(); },
          "/ @brief Start the timer.\n/ @details Starts the timer. Does nothing if the timer is "
          "already running.")
      .def("start", py::overload_cast<const std::chrono::duration<float> &>(&espp::Timer::start),
           py::arg("delay"),
           "/ @brief Start the timer with a delay.\n/ @details Starts the timer with a delay. If "
           "the timer is already running,\n/          this will cancel the timer and start it "
           "again with the new\n/          delay. If the timer is not running, this will start the "
           "timer\n/          with the delay. Overwrites any previous delay that might have\n/     "
           "     been set.\n/ @param delay The delay before the first execution of the timer "
           "callback.")
      .def("stop", &espp::Timer::stop,
           "/ @brief Stop the timer, same as cancel().\n/ @details Stops the timer, same as "
           "cancel().")
      .def("cancel", &espp::Timer::cancel,
           "/ @brief Cancel the timer.\n/ @details Cancels the timer.")
      .def("set_period", &espp::Timer::set_period, py::arg("period"),
           "/ @brief Set the period of the timer.\n/ @details Sets the period of the timer.\n/ "
           "@param period The period of the timer.\n/ @note If the period is 0, the timer will run "
           "once.\n/ @note If the period is negative, the period will not be set / updated.\n/ "
           "@note If the timer is running, the period will be updated after the\n/       current "
           "period has elapsed.")
      .def("is_running", &espp::Timer::is_running,
           "/ @brief Check if the timer is running.\n/ @details Checks if the timer is running.\n/ "
           "@return True if the timer is running, False otherwise.");
  ////////////////////    </generated_from:timer.hpp>    ////////////////////

  ////////////////////    <generated_from:joystick.hpp>    ////////////////////
  auto pyClassJoystick = py::class_<espp::Joystick>(
      m, "Joystick", py::dynamic_attr(),
      "*\n *  @brief 2-axis Joystick with axis mapping / calibration.\n *\n * \\section "
      "joystick_ex1 Basic Circular and Rectangular Joystick Example\n * \\snippet "
      "joystick_example.cpp circular joystick example\n * \\section joystick_ex2 ADC Joystick "
      "Example\n * \\snippet joystick_example.cpp adc joystick example\n");

  { // inner classes & enums of Joystick
    auto pyEnumType = py::enum_<espp::Joystick::Type>(
                          pyClassJoystick, "Type", py::arithmetic(),
                          "*\n   * @brief Type of the joystick.\n   * @note When using a "
                          "Type::CIRCULAR joystick, it's recommended to set the\n   *       "
                          "individual x/y calibration deadzones to be 0 and to only use the\n   *  "
                          "     deadzone_radius field to set the deadzone around the center.\n")
                          .value("rectangular", espp::Joystick::Type::RECTANGULAR,
                                 "/< The default type of joystick. Uses the rangemappers for")
                          .value("circular", espp::Joystick::Type::CIRCULAR,
                                 "/< The joystick is configured to have a circular output. This");
    auto pyClassJoystick_ClassConfig =
        py::class_<espp::Joystick::Config>(
            pyClassJoystick, "Config", py::dynamic_attr(),
            "*\n   *  @brief Configuration structure for the joystick.\n")
            .def(
                py::init<>([](espp::FloatRangeMapper::Config x_calibration =
                                  espp::FloatRangeMapper::Config(),
                              espp::FloatRangeMapper::Config y_calibration =
                                  espp::FloatRangeMapper::Config(),
                              espp::Joystick::Type type = {espp::Joystick::Type::RECTANGULAR},
                              float center_deadzone_radius = {0}, float range_deadzone = {0},
                              espp::Joystick::get_values_fn get_values = {nullptr},
                              espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                  auto r = std::make_unique<espp::Joystick::Config>();
                  r->x_calibration = x_calibration;
                  r->y_calibration = y_calibration;
                  r->type = type;
                  r->center_deadzone_radius = center_deadzone_radius;
                  r->range_deadzone = range_deadzone;
                  r->get_values = get_values;
                  r->log_level = log_level;
                  return r;
                }),
                py::arg("x_calibration") = espp::FloatRangeMapper::Config(),
                py::arg("y_calibration") = espp::FloatRangeMapper::Config(),
                py::arg("type") = espp::Joystick::Type{espp::Joystick::Type::RECTANGULAR},
                py::arg("center_deadzone_radius") = float{0}, py::arg("range_deadzone") = float{0},
                py::arg("get_values") = espp::Joystick::get_values_fn{nullptr},
                py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("x_calibration", &espp::Joystick::Config::x_calibration,
                           "*< Configuration for the x axis.")
            .def_readwrite("y_calibration", &espp::Joystick::Config::y_calibration,
                           "*< Configuration for the y axis.")
            .def_readwrite("type", &espp::Joystick::Config::type,
                           "*< The type of the joystick. See\n                                     "
                           "            Type enum for more information.")
            .def_readwrite(
                "center_deadzone_radius", &espp::Joystick::Config::center_deadzone_radius,
                "*< The radius of the unit circle's deadzone [0, 1.0] around the center, only "
                "used\n        when the joystick is configured as Type::CIRCULAR.")
            .def_readwrite(
                "range_deadzone", &espp::Joystick::Config::range_deadzone,
                "*< The deadzone around the edge of the unit circle, only used when\n              "
                "            the joystick is configured as Type::CIRCULAR. This scales the output "
                "so\n                          that the output appears to have magnitude 1 "
                "(meaning it appears to be on\n                          the edge of the unit "
                "circle) when the joystick value magnitude is within\n                          "
                "the range [1-range_deadzone, 1].")
            .def_readwrite("get_values", &espp::Joystick::Config::get_values,
                           "*< Function to retrieve the latest\n                                   "
                           "       unmapped joystick values. Required if\n                         "
                           "                 you want to use update(), unused if\n                 "
                           "                         you call update(float raw_x, float\n          "
                           "                                raw_y).")
            .def_readwrite("log_level", &espp::Joystick::Config::log_level,
                           "*< Verbosity for the Joystick logger_.");
  } // end of inner classes & enums of Joystick

  pyClassJoystick.def(py::init<const espp::Joystick::Config &>())
      .def(
          "set_type", &espp::Joystick::set_type, py::arg("type"), py::arg("radius") = 0,
          py::arg("range_deadzone") = 0,
          "*\n   *  @brief Set the type of the joystick.\n   *  @param type The Type of the "
          "joystick.\n   *  @param radius Optional radius parameter used when \\p type is\n   *    "
          "     Type::CIRCULAR. When the magnitude of the joystick's mapped\n   *         position "
          "vector is less than this value, the vector is set to\n   *         (0,0).\n   *  @param "
          "range_deadzone Optional deadzone around the edge of the unit circle\n   *         when "
          "\\p type is Type::CIRCULAR. This scales the output so that the\n   *         output "
          "appears to have magnitude 1 (meaning it appears to be on the\n   *         edge of the "
          "unit circle) if the magnitude of the mapped position\n   *         vector is greater "
          "than 1-range_deadzone. Example: if the range\n   *         deadzone is 0.1, then the "
          "output will be scaled so that the\n   *         magnitude of the output is 1 if the "
          "magnitude of the mapped\n   *         position vector is greater than 0.9.\n   *  @note "
          "If the Joystick is Type::CIRCULAR, the actual calibrations that are\n   *        saved "
          "into the joystick will have 0 deadzone around the center value\n   *        and range "
          "values, so that center and range deadzones are actually\n   *        applied on the "
          "vector value instead of on the individual axes\n   *        independently.\n   *  @sa "
          "set_center_deadzone_radius\n   *  @sa set_range_deadzone\n   *  @sa set_calibration\n")
      .def("type", &espp::Joystick::type,
           "*\n   * @brief Get the type of the joystick.\n   * @return The Type of the joystick.\n")
      .def("set_center_deadzone_radius", &espp::Joystick::set_center_deadzone_radius,
           py::arg("radius"),
           "*\n   * @brief Sets the center deadzone radius.\n   * @note Radius is only applied "
           "when \\p deadzone is Deadzone::CIRCULAR.\n   * @param radius Optional radius parameter "
           "used when \\p deadzone is\n   *        Deadzone::CIRCULAR. When the magnitude of the "
           "joystick's mapped\n   *        position vector is less than this value, the vector is "
           "set to\n   *        (0,0).\n")
      .def("center_deadzone_radius", &espp::Joystick::center_deadzone_radius,
           "*\n   * @brief Get the center deadzone radius.\n   * @return The center deadzone "
           "radius.\n")
      .def("set_range_deadzone", &espp::Joystick::set_range_deadzone, py::arg("range_deadzone"),
           "*\n   * @brief Sets the range deadzone.\n   * @note Range deadzone is only applied "
           "when \\p deadzone is Deadzone::CIRCULAR.\n   * @param range_deadzone Optional deadzone "
           "around the edge of the unit circle\n   *        when \\p deadzone is "
           "Deadzone::CIRCULAR. This scales the output so\n   *        that the output appears to "
           "have magnitude 1 (meaning it appears to\n   *        be on the edge of the unit "
           "circle) if the magnitude of the mapped\n   *        position vector is greater than "
           "1-range_deadzone. Example: if the\n   *        range deadzone is 0.1, then the output "
           "will be scaled so that the\n   *        magnitude of the output is 1 if the magnitude "
           "of the mapped position\n   *        vector is greater than 0.9.\n")
      .def("range_deadzone", &espp::Joystick::range_deadzone,
           "*\n   * @brief Get the range deadzone.\n   * @return The range deadzone.\n")
      .def("set_calibration", &espp::Joystick::set_calibration, py::arg("x_calibration"),
           py::arg("y_calibration"), py::arg("center_deadzone_radius") = 0,
           py::arg("range_deadzone") = 0,
           "*\n   * @brief Update the x and y axis mapping.\n   * @param x_calibration New x-axis "
           "range mapping configuration to use.\n   * @param y_calibration New y-axis range "
           "mapping configuration to use.\n   * @param center_deadzone_radius The radius of the "
           "unit circle's deadzone [0,\n   *        1.0] around the center, only used when the "
           "joystick is configured\n   *        as Type::CIRCULAR.\n   *  @param range_deadzone "
           "Optional deadzone around the edge of the unit circle\n   *         when \\p type is "
           "Type::CIRCULAR. This scales the output so that the\n   *         output appears to "
           "have magnitude 1 (meaning it appears to be on the\n   *         edge of the unit "
           "circle) if the magnitude of the mapped position\n   *         vector is greater than "
           "1-range_deadzone. Example: if the range\n   *         deadzone is 0.1, then the output "
           "will be scaled so that the\n   *         magnitude of the output is 1 if the magnitude "
           "of the mapped\n   *         position vector is greater than 0.9.\n   * @note If the "
           "Joystick is Type::CIRCULAR, the actual calibrations that are\n   *       saved into "
           "the joystick will have 0 deadzone around the center and range values,\n   *       so "
           "that center and range deadzones are actually applied on the vector value.\n   * @sa "
           "set_center_deadzone_radius\n   * @sa set_range_deadzone\n")
      .def(
          "update", [](espp::Joystick &self) { return self.update(); },
          "*\n   * @brief Read the raw values and use the calibration data to update the\n   *     "
          "   position.\n   * @note Requires that the get_values_ function is set.\n")
      .def("update", py::overload_cast<float, float>(&espp::Joystick::update), py::arg("raw_x"),
           py::arg("raw_y"),
           "*\n   * @brief Update the joystick's position using the provided raw x and y\n   *     "
           "   values.\n   * @param raw_x The raw x-axis value.\n   * @param raw_y The raw y-axis "
           "value.\n   * @note This function is useful when you have the raw values and don't "
           "want\n   *       to use the get_values_ function.\n")
      .def("x", &espp::Joystick::x,
           "*\n   * @brief Get the most recently updated x axis calibrated position.\n   * @return "
           "The most recent x-axis position (from when update() was last\n   *         called).\n")
      .def("y", &espp::Joystick::y,
           "*\n   * @brief Get the most recently updated y axis calibrated position.\n   * @return "
           "The most recent y-axis position (from when update() was last\n   *         called).\n")
      .def("position", &espp::Joystick::position,
           "*\n   * @brief Get the most recently updated calibrated position.\n   * @return The "
           "most recent position (from when update() was last called).\n")
      .def("raw", &espp::Joystick::raw,
           "*\n   * @brief Get the most recently updated raw / uncalibrated readings. This\n   *   "
           "     function is useful for externally performing a calibration routine\n   *        "
           "and creating updated calibration / mapper configuration\n   *        structures.\n   * "
           "@return The most recent raw measurements (from when update() was last\n   *         "
           "called).\n");
  ////////////////////    </generated_from:joystick.hpp>    ////////////////////

  ////////////////////    <generated_from:lowpass_filter.hpp>    ////////////////////
  auto pyClassLowpassFilter = py::class_<espp::LowpassFilter>(
      m, "LowpassFilter", py::dynamic_attr(),
      "*\n *  @brief Lowpass infinite impulse response (IIR) filter.\n");

  { // inner classes & enums of LowpassFilter
    auto pyClassLowpassFilter_ClassConfig =
        py::class_<espp::LowpassFilter::Config>(
            pyClassLowpassFilter, "Config", py::dynamic_attr(),
            "*\n   *  @brief Configuration for the lowpass filter.\n")
            .def(py::init<>(
                     [](float normalized_cutoff_frequency = float(), float q_factor = float()) {
                       auto r = std::make_unique<espp::LowpassFilter::Config>();
                       r->normalized_cutoff_frequency = normalized_cutoff_frequency;
                       r->q_factor = q_factor;
                       return r;
                     }),
                 py::arg("normalized_cutoff_frequency") = float(), py::arg("q_factor") = float())
            .def_readwrite(
                "normalized_cutoff_frequency",
                &espp::LowpassFilter::Config::normalized_cutoff_frequency,
                "*< Filter cutoff frequency in the range [0.0, 0.5] (normalizd\n                   "
                "                     to sample frequency, = 2 * f_cutoff / f_sample).")
            .def_readwrite(
                "q_factor", &espp::LowpassFilter::Config::q_factor,
                "*< Quality (Q) factor of the filter. The higher the Q the better the filter.");
  } // end of inner classes & enums of LowpassFilter

  pyClassLowpassFilter.def(py::init<>())
      .def("configure", &espp::LowpassFilter::configure, py::arg("config"),
           "*\n   * @brief Set the filter coefficients based on the config.\n   * @param config "
           "Configuration struct.\n")
      .def("update",
           py::overload_cast<const float *, float *, size_t>(&espp::LowpassFilter::update),
           py::arg("input"), py::arg("output"), py::arg("length"),
           "*\n   * @brief Filter the input samples, updating internal state, and writing the\n   "
           "*        filtered values to the data pointed to by output.\n   * @param input Pointer "
           "to (floating point) array of new samples of the input data\n   * @param output Pointer "
           "to (floating point) array which will be filled with\n   *        the filtered input.\n "
           "  * @param length Number of samples, should be >= length of input & output memory.\n   "
           "* @note On ESP32, the input and output arrays must have\n   *       "
           "__attribute__((aligned(16))) to ensure proper alignment for the ESP32\n   *       DSP "
           "functions.\n")
      .def("update", py::overload_cast<const float>(&espp::LowpassFilter::update), py::arg("input"),
           "*\n   * @brief Filter the signal sampled by input, updating internal state, and\n   *  "
           "      returning the filtered output.\n   * @param input New sample of the input "
           "data.\n   * @return Filtered output based on input and history.\n")
      .def("__call__", &espp::LowpassFilter::operator(), py::arg("input"),
           "*\n   * @brief Filter the signal sampled by input, updating internal state, and\n   *  "
           "      returning the filtered output.\n   * @param input New sample of the input "
           "data.\n   * @return Filtered output based on input and history.\n")
      .def("reset", &espp::LowpassFilter::reset,
           "*\n   * @brief Reset the filter state to zero.\n");
  ////////////////////    </generated_from:lowpass_filter.hpp>    ////////////////////

  ////////////////////    <generated_from:simple_lowpass_filter.hpp>    ////////////////////
  auto pyClassSimpleLowpassFilter = py::class_<espp::SimpleLowpassFilter>(
      m, "SimpleLowpassFilter", py::dynamic_attr(),
      "*\n *  @brief Simple lowpass filter using a time constant and a stored value.\n");

  { // inner classes & enums of SimpleLowpassFilter
    auto pyClassSimpleLowpassFilter_ClassConfig =
        py::class_<espp::SimpleLowpassFilter::Config>(
            pyClassSimpleLowpassFilter, "Config", py::dynamic_attr(),
            "*\n   *  @brief Configuration for the lowpass filter.\n")
            .def(py::init<>([](float time_constant = 0.0f) {
                   auto r = std::make_unique<espp::SimpleLowpassFilter::Config>();
                   r->time_constant = time_constant;
                   return r;
                 }),
                 py::arg("time_constant") = 0.0f)
            .def_readwrite("time_constant", &espp::SimpleLowpassFilter::Config::time_constant,
                           "*< Time constant of the filter.");
  } // end of inner classes & enums of SimpleLowpassFilter

  pyClassSimpleLowpassFilter.def(py::init<>())
      .def("set_time_constant", &espp::SimpleLowpassFilter::set_time_constant,
           py::arg("time_constant"),
           "*\n   * @brief Set the time constant of the filter.\n   * @param time_constant Time "
           "constant of the filter.\n")
      .def("get_time_constant", &espp::SimpleLowpassFilter::get_time_constant,
           "*\n   * @brief Get the time constant of the filter.\n   * @return Time constant of the "
           "filter.\n")
      .def("update", &espp::SimpleLowpassFilter::update, py::arg("input"),
           "*\n   * @brief Filter the signal sampled by input, updating internal state, and\n   *  "
           "      returning the filtered output.\n   * @param input New sample of the input "
           "data.\n   * @return Filtered output based on input, time, and history.\n")
      .def("__call__", &espp::SimpleLowpassFilter::operator(), py::arg("input"),
           "*\n   * @brief Filter the signal sampled by input, updating internal state, and\n   *  "
           "      returning the filtered output.\n   * @param input New sample of the input "
           "data.\n   * @return Filtered output based on input, time, and history.\n")
      .def("reset", &espp::SimpleLowpassFilter::reset,
           "*\n   * @brief Reset the filter to its initial state.\n");
  ////////////////////    </generated_from:simple_lowpass_filter.hpp>    ////////////////////

  // </litgen_pydef> // Autogenerated code end
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
