#include <chrono>
#include <memory>
#include <string>
#include <system_error>
#include <vector>

#include <pybind11/chrono.h>
#include <pybind11/functional.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include "espp.hpp"

namespace py = pybind11;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

void py_init_module_espp(py::module &m) {
  // using namespace espp;  // NON!

  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  // <litgen_pydef> // Autogenerated code below! Do not edit!
  ////////////////////    <generated_from:base_component.hpp>    ////////////////////
  auto pyClassBaseComponent =
      py::class_<espp::BaseComponent>(m, "BaseComponent", py::dynamic_attr(),
                                      "/ Base class for all components\n/ Provides a logger and "
                                      "some basic logging configuration")
          .def("get_name", &espp::BaseComponent::get_name,
               "/ Get the name of the component\n/ \\return A const reference to the name of the "
               "component\n/ \note This is the tag of the logger")
          .def("set_log_tag", &espp::BaseComponent::set_log_tag, py::arg("tag"),
               "/ Set the tag for the logger\n/ \\param tag The tag to use for the logger")
          .def("get_log_level", &espp::BaseComponent::get_log_level,
               "/ Get the log level for the logger\n/ \\return The verbosity level of the "
               "logger\n/ \\sa Logger::Verbosity\n/ \\sa Logger::set_verbosity")
          .def("set_log_level", &espp::BaseComponent::set_log_level, py::arg("level"),
               "/ Set the log level for the logger\n/ \\param level The verbosity level to use for "
               "the logger\n/ \\sa Logger::Verbosity\n/ \\sa Logger::set_verbosity")
          .def("set_log_verbosity", &espp::BaseComponent::set_log_verbosity, py::arg("level"),
               "/ Set the log verbosity for the logger\n/ \\param level The verbosity level to use "
               "for the logger\n/ \note This is a convenience method that calls set_log_level\n/ "
               "\\sa set_log_level\n/ \\sa Logger::Verbosity\n/ \\sa Logger::set_verbosity")
          .def("get_log_verbosity", &espp::BaseComponent::get_log_verbosity,
               "/ Get the log verbosity for the logger\n/ \\return The verbosity level of the "
               "logger\n/ \note This is a convenience method that calls get_log_level\n/ \\sa "
               "get_log_level\n/ \\sa Logger::Verbosity\n/ \\sa Logger::get_verbosity")
          .def("set_log_rate_limit", &espp::BaseComponent::set_log_rate_limit,
               py::arg("rate_limit"),
               "/ Set the rate limit for the logger\n/ \\param rate_limit The rate limit to use "
               "for the logger\n/ \note Only calls to the logger that have _rate_limit suffix will "
               "be rate limited\n/ \\sa Logger::set_rate_limit");
  ////////////////////    </generated_from:base_component.hpp>    ////////////////////

  ////////////////////    <generated_from:color.hpp>    ////////////////////
  auto pyClassRgb =
      py::class_<espp::Rgb>(m, "Rgb", py::dynamic_attr(),
                            "*\n * @brief Class representing a color using RGB color space.\n")
          .def_readwrite("r", &espp::Rgb::r, "/< Red value ∈ [0, 1]")
          .def_readwrite("g", &espp::Rgb::g, "/< Green value ∈ [0, 1]")
          .def_readwrite("b", &espp::Rgb::b, "/< Blue value ∈ [0, 1]")
          .def(py::init<>())
          .def(py::init<const float &, const float &, const float &>(), py::arg("r"), py::arg("g"),
               py::arg("b"),
               "*\n   * @brief Construct an Rgb object from the provided rgb values.\n   * @note "
               "If provided values outside the range [0,1], it will rescale them to\n   *       be "
               "within the range [0,1] by dividing by 255.\n   * @param r Floating point value for "
               "the red channel, should be in range [0,\n   *        1]\n   * @param g Floating "
               "point value for the green channel, should be in range\n   *        [0, 1]\n   * "
               "@param b Floating point value for the blue channel, should be in range\n   *       "
               " [0, 1]\n")
          .def(py::init<const espp::Rgb &>(), py::arg("rgb"),
               "*\n   * @brief Copy-construct an Rgb object from the provided object.\n   * @note "
               "If provided values outside the range [0,1], it will rescale them to\n   *       be "
               "within the range [0,1] by dividing by 255.\n   * @param rgb Rgb struct containing "
               "the values to copy.\n")
          .def(py::init<const espp::Hsv &>(), py::arg("hsv"),
               "*\n   * @brief Construct an Rgb object from the provided Hsv object.\n   * @note "
               "This calls hsv.rgb() on the provided object, which means that invalid\n   *       "
               "HSV data (not in the ranges [0,360], [0,1], and [0,1]) could lead to\n   *       "
               "bad RGB data. The Rgb constructor will automatically convert the\n   *       "
               "values to be in the proper range, but the perceived color will be\n   *       "
               "changed.\n   * @param hsv Hsv object to copy.\n")
          .def(py::init<const uint32_t &>(), py::arg("hex"),
               "*\n   * @brief Construct an Rgb object from the provided hex value.\n   * @param "
               "hex Hex value to convert to RGB. The hex value should be in the\n   *        "
               "format 0xRRGGBB.\n")
          .def("__add__", &espp::Rgb::operator+, py::arg("rhs"),
               "*\n   * @brief Perform additive color blending (averaging)\n   * @param rhs Other "
               "color to add to this color to create the resultant color\n   * @return Resultant "
               "color from blending this color with the \\p rhs color.\n")
          .def("__iadd__", &espp::Rgb::operator+=, py::arg("rhs"),
               "*\n   * @brief Perform additive color blending (averaging)\n   * @param rhs Other "
               "color to add to this color\n")
          .def("__eq__", &espp::Rgb::operator==, py::arg("rhs"))
          .def("__ne__", &espp::Rgb::operator!=, py::arg("rhs"))
          .def("hsv", &espp::Rgb::hsv,
               "*\n   * @brief Get a HSV representation of this RGB color.\n   * @return An HSV "
               "object containing the HSV representation.\n")
          .def("hex", &espp::Rgb::hex,
               "*\n   * @brief Get the hex representation of this RGB color.\n   * @return The hex "
               "representation of this RGB color.\n");

  auto pyClassHsv =
      py::class_<espp::Hsv>(m, "Hsv", py::dynamic_attr(),
                            "*\n * @brief Class representing a color using HSV color space.\n")
          .def_readwrite("h", &espp::Hsv::h, "/< Hue ∈ [0, 360]")
          .def_readwrite("s", &espp::Hsv::s, "/< Saturation ∈ [0, 1]")
          .def_readwrite("v", &espp::Hsv::v, "/< Value ∈ [0, 1]")
          .def(py::init<>())
          .def(py::init<const float &, const float &, const float &>(), py::arg("h"), py::arg("s"),
               py::arg("v"),
               "*\n   * @brief Construct a Hsv object from the provided values.\n   * @param h Hue "
               "- will be clamped to be in range [0, 360]\n   * @param s Saturation - will be "
               "clamped to be in range [0, 1]\n   * @param v Value - will be clamped to be in "
               "range [0, 1]\n")
          .def(py::init<const espp::Hsv &>(), py::arg("hsv"),
               "*\n   * @brief Copy-construct the Hsv object\n   * @param hsv Object to copy "
               "from.\n")
          .def(py::init<const espp::Rgb &>(), py::arg("rgb"),
               "*\n   * @brief Construct Hsv object from Rgb object. Calls rgb.hsv() to perform\n  "
               " *        the conversion.\n   * @param rgb The Rgb object to convert and copy.\n")
          .def("__eq__", &espp::Hsv::operator==, py::arg("rhs"))
          .def("__ne__", &espp::Hsv::operator!=, py::arg("rhs"))
          .def("rgb", &espp::Hsv::rgb,
               "*\n   * @brief Get a RGB representation of this HSV color.\n   * @return An RGB "
               "object containing the RGB representation.\n");

  m.def("color_code", py::overload_cast<const espp::Rgb &>(espp::color_code), py::arg("rgb"),
        "\n(C++ auto return type)");

  m.def("color_code", py::overload_cast<const espp::Hsv &>(espp::color_code), py::arg("hsv"),
        "\n(C++ auto return type)");
  ////////////////////    </generated_from:color.hpp>    ////////////////////

  ////////////////////    <generated_from:event_manager.hpp>    ////////////////////
  auto pyClassEventManager =
      py::class_<espp::EventManager>(
          m, "EventManager", py::dynamic_attr(),
          "*\n * @brief Singleton class for managing events. Provides mechanisms for\n *        "
          "anonymous publish / subscribe interactions - enabling one to one,\n *        one to "
          "many, many to one, and many to many data distribution with\n *        loose coupling "
          "and low overhead. Each topic runs a thread for that\n *        topic's subscribers, "
          "executing all the callbacks in sequence and\n *        then going to sleep again until "
          "new data is published.\n *\n * @note In c++ objects, it's recommended to call the\n *   "
          "    add_publisher/add_subscriber functions in the class constructor and\n *       then "
          "to call the remove_publisher/remove_subscriber functions in the\n *       class "
          "destructor.\n *\n * @note It is recommended (unless you are only interested in events "
          "and not\n *       data or are only needing to transmit actual strings) to use a\n *     "
          "  serialization library (such as espp::serialization - which wraps\n *       alpaca) to "
          "serialize your data structures to string when publishing\n *       and then deserialize "
          "your data from string in the subscriber\n *       callbacks.\n *\n * \\section "
          "event_manager_ex1 Event Manager Example\n * \\snippet event_manager_example.cpp event "
          "manager example\n")
          .def_static("get", &espp::EventManager::get,
                      "*\n   * @brief Get the singleton instance of the EventManager.\n   * "
                      "@return A reference to the EventManager singleton.\n",
                      pybind11::return_value_policy::reference)
          .def("add_publisher", &espp::EventManager::add_publisher, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Register a publisher for \\p component on \\p topic.\n   * @param "
               "topic Topic name for the data being published.\n   * @param component Name of the "
               "component publishing data.\n   * @return True if the publisher was added, False if "
               "it was already\n   *         registered for that component.\n")
          .def("add_subscriber",
               py::overload_cast<const std::string &, const std::string &,
                                 const espp::EventManager::event_callback_fn &, const size_t>(
                   &espp::EventManager::add_subscriber),
               py::arg("topic"), py::arg("component"), py::arg("callback"),
               py::arg("stack_size_bytes") = 8192,
               "*\n   * @brief Register a subscriber for \\p component on \\p topic.\n   * @param "
               "topic Topic name for the data being subscribed to.\n   * @param component Name of "
               "the component publishing data.\n   * @param callback The event_callback_fn to be "
               "called when receicing data on\n   *        \\p topic.\n   * @param "
               "stack_size_bytes The stack size in bytes to use for the subscriber\n   * @note The "
               "stack size is only used if a subscriber is not already registered\n   *       for "
               "that topic. If a subscriber is already registered for that topic,\n   *       the "
               "stack size is ignored.\n   * @return True if the subscriber was added, False if it "
               "was already\n   *         registered for that component.\n")
          .def("add_subscriber",
               py::overload_cast<const std::string &, const std::string &,
                                 const espp::EventManager::event_callback_fn &,
                                 const espp::Task::BaseConfig &>(
                   &espp::EventManager::add_subscriber),
               py::arg("topic"), py::arg("component"), py::arg("callback"), py::arg("task_config"),
               "*\n   * @brief Register a subscriber for \\p component on \\p topic.\n   * @param "
               "topic Topic name for the data being subscribed to.\n   * @param component Name of "
               "the component publishing data.\n   * @param callback The event_callback_fn to be "
               "called when receicing data on\n   *        \\p topic.\n   * @param task_config The "
               "task configuration to use for the subscriber.\n   * @note The task_config is only "
               "used if a subscriber is not already\n   *       registered for that topic. If a "
               "subscriber is already registered for\n   *       that topic, the task_config is "
               "ignored.\n   * @return True if the subscriber was added, False if it was already\n "
               "  *         registered for that component.\n")
          .def("publish", &espp::EventManager::publish, py::arg("topic"), py::arg("data"),
               "*\n   * @brief Publish \\p data on \\p topic.\n   * @param topic Topic to publish "
               "data on.\n   * @param data Data to publish, within a vector container.\n   * "
               "@return True if \\p data was successfully published to \\p topic, False\n   *      "
               "   otherwise. Publish will not occur (and will return False) if\n   *         "
               "there are no subscribers for this topic.\n")
          .def("remove_publisher", &espp::EventManager::remove_publisher, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Remove \\p component's publisher for \\p topic.\n   * @param topic "
               "The topic that \\p component was publishing on.\n   * @param component The "
               "component for which the publisher was registered.\n   * @return True if the "
               "publisher was removed, False if it was not\n   *         registered.\n")
          .def("remove_subscriber", &espp::EventManager::remove_subscriber, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Remove \\p component's subscriber for \\p topic.\n   * @param topic "
               "The topic that \\p component was subscribing to.\n   * @param component The "
               "component for which the subscriber was registered.\n   * @return True if the "
               "subscriber was removed, False if it was not\n   *         registered.\n");
  ////////////////////    </generated_from:event_manager.hpp>    ////////////////////

  ////////////////////    <generated_from:ftp_server.hpp>    ////////////////////
  auto pyClassFtpServer =
      py::class_<espp::FtpServer>(m, "FtpServer", py::dynamic_attr(),
                                  "/ \\brief A class that implements a FTP server.")
          .def(py::init<std::string_view, uint16_t, const std::filesystem::path &>(),
               py::arg("ip_address"), py::arg("port"), py::arg("root"),
               "/ \\brief A class that implements a FTP server.\n/ \note The IP Address is not "
               "currently used to select the right\n/       interface, but is instead passed to "
               "the FtpClientSession so that\n/       it can be used in the PASV command.\n/ "
               "\\param ip_address The IP address to listen on.\n/ \\param port The port to listen "
               "on.\n/ \\param root The root directory of the FTP server.")
          .def("start", &espp::FtpServer::start,
               "/ \\brief Start the FTP server.\n/ Bind to the port and start accepting "
               "connections.\n/ \\return True if the server was started, False otherwise.")
          .def("stop", &espp::FtpServer::stop, "/ \\brief Stop the FTP server.");
  ////////////////////    </generated_from:ftp_server.hpp>    ////////////////////

  ////////////////////    <generated_from:logger.hpp>    ////////////////////
  auto pyClassLogger = py::class_<espp::Logger>(
      m, "Logger", py::dynamic_attr(),
      "*\n * @brief Logger provides a wrapper around nicer / more robust formatting than\n * "
      "standard ESP_LOG* macros with the ability to change the log level at\n * run-time. Logger "
      "currently is a light wrapper around libfmt (future\n * std::format).\n *\n * To save on "
      "code size, the logger has the ability to be compiled out based on\n * the log level set in "
      "the sdkconfig. This means that if the log level is set to\n * ERROR, all debug, info, and "
      "warn logs will be compiled out. This is done by\n * checking the log level at compile time "
      "and only compiling in the functions\n * that are needed.\n *\n * \\section logger_ex1 Basic "
      "Example\n * \\snippet logger_example.cpp Logger example\n * \\section logger_ex2 Threaded "
      "Logging and Verbosity Example\n * \\snippet logger_example.cpp MultiLogger example\n");

  { // inner classes & enums of Logger
    py::enum_<espp::Logger::Verbosity>(
        pyClassLogger, "Verbosity", py::arithmetic(),
        "*\n   *   Verbosity levels for the logger, in order of increasing priority.\n")
        .value("debug", espp::Logger::Verbosity::DEBUG, "*< Debug level verbosity.")
        .value("info", espp::Logger::Verbosity::INFO, "*< Info level verbosity.")
        .value("warn", espp::Logger::Verbosity::WARN, "*< Warn level verbosity.")
        .value("error", espp::Logger::Verbosity::ERROR, "*< Error level verbosity.")
        .value("none", espp::Logger::Verbosity::NONE,
               "*< No verbosity - logger will not print anything.");
    auto pyClassLogger_ClassConfig =
        py::class_<espp::Logger::Config>(pyClassLogger, "Config", py::dynamic_attr(),
                                         "*\n   * @brief Configuration struct for the logger.\n")
            .def(py::init<>(
                     [](std::string_view tag = std::string_view(), bool include_time = {true},
                        std::chrono::duration<float> rate_limit = std::chrono::duration<float>(0),
                        espp::Logger::Verbosity level = espp::Logger::Verbosity::WARN) {
                       auto r = std::make_unique<espp::Logger::Config>();
                       r->tag = tag;
                       r->include_time = include_time;
                       r->rate_limit = rate_limit;
                       r->level = level;
                       return r;
                     }),
                 py::arg("tag") = std::string_view(), py::arg("include_time") = bool{true},
                 py::arg("rate_limit") = std::chrono::duration<float>(0),
                 py::arg("level") = espp::Logger::Verbosity::WARN)
            .def_readwrite("tag", &espp::Logger::Config::tag,
                           "*< The TAG that will be prepended to all logs.")
            .def_readwrite("include_time", &espp::Logger::Config::include_time,
                           "*< Include the time in the log.")
            .def_readwrite(
                "rate_limit", &espp::Logger::Config::rate_limit,
                "*< The rate limit for the logger. Optional, if <= 0 no\nrate limit. @note Only "
                "calls that have _rate_limited suffixed will be rate limited.")
            .def_readwrite("level", &espp::Logger::Config::level,
                           "*< The verbosity level for the logger.");
  } // end of inner classes & enums of Logger

  pyClassLogger
      .def("set_verbosity", &espp::Logger::set_verbosity, py::arg("level"),
           "*\n   * @brief Change the verbosity for the logger. \\sa Logger::Verbosity\n   * "
           "@param level new verbosity level\n")
      .def("set_tag", &espp::Logger::set_tag, py::arg("tag"),
           "*\n   * @brief Change the tag for the logger.\n   * @param tag The new tag.\n")
      .def("get_tag", &espp::Logger::get_tag,
           "*\n   * @brief Get the current tag for the logger.\n   * @return A const reference to "
           "the current tag.\n")
      .def("set_include_time", &espp::Logger::set_include_time, py::arg("include_time"),
           "*\n   * @brief Whether to include the time in the log.\n   * @param include_time "
           "Whether to include the time in the log.\n   * @note The time is in seconds since boot "
           "and is represented as a floating\n   *       point number with precision to the "
           "millisecond.\n")
      .def("set_rate_limit", &espp::Logger::set_rate_limit, py::arg("rate_limit"),
           "*\n   * @brief Change the rate limit for the logger.\n   * @param rate_limit The new "
           "rate limit.\n   * @note Only calls that have _rate_limited suffixed will be rate "
           "limited.\n")
      .def("get_rate_limit", &espp::Logger::get_rate_limit,
           "*\n   * @brief Get the current rate limit for the logger.\n   * @return The current "
           "rate limit.\n");
  ////////////////////    </generated_from:logger.hpp>    ////////////////////

  ////////////////////    <generated_from:bezier.hpp>    ////////////////////
  auto pyClassBezier_espp_Vector2f = py::class_<espp::Bezier<espp::Vector2f>>(
      m, "Bezier_espp_Vector2f", py::dynamic_attr(),
      "*\n * @brief Implements rational / weighted and unweighted cubic bezier curves\n *        "
      "between control points.\n * @note See https://pomax.github.io/bezierinfo/ for information "
      "on bezier\n *       curves.\n * @note Template class which can be used individually on "
      "floating point\n *       values directly or on containers such as Vector2<float>.\n * "
      "@tparam T The type of the control points, e.g. float or Vector2<float>.\n * @note The "
      "bezier curve is defined by 4 control points, P0, P1, P2, P3.\n *      The curve is defined "
      "by the equation:\n *      \\f$B(t) = (1-t)^3 * P0 + 3 * (1-t)^2 * t * P1 + 3 * (1-t) * t^2 "
      "* P2 + t^3 * P3\\f$\n *      where t is the evaluation parameter, [0, 1].\n *\n * @note The "
      "weighted bezier curve is defined by 4 control points, P0, P1, P2, P3\n *      and 4 "
      "weights, W0, W1, W2, W3.\n *      The curve is defined by the equation:\n *      \\f$B(t) = "
      "(W0 * (1-t)^3 * P0 + W1 * 3 * (1-t)^2 * t * P1 + W2 * 3 * (1-t) * t^2 * P2 + W3 *\n * t^3 * "
      "P3) / (W0 + W1 + W2 + W3)\\f$ where t is the evaluation parameter, [0, 1].\n *\n * "
      "\\section bezier_ex1 Example\n * \\snippet math_example.cpp bezier example\n");

  { // inner classes & enums of Bezier_espp_Vector2f
    auto pyClassBezier_ClassConfig =
        py::class_<espp::Bezier<espp::Vector2f>::Config>(
            pyClassBezier_espp_Vector2f, "Config", py::dynamic_attr(),
            "*\n   * @brief Unweighted cubic bezier configuration for 4 control points.\n")
            .def(py::init<>()) // implicit default constructor
            .def_readwrite("control_points", &espp::Bezier<espp::Vector2f>::Config::control_points,
                           "/< Array of 4 control points");
    auto pyClassBezier_ClassWeightedConfig =
        py::class_<espp::Bezier<espp::Vector2f>::WeightedConfig>(
            pyClassBezier_espp_Vector2f, "WeightedConfig", py::dynamic_attr(),
            "*\n   * @brief Weighted cubic bezier configuration for 4 control points with\n   *    "
            "    individual weights.\n")
            .def(py::init<>()) // implicit default constructor
            .def_readwrite("control_points",
                           &espp::Bezier<espp::Vector2f>::WeightedConfig::control_points,
                           "/< Array of 4 control points")
            .def_readwrite("weights", &espp::Bezier<espp::Vector2f>::WeightedConfig::weights,
                           "/< Array of 4 weights, default is array of 1.0");
  } // end of inner classes & enums of Bezier_espp_Vector2f

  pyClassBezier_espp_Vector2f.def(py::init<const espp::Bezier<espp::Vector2f>::Config &>())
      .def(py::init<const espp::Bezier<espp::Vector2f>::WeightedConfig &>())
      .def("__call__", &espp::Bezier<espp::Vector2f>::operator(), py::arg("t"),
           "*\n   * @brief Evaluate the bezier at \\p t.\n   * @note Convienience wrapper around "
           "the at() method.\n   * @param t The evaluation parameter, [0, 1].\n   * @return The "
           "bezier evaluated at \\p t.\n");
  ////////////////////    </generated_from:bezier.hpp>    ////////////////////

  ////////////////////    <generated_from:fast_math.hpp>    ////////////////////
  m.def("square", espp::square, py::arg("f"),
        "*\n * @brief Simple square of the input.\n * @param f Value to square.\n * @return The "
        "square of f (f*f).\n");

  m.def("cube", espp::cube, py::arg("f"),
        "*\n * @brief Simple cube of the input.\n * @param f Value to cube.\n * @return The cube "
        "of f (f*f*f).\n");

  m.def("fast_sqrt", espp::fast_sqrt, py::arg("value"),
        "*\n * @brief Fast square root approximation.\n * @note Using "
        "https://reprap.org/forum/read.php?147,219210 and\n *       "
        "https://en.wikipedia.org/wiki/Fast_inverse_square_root\n * @param value Value to take the "
        "square root of.\n * @return Approximation of the square root of value.\n");

  m.def("sgn", py::overload_cast<int>(espp::sgn<int>), py::arg("x"),
        "*\n * @brief Get the sign of a number (+1, 0, or -1)\n * @param x Value to get the sign "
        "of\n * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0\n");
  m.def("sgn", py::overload_cast<float>(espp::sgn<float>), py::arg("x"),
        "*\n * @brief Get the sign of a number (+1, 0, or -1)\n * @param x Value to get the sign "
        "of\n * @return Sign of x: -1 if x < 0, 0 if x == 0, or +1 if x > 0\n");

  m.def("lerp", espp::lerp, py::arg("a"), py::arg("b"), py::arg("t"),
        "*\n * @brief Linear interpolation between two values.\n * @param a First value.\n * "
        "@param b Second value.\n * @param t Interpolation factor in the range [0, 1].\n * @return "
        "Linear interpolation between a and b.\n");

  m.def("inv_lerp", espp::inv_lerp, py::arg("a"), py::arg("b"), py::arg("v"),
        "*\n * @brief Compute the inverse lerped value.\n * @param a First value (usually the "
        "lower of the two).\n * @param b Second value (usually the higher of the two).\n * @param "
        "v Value to inverse lerp (usually a value between a and b).\n * @return Inverse lerp "
        "value, the factor of v between a and b in the range [0,\n *         1] if v is between a "
        "and b, 0 if v == a, or 1 if v == b. If a == b,\n *         0 is returned. If v is outside "
        "the range [a, b], the value is\n *         extrapolated linearly (i.e. if v < a, the "
        "value is less than 0, if v\n *         > b, the value is greater than 1).\n");

  m.def(
      "piecewise_linear", espp::piecewise_linear, py::arg("points"), py::arg("x"),
      "*\n * @brief Compute the piecewise linear interpolation between a set of points.\n * @param "
      "points Vector of points to interpolate between. The vector should be\n *               "
      "sorted by the first value in the pair. The first value in the\n *               pair is the "
      "x value and the second value is the y value. The x\n *               values should be "
      "unique. The function will interpolate between\n *               the points using linear "
      "interpolation. If x is less than the\n *               first x value, the first y value is "
      "returned. If x is greater\n *               than the last x value, the last y value is "
      "returned. If x is\n *               between two x values, the y value is interpolated "
      "between the\n *               two y values.\n * @param x Value to interpolate at. Should be "
      "a value from the first\n *          distribution of the points (the domain). If x is "
      "outside the domain\n *          of the points, the value returned will be clamped to the "
      "first or\n *          last y value.\n * @return Interpolated value at x.\n");

  m.def("round", espp::round, py::arg("x"),
        "*\n * @brief Round x to the nearest integer.\n * @param x Floating point value to be "
        "rounded.\n * @return Nearest integer to x.\n");

  m.def("fast_ln", espp::fast_ln, py::arg("x"),
        "*\n * @brief fast natural log function, ln(x).\n * @note This speed hack comes from:\n *  "
        " https://gist.github.com/LingDong-/7e4c4cae5cbbc44400a05ba650623\n * @param x Value to "
        "take the natural log of.\n * @return ln(x)\n");

  m.def("fast_sin", espp::fast_sin, py::arg("angle"),
        "*\n * @brief Fast approximation of sin(angle) (radians).\n * @note \\p Angle must be in "
        "the range [0, 2PI].\n * @param angle Angle in radians [0, 2*PI]\n * @return Approximation "
        "of sin(value)\n");

  m.def("fast_cos", espp::fast_cos, py::arg("angle"),
        "*\n * @brief Fast approximation of cos(angle) (radians).\n * @note \\p Angle must be in "
        "the range [0, 2PI].\n * @param angle Angle in radians [0, 2*PI]\n * @return Approximation "
        "of cos(value)\n");
  ////////////////////    </generated_from:fast_math.hpp>    ////////////////////

  ////////////////////    <generated_from:gaussian.hpp>    ////////////////////
  auto pyClassGaussian = py::class_<espp::Gaussian>(
      m, "Gaussian", py::dynamic_attr(),
      "*\n * @brief Implements a gaussian function\n *        "
      "\\f$y(t)=\\alpha\\exp(-\\frac{(t-\\beta)^2}{2\\gamma^2})\\f$.\n * @details Alows you to "
      "store the alpha, beta, and gamma coefficients as well\n *          as update them "
      "dynamically.\n *\n * \\section gaussian_ex1 Example\n * \\snippet math_example.cpp gaussian "
      "example\n * \\section gaussian_ex2 Fade-In/Fade-Out Example\n * \\snippet math_example.cpp "
      "gaussian fade in fade out example\n");

  { // inner classes & enums of Gaussian
    auto pyClassGaussian_ClassConfig =
        py::class_<espp::Gaussian::Config>(
            pyClassGaussian, "Config", py::dynamic_attr(),
            "*\n   * @brief Configuration structure for initializing the gaussian.\n")
            .def(py::init<>([](float gamma = float(), float alpha = {1.0f}, float beta = {0.5f}) {
                   auto r = std::make_unique<espp::Gaussian::Config>();
                   r->gamma = gamma;
                   r->alpha = alpha;
                   r->beta = beta;
                   return r;
                 }),
                 py::arg("gamma") = float(), py::arg("alpha") = float{1.0f},
                 py::arg("beta") = float{0.5f})
            .def_readwrite(
                "gamma", &espp::Gaussian::Config::gamma,
                "/< Slope of the gaussian, range [0, 1]. 0 is more of a thin spike from 0 up to")
            .def_readwrite("alpha", &espp::Gaussian::Config::alpha,
                           "/< Max amplitude of the gaussian output, defautls to 1.0.")
            .def_readwrite(
                "beta", &espp::Gaussian::Config::beta,
                "/< Beta value for the gaussian, default to be symmetric at 0.5 in range [0,1].")
            .def("__eq__", &espp::Gaussian::Config::operator==, py::arg("rhs"));
  } // end of inner classes & enums of Gaussian

  pyClassGaussian
      .def(py::init<espp::Gaussian::Config>()) // implicit default constructor
      .def("__call__", &espp::Gaussian::operator(), py::arg("t"),
           "*\n   * @brief Evaluate the gaussian at \\p t.\n   * @note Convienience wrapper around "
           "the at() method.\n   * @param t The evaluation parameter, [0, 1].\n   * @return The "
           "gaussian evaluated at \\p t.\n")
      .def("update", &espp::Gaussian::update, py::arg("config"),
           "*\n   * @brief Update the gaussian configuration.\n   * @param config The new "
           "configuration.\n")
      .def("set_config", &espp::Gaussian::set_config, py::arg("config"),
           "*\n   * @brief Set the configuration of the gaussian.\n   * @param config The new "
           "configuration.\n")
      .def("get_config", &espp::Gaussian::get_config,
           "*\n   * @brief Get the current configuration of the gaussian.\n   * @return The "
           "current configuration.\n")
      .def("get_gamma", &espp::Gaussian::get_gamma,
           "*\n   * @brief Get the gamma value.\n   * @return The gamma value.\n")
      .def("get_alpha", &espp::Gaussian::get_alpha,
           "*\n   * @brief Get the alpha value.\n   * @return The alpha value.\n")
      .def("get_beta", &espp::Gaussian::get_beta,
           "*\n   * @brief Get the beta value.\n   * @return The beta value.\n")
      .def("set_gamma", &espp::Gaussian::set_gamma, py::arg("gamma"),
           "*\n   * @brief Set the gamma value.\n   * @param gamma The new gamma value.\n")
      .def("set_alpha", &espp::Gaussian::set_alpha, py::arg("alpha"),
           "*\n   * @brief Set the alpha value.\n   * @param alpha The new alpha value.\n")
      .def("set_beta", &espp::Gaussian::set_beta, py::arg("beta"),
           "*\n   * @brief Set the beta value.\n   * @param beta The new beta value.\n");
  ////////////////////    </generated_from:gaussian.hpp>    ////////////////////

  ////////////////////    <generated_from:range_mapper.hpp>    ////////////////////
  auto pyClassRangeMapper_int = py::class_<espp::RangeMapper<int>>(
      m, "RangeMapper_int", py::dynamic_attr(),
      "*\n * @brief Template class for converting a value from an uncentered [minimum,\n *        "
      "maximum] range into a centered output range (default [-1,1]). If\n *        provided a "
      "non-zero deadband, it will convert all values within\n *        [center-deadband, "
      "center+deadband] to be the configured\n *        output_center (default 0).\n *\n *        "
      "The RangeMapper can be optionally configured to invert the input,\n *        so that it "
      "will compute the input w.r.t. the configured min/max of\n *        the input range when "
      "mapping to the output range - this will mean\n *        that a values within the ranges "
      "[minimum, minimum+deadband] and\n *        [maximum-deadband, maximum] will all map to the "
      "output_center and\n *        the input center will map to both output_max and output_min\n "
      "*        depending on the sign of the input.\n *\n * @note When inverting the input range, "
      "you are introducing a discontinuity\n *       between the input distribution and the output "
      "distribution at the\n *       input center. Noise around the input's center value will "
      "create\n *       oscillations in the output which will jump between output maximum\n *      "
      " and output minimum. Therefore it is advised to use \\p invert_input\n *       sparignly, "
      "and to set the values robustly.\n *\n *        The RangeMapper can be optionally configured "
      "to invert the output,\n *        so that after converting from the input range to the "
      "output range,\n *        it will flip the sign on the output.\n *\n * \\section "
      "range_mapper_ex1 Example\n * \\snippet math_example.cpp range_mapper example\n");

  { // inner classes & enums of RangeMapper_int
    auto pyClassRangeMapper_ClassConfig =
        py::class_<espp::RangeMapper<int>::Config>(
            pyClassRangeMapper_int, "Config", py::dynamic_attr(),
            "*\n   *  @brief Configuration for the input uncentered range with optional\n   *  "
            "values for the centered output range, default values of 0 output center\n   *  and 1 "
            "output range provide a default output range between [-1, 1].\n")
            .def(py::init<>([](int center = int(), int center_deadband = 0, int minimum = int(),
                               int maximum = int(), int range_deadband = 0, int output_center = 0,
                               int output_range = 1, bool invert_output = false) {
                   auto r = std::make_unique<espp::RangeMapper<int>::Config>();
                   r->center = center;
                   r->center_deadband = center_deadband;
                   r->minimum = minimum;
                   r->maximum = maximum;
                   r->range_deadband = range_deadband;
                   r->output_center = output_center;
                   r->output_range = output_range;
                   r->invert_output = invert_output;
                   return r;
                 }),
                 py::arg("center") = int(), py::arg("center_deadband") = 0,
                 py::arg("minimum") = int(), py::arg("maximum") = int(),
                 py::arg("range_deadband") = 0, py::arg("output_center") = 0,
                 py::arg("output_range") = 1, py::arg("invert_output") = false)
            .def_readwrite("center", &espp::RangeMapper<int>::Config::center,
                           "*< Center value for the input range.")
            .def_readwrite("center_deadband", &espp::RangeMapper<int>::Config::center_deadband,
                           "*< Deadband amount around (+-) the center for which output will be 0.")
            .def_readwrite("minimum", &espp::RangeMapper<int>::Config::minimum,
                           "*< Minimum value for the input range.")
            .def_readwrite("maximum", &espp::RangeMapper<int>::Config::maximum,
                           "*< Maximum value for the input range.")
            .def_readwrite("range_deadband", &espp::RangeMapper<int>::Config::range_deadband,
                           "*< Deadband amount around the minimum and maximum for which output "
                           "will\n                             be min/max output.")
            .def_readwrite("output_center", &espp::RangeMapper<int>::Config::output_center,
                           "*< The center for the output. Default 0.")
            .def_readwrite(
                "output_range", &espp::RangeMapper<int>::Config::output_range,
                "*< The range (+/-) from the center for the output. Default 1. @note Will\n        "
                "                     be passed through std::abs() to ensure it is positive.")
            .def_readwrite("invert_output", &espp::RangeMapper<int>::Config::invert_output,
                           "*< Whether to invert the output (default False). @note If True will "
                           "flip the sign\n                  of the output after converting from "
                           "the input distribution.");
  } // end of inner classes & enums of RangeMapper_int

  pyClassRangeMapper_int.def(py::init<espp::RangeMapper<int>::Config>())
      .def("get_center_deadband", &espp::RangeMapper<int>::get_center_deadband,
           "*\n   * @brief Return the configured deadband around the center of the input\n   *     "
           "   distribution\n   * @return Deadband around the center of the input distribution for "
           "this\n   *         range mapper.\n")
      .def("get_minimum", &espp::RangeMapper<int>::get_minimum,
           "*\n   * @brief Return the configured minimum of the input distribution\n   * @return "
           "Minimum of the input distribution for this range mapper.\n")
      .def("get_maximum", &espp::RangeMapper<int>::get_maximum,
           "*\n   * @brief Return the configured maximum of the input distribution\n   * @return "
           "Maximum of the input distribution for this range mapper.\n")
      .def(
          "get_range", &espp::RangeMapper<int>::get_range,
          "*\n   * @brief Return the configured range of the input distribution\n   * @note Always "
          "positive.\n   * @return Range of the input distribution for this range mapper.\n")
      .def("get_range_deadband", &espp::RangeMapper<int>::get_range_deadband,
           "*\n   * @brief Return the configured deadband around the min/max of the input\n   *    "
           "    distribution\n   * @return Deadband around the min/max of the input distribution "
           "for this\n   *         range mapper.\n")
      .def("get_output_center", &espp::RangeMapper<int>::get_output_center,
           "*\n   * @brief Return the configured center of the output distribution\n   * @return "
           "Center of the output distribution for this range mapper.\n")
      .def("get_output_range", &espp::RangeMapper<int>::get_output_range,
           "*\n   * @brief Return the configured range of the output distribution\n   * @note "
           "Always positive.\n   * @return Range of the output distribution for this range "
           "mapper.\n")
      .def("get_output_min", &espp::RangeMapper<int>::get_output_min,
           "*\n   * @brief Return the configured minimum of the output distribution\n   * @return "
           "Minimum of the output distribution for this range mapper.\n")
      .def("get_output_max", &espp::RangeMapper<int>::get_output_max,
           "*\n   * @brief Return the configured maximum of the output distribution\n   * @return "
           "Maximum of the output distribution for this range mapper.\n")
      .def("set_center_deadband", &espp::RangeMapper<int>::set_center_deadband, py::arg("deadband"),
           "*\n   * @brief Set the deadband around the center of the input distribution.\n   * "
           "@param deadband The deadband to use around the center of the input\n   *        "
           "distribution.\n   * @note The deadband must be non-negative.\n   * @note The deadband "
           "is applied around the center value of the input\n   *       distribution.\n")
      .def("set_range_deadband", &espp::RangeMapper<int>::set_range_deadband, py::arg("deadband"),
           "*\n   * @brief Set the deadband around the min/max of the input distribution.\n   * "
           "@param deadband The deadband to use around the min/max of the input\n   *        "
           "distribution.\n   * @note The deadband must be non-negative.\n   * @note The deadband "
           "is applied around the min/max values of the input\n   *       distribution.\n")
      .def("map", &espp::RangeMapper<int>::map, py::arg("v"),
           "*\n   * @brief Map a value \\p v from the input distribution into the configured\n   * "
           "       output range (centered, default [-1,1]).\n   * @param v Value from the "
           "(possibly uncentered and possibly inverted -\n   *        defined by the previously "
           "configured Config) input distribution\n   * @return Value within the centered output "
           "distribution.\n")
      .def("unmap", &espp::RangeMapper<int>::unmap, py::arg("v"),
           "*\n   * @brief Unmap a value \\p v from the configured output range (centered,\n   *   "
           "     default [-1,1]) back into the input distribution.\n   * @param T&v Value from the "
           "centered output distribution.\n   * @return Value within the input distribution.\n");
  auto pyClassRangeMapper_float = py::class_<espp::RangeMapper<float>>(
      m, "RangeMapper_float", py::dynamic_attr(),
      "*\n * @brief Template class for converting a value from an uncentered [minimum,\n *        "
      "maximum] range into a centered output range (default [-1,1]). If\n *        provided a "
      "non-zero deadband, it will convert all values within\n *        [center-deadband, "
      "center+deadband] to be the configured\n *        output_center (default 0).\n *\n *        "
      "The RangeMapper can be optionally configured to invert the input,\n *        so that it "
      "will compute the input w.r.t. the configured min/max of\n *        the input range when "
      "mapping to the output range - this will mean\n *        that a values within the ranges "
      "[minimum, minimum+deadband] and\n *        [maximum-deadband, maximum] will all map to the "
      "output_center and\n *        the input center will map to both output_max and output_min\n "
      "*        depending on the sign of the input.\n *\n * @note When inverting the input range, "
      "you are introducing a discontinuity\n *       between the input distribution and the output "
      "distribution at the\n *       input center. Noise around the input's center value will "
      "create\n *       oscillations in the output which will jump between output maximum\n *      "
      " and output minimum. Therefore it is advised to use \\p invert_input\n *       sparignly, "
      "and to set the values robustly.\n *\n *        The RangeMapper can be optionally configured "
      "to invert the output,\n *        so that after converting from the input range to the "
      "output range,\n *        it will flip the sign on the output.\n *\n * \\section "
      "range_mapper_ex1 Example\n * \\snippet math_example.cpp range_mapper example\n");

  { // inner classes & enums of RangeMapper_float
    auto pyClassRangeMapper_ClassConfig =
        py::class_<espp::RangeMapper<float>::Config>(
            pyClassRangeMapper_float, "Config", py::dynamic_attr(),
            "*\n   *  @brief Configuration for the input uncentered range with optional\n   *  "
            "values for the centered output range, default values of 0 output center\n   *  and 1 "
            "output range provide a default output range between [-1, 1].\n")
            .def(py::init<>([](float center = float(), float center_deadband = 0,
                               float minimum = float(), float maximum = float(),
                               float range_deadband = 0, float output_center = 0,
                               float output_range = 1, bool invert_output = false) {
                   auto r = std::make_unique<espp::RangeMapper<float>::Config>();
                   r->center = center;
                   r->center_deadband = center_deadband;
                   r->minimum = minimum;
                   r->maximum = maximum;
                   r->range_deadband = range_deadband;
                   r->output_center = output_center;
                   r->output_range = output_range;
                   r->invert_output = invert_output;
                   return r;
                 }),
                 py::arg("center") = float(), py::arg("center_deadband") = 0,
                 py::arg("minimum") = float(), py::arg("maximum") = float(),
                 py::arg("range_deadband") = 0, py::arg("output_center") = 0,
                 py::arg("output_range") = 1, py::arg("invert_output") = false)
            .def_readwrite("center", &espp::RangeMapper<float>::Config::center,
                           "*< Center value for the input range.")
            .def_readwrite("center_deadband", &espp::RangeMapper<float>::Config::center_deadband,
                           "*< Deadband amount around (+-) the center for which output will be 0.")
            .def_readwrite("minimum", &espp::RangeMapper<float>::Config::minimum,
                           "*< Minimum value for the input range.")
            .def_readwrite("maximum", &espp::RangeMapper<float>::Config::maximum,
                           "*< Maximum value for the input range.")
            .def_readwrite("range_deadband", &espp::RangeMapper<float>::Config::range_deadband,
                           "*< Deadband amount around the minimum and maximum for which output "
                           "will\n                             be min/max output.")
            .def_readwrite("output_center", &espp::RangeMapper<float>::Config::output_center,
                           "*< The center for the output. Default 0.")
            .def_readwrite(
                "output_range", &espp::RangeMapper<float>::Config::output_range,
                "*< The range (+/-) from the center for the output. Default 1. @note Will\n        "
                "                     be passed through std::abs() to ensure it is positive.")
            .def_readwrite("invert_output", &espp::RangeMapper<float>::Config::invert_output,
                           "*< Whether to invert the output (default False). @note If True will "
                           "flip the sign\n                  of the output after converting from "
                           "the input distribution.");
  } // end of inner classes & enums of RangeMapper_float

  pyClassRangeMapper_float.def(py::init<espp::RangeMapper<float>::Config>())
      .def("get_center_deadband", &espp::RangeMapper<float>::get_center_deadband,
           "*\n   * @brief Return the configured deadband around the center of the input\n   *     "
           "   distribution\n   * @return Deadband around the center of the input distribution for "
           "this\n   *         range mapper.\n")
      .def("get_minimum", &espp::RangeMapper<float>::get_minimum,
           "*\n   * @brief Return the configured minimum of the input distribution\n   * @return "
           "Minimum of the input distribution for this range mapper.\n")
      .def("get_maximum", &espp::RangeMapper<float>::get_maximum,
           "*\n   * @brief Return the configured maximum of the input distribution\n   * @return "
           "Maximum of the input distribution for this range mapper.\n")
      .def(
          "get_range", &espp::RangeMapper<float>::get_range,
          "*\n   * @brief Return the configured range of the input distribution\n   * @note Always "
          "positive.\n   * @return Range of the input distribution for this range mapper.\n")
      .def("get_range_deadband", &espp::RangeMapper<float>::get_range_deadband,
           "*\n   * @brief Return the configured deadband around the min/max of the input\n   *    "
           "    distribution\n   * @return Deadband around the min/max of the input distribution "
           "for this\n   *         range mapper.\n")
      .def("get_output_center", &espp::RangeMapper<float>::get_output_center,
           "*\n   * @brief Return the configured center of the output distribution\n   * @return "
           "Center of the output distribution for this range mapper.\n")
      .def("get_output_range", &espp::RangeMapper<float>::get_output_range,
           "*\n   * @brief Return the configured range of the output distribution\n   * @note "
           "Always positive.\n   * @return Range of the output distribution for this range "
           "mapper.\n")
      .def("get_output_min", &espp::RangeMapper<float>::get_output_min,
           "*\n   * @brief Return the configured minimum of the output distribution\n   * @return "
           "Minimum of the output distribution for this range mapper.\n")
      .def("get_output_max", &espp::RangeMapper<float>::get_output_max,
           "*\n   * @brief Return the configured maximum of the output distribution\n   * @return "
           "Maximum of the output distribution for this range mapper.\n")
      .def("set_center_deadband", &espp::RangeMapper<float>::set_center_deadband,
           py::arg("deadband"),
           "*\n   * @brief Set the deadband around the center of the input distribution.\n   * "
           "@param deadband The deadband to use around the center of the input\n   *        "
           "distribution.\n   * @note The deadband must be non-negative.\n   * @note The deadband "
           "is applied around the center value of the input\n   *       distribution.\n")
      .def("set_range_deadband", &espp::RangeMapper<float>::set_range_deadband, py::arg("deadband"),
           "*\n   * @brief Set the deadband around the min/max of the input distribution.\n   * "
           "@param deadband The deadband to use around the min/max of the input\n   *        "
           "distribution.\n   * @note The deadband must be non-negative.\n   * @note The deadband "
           "is applied around the min/max values of the input\n   *       distribution.\n")
      .def("map", &espp::RangeMapper<float>::map, py::arg("v"),
           "*\n   * @brief Map a value \\p v from the input distribution into the configured\n   * "
           "       output range (centered, default [-1,1]).\n   * @param v Value from the "
           "(possibly uncentered and possibly inverted -\n   *        defined by the previously "
           "configured Config) input distribution\n   * @return Value within the centered output "
           "distribution.\n")
      .def("unmap", &espp::RangeMapper<float>::unmap, py::arg("v"),
           "*\n   * @brief Unmap a value \\p v from the configured output range (centered,\n   *   "
           "     default [-1,1]) back into the input distribution.\n   * @param T&v Value from the "
           "centered output distribution.\n   * @return Value within the input distribution.\n");
  ////////////////////    </generated_from:range_mapper.hpp>    ////////////////////

  ////////////////////    <generated_from:vector2d.hpp>    ////////////////////
  auto pyClassVector2d_int =
      py::class_<espp::Vector2d<int>>(
          m, "Vector2d_int", py::dynamic_attr(),
          "*\n * @brief Container representing a 2 dimensional vector.\n *\n * Provides "
          "getters/setters, index operator, and vector / scalar math\n * utilities.\n *\n * "
          "\\section vector_ex1 Example\n * \\snippet math_example.cpp vector2 example\n")
          .def(py::init<int, int>(), py::arg("x") = 0, py::arg("y") = 0,
               "*\n   * @brief Constructor for the vector, defaults to 0,0.\n   * @param x The "
               "starting X value.\n   * @param y The starting Y value.\n")
          .def(py::init<const espp::Vector2d<int> &>(), py::arg("other"),
               "*\n   * @brief Vector copy constructor.\n   * @param other Vector to copy.\n")
          .def("magnitude", &espp::Vector2d<int>::magnitude,
               "*\n   * @brief Returns vector magnitude: ||v||.\n   * @return The magnitude.\n")
          .def("magnitude_squared", &espp::Vector2d<int>::magnitude_squared,
               "*\n   * @brief Returns vector magnitude squared: ||v||^2.\n   * @return The "
               "magnitude squared.\n")
          .def(
              "x", [](espp::Vector2d<int> &self) { return self.x(); },
              "*\n   * @brief Getter for the x value.\n   * @return The current x value.\n")
          .def("x", py::overload_cast<int>(&espp::Vector2d<int>::x), py::arg("v"),
               "*\n   * @brief Setter for the x value.\n   * @param v New value for \\c x.\n")
          .def(
              "y", [](espp::Vector2d<int> &self) { return self.y(); },
              "*\n   * @brief Getter for the y value.\n   * @return The current y value.\n")
          .def("y", py::overload_cast<int>(&espp::Vector2d<int>::y), py::arg("v"),
               "*\n   * @brief Setter for the y value.\n   * @param v New value for \\c y.\n")
          .def(
              "__lt__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) < 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__le__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) <= 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__eq__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) == 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__ge__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) >= 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__gt__",
              [](const espp::Vector2d<int> &self, const espp::Vector2d<int> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) > 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def("__eq__", &espp::Vector2d<int>::operator==, py::arg("other"),
               "*\n   * @brief Equality operator for comparing two vectors.\n   * @param other The "
               "vector to compare against.\n   * @return True if the vectors are equal, False "
               "otherwise.\n")
          .def("__getitem__", &espp::Vector2d<int>::operator[], py::arg("index"),
               "*\n   * @brief Index operator for vector elements.\n   * @note Returns a mutable "
               "reference to the element.\n   * @param index The index to return.\n   * @return "
               "Mutable reference to the element at \\p index.\n")
          .def(
              "__neg__", [](espp::Vector2d<int> &self) { return self.operator-(); },
              "*\n   * @brief Negate the vector.\n   * @return The new vector which is the "
              "negative.\n")
          .def("__sub__",
               py::overload_cast<const espp::Vector2d<int> &>(&espp::Vector2d<int>::operator-,
                                                              py::const_),
               py::arg("rhs"),
               "*\n   * @brief Return a new vector which is the provided vector subtracted from\n  "
               " *        this vector.\n   * @param rhs The vector to subtract from this vector.\n "
               "  * @return Resultant vector subtraction.\n")
          .def("__isub__", &espp::Vector2d<int>::operator-=, py::arg("rhs"),
               "*\n   * @brief Return the provided vector subtracted from this vector.\n   * "
               "@param rhs The vector to subtract from this vector.\n   * @return Resultant vector "
               "subtraction.\n")
          .def("__add__", &espp::Vector2d<int>::operator+, py::arg("rhs"),
               "*\n   * @brief Return a new vector, which is the addition of this vector and the\n "
               "  *        provided vector.\n   * @param rhs The vector to add to this vector.\n   "
               "* @return Resultant vector addition.\n")
          .def("__iadd__", &espp::Vector2d<int>::operator+=, py::arg("rhs"),
               "*\n   * @brief Return the vector added with the provided vector.\n   * @param rhs "
               "The vector to add to this vector.\n   * @return Resultant vector addition.\n")
          .def("__mul__", &espp::Vector2d<int>::operator*, py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, multiplied by the provided\n "
               "  *        value.\n   * @param v Value the vector should be multiplied by.\n   * "
               "@return Resultant scaled vector.\n")
          .def("__imul__", &espp::Vector2d<int>::operator*=, py::arg("v"),
               "*\n   * @brief Return the vector multiplied by the provided value.\n   * @param v "
               "Value the vector should be scaled by.\n   * @return Resultant scaled vector.\n")
          .def("__truediv__",
               py::overload_cast<const int &>(&espp::Vector2d<int>::operator/, py::const_),
               py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, divided by the provided\n   "
               "*        value.\n   * @param v Value the vector should be divided by.\n   * "
               "@return Resultant scaled vector.\n")
          .def("__itruediv__", py::overload_cast<const int &>(&espp::Vector2d<int>::operator/=),
               py::arg("v"),
               "*\n   * @brief Return the vector divided by the provided value.\n   * @param v "
               "Value the vector should be divided by.\n   * @return Resultant scaled vector.\n")
          .def("__truediv__",
               py::overload_cast<const espp::Vector2d<int> &>(&espp::Vector2d<int>::operator/,
                                                              py::const_),
               py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, divided by the provided\n   "
               "*        vector value. Scales x and y independently.\n   * @param v Vector values "
               "the vector should be divided by.\n   * @return Resultant scaled vector.\n")
          .def("__itruediv__",
               py::overload_cast<const espp::Vector2d<int> &>(&espp::Vector2d<int>::operator/=),
               py::arg("v"),
               "*\n   * @brief Return the vector divided by the provided vector values.\n   * "
               "@param v Vector of values the vector should be divided by.\n   * @return Resultant "
               "scaled vector.\n")
          .def("dot", &espp::Vector2d<int>::dot, py::arg("other"),
               "*\n   * @brief Dot product of this vector with another vector.\n   * @param other "
               "The second vector\n   * @return The dot product (x1*x2 + y1*y2)\n")
          .def("normalized", &espp::Vector2d<int>::normalized,
               "*\n   * @brief Return normalized (unit length) version of the vector.\n   * "
               "@return The normalized vector.\n");
  auto pyClassVector2d_float =
      py::class_<espp::Vector2d<float>>(
          m, "Vector2d_float", py::dynamic_attr(),
          "*\n * @brief Container representing a 2 dimensional vector.\n *\n * Provides "
          "getters/setters, index operator, and vector / scalar math\n * utilities.\n *\n * "
          "\\section vector_ex1 Example\n * \\snippet math_example.cpp vector2 example\n")
          .def(py::init<float, float>(), py::arg("x") = 0, py::arg("y") = 0,
               "*\n   * @brief Constructor for the vector, defaults to 0,0.\n   * @param x The "
               "starting X value.\n   * @param y The starting Y value.\n")
          .def(py::init<const espp::Vector2d<float> &>(), py::arg("other"),
               "*\n   * @brief Vector copy constructor.\n   * @param other Vector to copy.\n")
          .def("magnitude", &espp::Vector2d<float>::magnitude,
               "*\n   * @brief Returns vector magnitude: ||v||.\n   * @return The magnitude.\n")
          .def("magnitude_squared", &espp::Vector2d<float>::magnitude_squared,
               "*\n   * @brief Returns vector magnitude squared: ||v||^2.\n   * @return The "
               "magnitude squared.\n")
          .def(
              "x", [](espp::Vector2d<float> &self) { return self.x(); },
              "*\n   * @brief Getter for the x value.\n   * @return The current x value.\n")
          .def("x", py::overload_cast<float>(&espp::Vector2d<float>::x), py::arg("v"),
               "*\n   * @brief Setter for the x value.\n   * @param v New value for \\c x.\n")
          .def(
              "y", [](espp::Vector2d<float> &self) { return self.y(); },
              "*\n   * @brief Getter for the y value.\n   * @return The current y value.\n")
          .def("y", py::overload_cast<float>(&espp::Vector2d<float>::y), py::arg("v"),
               "*\n   * @brief Setter for the y value.\n   * @param v New value for \\c y.\n")
          .def(
              "__lt__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) < 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__le__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) <= 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__eq__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) == 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__ge__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) >= 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def(
              "__gt__",
              [](const espp::Vector2d<float> &self, const espp::Vector2d<float> &other) -> bool {
                auto cmp = [&self](auto &&other) -> bool { return self.operator<=>(other) > 0; };

                return cmp(other);
              },
              py::arg("other"),
              "*\n   * @brief Spaceship operator for comparing two vectors.\n   * @param other The "
              "vector to compare against.\n   * @return -1 if this vector is less than \\p other, "
              "0 if they are equal, 1 if\n   *         this vector is greater than \\p other.\n")
          .def("__eq__", &espp::Vector2d<float>::operator==, py::arg("other"),
               "*\n   * @brief Equality operator for comparing two vectors.\n   * @param other The "
               "vector to compare against.\n   * @return True if the vectors are equal, False "
               "otherwise.\n")
          .def("__getitem__", &espp::Vector2d<float>::operator[], py::arg("index"),
               "*\n   * @brief Index operator for vector elements.\n   * @note Returns a mutable "
               "reference to the element.\n   * @param index The index to return.\n   * @return "
               "Mutable reference to the element at \\p index.\n")
          .def(
              "__neg__", [](espp::Vector2d<float> &self) { return self.operator-(); },
              "*\n   * @brief Negate the vector.\n   * @return The new vector which is the "
              "negative.\n")
          .def("__sub__",
               py::overload_cast<const espp::Vector2d<float> &>(&espp::Vector2d<float>::operator-,
                                                                py::const_),
               py::arg("rhs"),
               "*\n   * @brief Return a new vector which is the provided vector subtracted from\n  "
               " *        this vector.\n   * @param rhs The vector to subtract from this vector.\n "
               "  * @return Resultant vector subtraction.\n")
          .def("__isub__", &espp::Vector2d<float>::operator-=, py::arg("rhs"),
               "*\n   * @brief Return the provided vector subtracted from this vector.\n   * "
               "@param rhs The vector to subtract from this vector.\n   * @return Resultant vector "
               "subtraction.\n")
          .def("__add__", &espp::Vector2d<float>::operator+, py::arg("rhs"),
               "*\n   * @brief Return a new vector, which is the addition of this vector and the\n "
               "  *        provided vector.\n   * @param rhs The vector to add to this vector.\n   "
               "* @return Resultant vector addition.\n")
          .def("__iadd__", &espp::Vector2d<float>::operator+=, py::arg("rhs"),
               "*\n   * @brief Return the vector added with the provided vector.\n   * @param rhs "
               "The vector to add to this vector.\n   * @return Resultant vector addition.\n")
          .def("__mul__", &espp::Vector2d<float>::operator*, py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, multiplied by the provided\n "
               "  *        value.\n   * @param v Value the vector should be multiplied by.\n   * "
               "@return Resultant scaled vector.\n")
          .def("__imul__", &espp::Vector2d<float>::operator*=, py::arg("v"),
               "*\n   * @brief Return the vector multiplied by the provided value.\n   * @param v "
               "Value the vector should be scaled by.\n   * @return Resultant scaled vector.\n")
          .def("__truediv__",
               py::overload_cast<const float &>(&espp::Vector2d<float>::operator/, py::const_),
               py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, divided by the provided\n   "
               "*        value.\n   * @param v Value the vector should be divided by.\n   * "
               "@return Resultant scaled vector.\n")
          .def("__itruediv__", py::overload_cast<const float &>(&espp::Vector2d<float>::operator/=),
               py::arg("v"),
               "*\n   * @brief Return the vector divided by the provided value.\n   * @param v "
               "Value the vector should be divided by.\n   * @return Resultant scaled vector.\n")
          .def("__truediv__",
               py::overload_cast<const espp::Vector2d<float> &>(&espp::Vector2d<float>::operator/,
                                                                py::const_),
               py::arg("v"),
               "*\n   * @brief Return a scaled version of the vector, divided by the provided\n   "
               "*        vector value. Scales x and y independently.\n   * @param v Vector values "
               "the vector should be divided by.\n   * @return Resultant scaled vector.\n")
          .def("__itruediv__",
               py::overload_cast<const espp::Vector2d<float> &>(&espp::Vector2d<float>::operator/=),
               py::arg("v"),
               "*\n   * @brief Return the vector divided by the provided vector values.\n   * "
               "@param v Vector of values the vector should be divided by.\n   * @return Resultant "
               "scaled vector.\n")
          .def("dot", &espp::Vector2d<float>::dot, py::arg("other"),
               "*\n   * @brief Dot product of this vector with another vector.\n   * @param other "
               "The second vector\n   * @return The dot product (x1*x2 + y1*y2)\n")
          .def("normalized", &espp::Vector2d<float>::normalized,
               "*\n   * @brief Return normalized (unit length) version of the vector.\n   * "
               "@return The normalized vector.\n");
  ////////////////////    </generated_from:vector2d.hpp>    ////////////////////

  ////////////////////    <generated_from:socket.hpp>    ////////////////////
  auto pyClassSocket =
      py::class_<espp::Socket>(m, "Socket", py::dynamic_attr(),
                               "*\n *   @brief Class for a generic socket with some helper "
                               "functions for\n *          configuring the socket.\n");

  { // inner classes & enums of Socket
    py::enum_<espp::Socket::Type>(pyClassSocket, "Type", py::arithmetic(), "")
        .value("raw", espp::Socket::Type::RAW, "*< Only IP headers, no TCP or UDP headers as well.")
        .value("dgram", espp::Socket::Type::DGRAM, "*< UDP/IP socket - datagram.")
        .value("stream", espp::Socket::Type::STREAM, "*< TCP/IP socket - stream.");
    auto pyClassSocket_ClassInfo =
        py::class_<espp::Socket::Info>(
            pyClassSocket, "Info", py::dynamic_attr(),
            "*\n   *  @brief Storage for socket information (address, port) with convenience\n   * "
            "        functions to convert to/from POSIX structures.\n")
            .def(py::init<>([](std::string address = std::string(), size_t port = size_t()) {
                   auto r = std::make_unique<espp::Socket::Info>();
                   r->address = address;
                   r->port = port;
                   return r;
                 }),
                 py::arg("address") = std::string(), py::arg("port") = size_t())
            .def_readwrite("address", &espp::Socket::Info::address,
                           "*< IP address of the endpoint as a string.")
            .def_readwrite("port", &espp::Socket::Info::port,
                           "*< Port of the endpoint as an integer.")
            .def("init_ipv4", &espp::Socket::Info::init_ipv4, py::arg("addr"), py::arg("prt"),
                 "*\n     * @brief Initialize the struct as an ipv4 address/port combo.\n     * "
                 "@param addr IPv4 address string\n     * @param prt port number\n")
            .def("ipv4_ptr", &espp::Socket::Info::ipv4_ptr,
                 "*\n     * @brief Gives access to IPv4 sockaddr structure (sockaddr_in) for use\n "
                 "    *        with low level socket calls like sendto / recvfrom.\n     * @return "
                 "*sockaddr_in pointer to ipv4 data structure\n")
            .def("ipv6_ptr", &espp::Socket::Info::ipv6_ptr,
                 "*\n     * @brief Gives access to IPv6 sockaddr structure (sockaddr_in6) for "
                 "use\n     *        with low level socket calls like sendto / recvfrom.\n     * "
                 "@return *sockaddr_in6 pointer to ipv6 data structure\n")
            .def("update", &espp::Socket::Info::update,
                 "*\n     * @brief Will update address and port based on the curent data in raw.\n")
            .def("from_sockaddr",
                 py::overload_cast<const struct sockaddr_storage &>(
                     &espp::Socket::Info::from_sockaddr),
                 py::arg("source_address"),
                 "*\n     * @brief Fill this Info from the provided sockaddr struct.\n     * "
                 "@param &source_address sockaddr info filled out by recvfrom.\n")
            .def("from_sockaddr",
                 py::overload_cast<const struct sockaddr_in &>(&espp::Socket::Info::from_sockaddr),
                 py::arg("source_address"),
                 "*\n     * @brief Fill this Info from the provided sockaddr struct.\n     * "
                 "@param &source_address sockaddr info filled out by recvfrom.\n")
            .def("from_sockaddr",
                 py::overload_cast<const struct sockaddr_in6 &>(&espp::Socket::Info::from_sockaddr),
                 py::arg("source_address"),
                 "*\n     * @brief Fill this Info from the provided sockaddr struct.\n     * "
                 "@param &source_address sockaddr info filled out by recvfrom.\n");
  } // end of inner classes & enums of Socket

  pyClassSocket
      .def(
          "is_valid", [](espp::Socket &self) { return self.is_valid(); },
          "*\n   * @brief Is the socket valid.\n   * @return True if the socket file descriptor is "
          ">= 0.\n")
      .def_static("is_valid_fd", py::overload_cast<sock_type_t>(&espp::Socket::is_valid_fd),
                  py::arg("socket_fd"),
                  "*\n   * @brief Is the socket valid.\n   * @param socket_fd Socket file "
                  "descriptor.\n   * @return True if the socket file descriptor is >= 0.\n")
      .def("get_ipv4_info", &espp::Socket::get_ipv4_info,
           "*\n   * @brief Get the Socket::Info for the socket.\n   * @details This will call "
           "getsockname() on the socket to get the\n   *          sockaddr_storage structure, and "
           "then fill out the Socket::Info\n   *          structure.\n   * @return Socket::Info "
           "for the socket.\n")
      .def("set_receive_timeout", &espp::Socket::set_receive_timeout, py::arg("timeout"),
           "*\n   * @brief Set the receive timeout on the provided socket.\n   * @param timeout "
           "requested timeout, must be > 0.\n   * @return True if SO_RECVTIMEO was successfully "
           "set.\n")
      .def("enable_reuse", &espp::Socket::enable_reuse,
           "*\n   * @brief Allow others to use this address/port combination after we're done\n   "
           "*        with it.\n   * @return True if SO_REUSEADDR and SO_REUSEPORT were "
           "successfully set.\n")
      .def("make_multicast", &espp::Socket::make_multicast, py::arg("time_to_live") = 1,
           py::arg("loopback_enabled") = true,
           "*\n   * @brief Configure the socket to be multicast (if time_to_live > 0).\n   *       "
           " Sets the IP_MULTICAST_TTL (number of multicast hops allowed) and\n   *        "
           "optionally configures whether this node should receive its own\n   *        multicast "
           "packets (IP_MULTICAST_LOOP).\n   * @param time_to_live number of multicast hops "
           "allowed (TTL).\n   * @param loopback_enabled Whether to receive our own multicast "
           "packets.\n   * @return True if IP_MULTICAST_TTL and IP_MULTICAST_LOOP were set.\n")
      .def("add_multicast_group", &espp::Socket::add_multicast_group, py::arg("multicast_group"),
           "*\n   * @brief If this is a server socket, add it to the provided the multicast\n   *  "
           "      group.\n   *\n   *         @note Multicast groups must be Class D addresses "
           "(224.0.0.0 to\n   *                239.255.255.255)\n   *\n   *        See "
           "https://en.wikipedia.org/wiki/Multicast_address for more\n   *        information.\n   "
           "* @param multicast_group multicast group to join.\n   * @return True if "
           "IP_ADD_MEMBERSHIP was successfully set.\n")
      .def("select", &espp::Socket::select, py::arg("timeout"),
           "*\n   * @brief Select on the socket for read events.\n   * @param timeout how long to "
           "wait for an event.\n   * @return number of events that occurred.\n");
  ////////////////////    </generated_from:socket.hpp>    ////////////////////

  ////////////////////    <generated_from:tcp_socket.hpp>    ////////////////////
  auto pyClassTcpSocket = py::class_<espp::TcpSocket>(
      m, "TcpSocket", py::dynamic_attr(),
      "*\n *   @brief Class for managing sending and receiving data using TCP/IP. Can be\n *       "
      "   used to create client or server sockets.\n *\n * \\section tcp_ex1 TCP Client Example\n "
      "* \\snippet socket_example.cpp TCP Client example\n * \\section tcp_ex2 TCP Server "
      "Example\n * \\snippet socket_example.cpp TCP Server example\n *\n * \\section tcp_ex3 TCP "
      "Client Response Example\n * \\snippet socket_example.cpp TCP Client Response example\n * "
      "\\section tcp_ex4 TCP Server Response Example\n * \\snippet socket_example.cpp TCP Server "
      "Response example\n *\n");

  { // inner classes & enums of TcpSocket
    auto pyClassTcpSocket_ClassConfig =
        py::class_<espp::TcpSocket::Config>(pyClassTcpSocket, "Config", py::dynamic_attr(),
                                            "*\n   * @brief Config struct for the TCP socket.\n")
            .def(
                py::init<>([](espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                  auto r = std::make_unique<espp::TcpSocket::Config>();
                  r->log_level = log_level;
                  return r;
                }),
                py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("log_level", &espp::TcpSocket::Config::log_level,
                           "*< Verbosity level for the TCP socket logger.");
    auto pyClassTcpSocket_ClassConnectConfig =
        py::class_<espp::TcpSocket::ConnectConfig>(
            pyClassTcpSocket, "ConnectConfig", py::dynamic_attr(),
            "*\n   * @brief Config struct for connecting to a remote TCP server.\n")
            .def(py::init<>([](std::string ip_address = std::string(), size_t port = size_t()) {
                   auto r = std::make_unique<espp::TcpSocket::ConnectConfig>();
                   r->ip_address = ip_address;
                   r->port = port;
                   return r;
                 }),
                 py::arg("ip_address") = std::string(), py::arg("port") = size_t())
            .def_readwrite("ip_address", &espp::TcpSocket::ConnectConfig::ip_address,
                           "*< Address to send data to.")
            .def_readwrite("port", &espp::TcpSocket::ConnectConfig::port,
                           "*< Port number to send data to.");
    auto pyClassTcpSocket_ClassTransmitConfig =
        py::class_<espp::TcpSocket::TransmitConfig>(
            pyClassTcpSocket, "TransmitConfig", py::dynamic_attr(),
            "*\n   * @brief Config struct for sending data to a remote TCP socket.\n   * @note "
            "This is only used when waiting for a response from the remote.\n")
            .def(py::init<>([](bool wait_for_response = false, size_t response_size = 0,
                               espp::Socket::response_callback_fn on_response_callback = nullptr,
                               std::chrono::duration<float> response_timeout =
                                   std::chrono::duration<float>(0.5f)) {
                   auto r = std::make_unique<espp::TcpSocket::TransmitConfig>();
                   r->wait_for_response = wait_for_response;
                   r->response_size = response_size;
                   r->on_response_callback = on_response_callback;
                   r->response_timeout = response_timeout;
                   return r;
                 }),
                 py::arg("wait_for_response") = false, py::arg("response_size") = 0,
                 py::arg("on_response_callback") = py::none(),
                 py::arg("response_timeout") = std::chrono::duration<float>(0.5f))
            .def_readwrite("wait_for_response", &espp::TcpSocket::TransmitConfig::wait_for_response,
                           "*< Whether to wait for a response from the remote or not.")
            .def_readwrite(
                "response_size", &espp::TcpSocket::TransmitConfig::response_size,
                "*< If waiting for a response, this is the maximum size response we will receive.")
            .def_readwrite("on_response_callback",
                           &espp::TcpSocket::TransmitConfig::on_response_callback,
                           "*< If waiting for a\n                   response, this is an optional "
                           "handler which is provided the response data.")
            .def_readwrite("response_timeout", &espp::TcpSocket::TransmitConfig::response_timeout,
                           "*< If waiting for a response, this is the maximum timeout to wait.")
            .def_static("default", &espp::TcpSocket::TransmitConfig::Default);
  } // end of inner classes & enums of TcpSocket

  pyClassTcpSocket.def(py::init<espp::TcpSocket::Config>())
      .def("reinit", &espp::TcpSocket::reinit,
           "*\n   * @brief Reinitialize the socket, cleaning it up if first it is already\n   *    "
           "    initalized.\n")
      .def("close", &espp::TcpSocket::close, "*\n   * @brief Close the socket.\n")
      .def("is_connected", &espp::TcpSocket::is_connected,
           "*\n   * @brief Check if the socket is connected to a remote endpoint.\n   * @return "
           "True if the socket is connected to a remote endpoint.\n")
      .def("connect", &espp::TcpSocket::connect, py::arg("connect_config"),
           "*\n   * @brief Open a connection to the remote TCP server.\n   * @param connect_config "
           "ConnectConfig struct describing the server endpoint.\n   * @return True if the client "
           "successfully connected to the server.\n")
      .def("get_remote_info", &espp::TcpSocket::get_remote_info,
           "*\n   * @brief Get the remote endpoint info.\n   * @return The remote endpoint info.\n")
      .def("transmit",
           py::overload_cast<const std::vector<uint8_t> &, const espp::TcpSocket::TransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::TcpSocket::TransmitConfig::Default(),
           "*\n   * @brief Send data to the endpoint already connected to by TcpSocket::connect.\n "
           "  *        Can be configured to block waiting for a response from the remote.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data vector of bytes to send to the remote endpoint.\n   * @param "
           "transmit_config TransmitConfig struct indicating whether to wait for a\n   *        "
           "response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("transmit",
           py::overload_cast<const std::vector<char> &, const espp::TcpSocket::TransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::TcpSocket::TransmitConfig::Default(),
           "*\n   * @brief Send data to the endpoint already connected to by TcpSocket::connect.\n "
           "  *        Can be configured to block waiting for a response from the remote.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data vector of bytes to send to the remote endpoint.\n   * @param "
           "transmit_config TransmitConfig struct indicating whether to wait for a\n   *        "
           "response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("transmit",
           py::overload_cast<std::string_view, const espp::TcpSocket::TransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::TcpSocket::TransmitConfig::Default(),
           "*\n   * @brief Send data to the endpoint already connected to by TcpSocket::connect.\n "
           "  *        Can be configured to block waiting for a response from the remote.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data string view of bytes to send to the remote endpoint.\n   * @param "
           "transmit_config TransmitConfig struct indicating whether to wait for a\n   *        "
           "response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("receive", py::overload_cast<std::vector<uint8_t> &, size_t>(&espp::TcpSocket::receive),
           py::arg("data"), py::arg("max_num_bytes"),
           "*\n   * @brief Call read on the socket, assuming it has already been configured\n   *  "
           "      appropriately.\n   *\n   * @param data Vector of bytes of received data.\n   * "
           "@param max_num_bytes Maximum number of bytes to receive.\n   * @return True if "
           "successfully received, False otherwise.\n")
      .def("receive", py::overload_cast<uint8_t *, size_t>(&espp::TcpSocket::receive),
           py::arg("data"), py::arg("max_num_bytes"),
           "*\n   * @brief Call read on the socket, assuming it has already been configured\n   *  "
           "      appropriately.\n   * @note This function will block until max_num_bytes are "
           "received or the\n   *       receive timeout is reached.\n   * @note The data pointed "
           "to by data must be at least max_num_bytes in size.\n   * @param data Pointer to buffer "
           "to receive data.\n   * @param max_num_bytes Maximum number of bytes to receive.\n   * "
           "@return Number of bytes received.\n")
      .def("bind", &espp::TcpSocket::bind, py::arg("port"),
           "*\n   * @brief Bind the socket as a server on \\p port.\n   * @param port The port to "
           "which to bind the socket.\n   * @return True if the socket was bound.\n")
      .def("listen", &espp::TcpSocket::listen, py::arg("max_pending_connections"),
           "*\n   * @brief Listen for incoming client connections.\n   * @note Must be called "
           "after bind and before accept.\n   * @see bind\n   * @see accept\n   * @param "
           "max_pending_connections Max number of allowed pending connections.\n   * @return True "
           "if socket was able to start listening.\n")
      .def("accept", &espp::TcpSocket::accept,
           "*\n   * @brief Accept an incoming connection.\n   * @note Blocks until a connection is "
           "accepted.\n   * @note Must be called after listen.\n   * @note This function will "
           "block until a connection is accepted.\n   * @return A unique pointer to a "
           "TcpClientSession if a connection was\n   *         accepted, None otherwise.\n");
  ////////////////////    </generated_from:tcp_socket.hpp>    ////////////////////

  ////////////////////    <generated_from:udp_socket.hpp>    ////////////////////
  auto pyClassUdpSocket = py::class_<espp::UdpSocket>(
      m, "UdpSocket", py::dynamic_attr(),
      "*\n *   @brief Class for managing sending and receiving data using UDP/IP. Can be\n *       "
      "   used to create client or server sockets.\n *\n *   See\n *   "
      "https://github.com/espressif/esp-idf/tree/master/examples/protocols/sockets/udp_multicast\n "
      "*   for more information on udp multicast sockets.\n *\n * \\section udp_ex1 UDP Client "
      "Example\n * \\snippet socket_example.cpp UDP Client example\n * \\section udp_ex2 UDP "
      "Server Example\n * \\snippet socket_example.cpp UDP Server example\n *\n * \\section "
      "udp_ex3 UDP Client Response Example\n * \\snippet socket_example.cpp UDP Client Response "
      "example\n * \\section udp_ex4 UDP Server Response Example\n * \\snippet socket_example.cpp "
      "UDP Server Response example\n *\n * \\section udp_ex5 UDP Multicast Client Example\n * "
      "\\snippet socket_example.cpp UDP Multicast Client example\n * \\section udp_ex6 UDP "
      "Multicast Server Example\n * \\snippet socket_example.cpp UDP Multicast Server example\n "
      "*\n");

  { // inner classes & enums of UdpSocket
    auto pyClassUdpSocket_ClassReceiveConfig =
        py::class_<espp::UdpSocket::ReceiveConfig>(pyClassUdpSocket, "ReceiveConfig",
                                                   py::dynamic_attr(), "")
            .def(py::init<>([](size_t port = size_t(), size_t buffer_size = size_t(),
                               bool is_multicast_endpoint = {false},
                               std::string multicast_group = {""},
                               espp::Socket::receive_callback_fn on_receive_callback = {nullptr}) {
                   auto r = std::make_unique<espp::UdpSocket::ReceiveConfig>();
                   r->port = port;
                   r->buffer_size = buffer_size;
                   r->is_multicast_endpoint = is_multicast_endpoint;
                   r->multicast_group = multicast_group;
                   r->on_receive_callback = on_receive_callback;
                   return r;
                 }),
                 py::arg("port") = size_t(), py::arg("buffer_size") = size_t(),
                 py::arg("is_multicast_endpoint") = bool{false},
                 py::arg("multicast_group") = std::string{""},
                 py::arg("on_receive_callback") = espp::Socket::receive_callback_fn{nullptr})
            .def_readwrite("port", &espp::UdpSocket::ReceiveConfig::port,
                           "*< Port number to bind to / receive from.")
            .def_readwrite("buffer_size", &espp::UdpSocket::ReceiveConfig::buffer_size,
                           "*< Max size of data we can receive at one time.")
            .def_readwrite("is_multicast_endpoint",
                           &espp::UdpSocket::ReceiveConfig::is_multicast_endpoint,
                           "*< Whether this should be a multicast endpoint.")
            .def_readwrite("multicast_group", &espp::UdpSocket::ReceiveConfig::multicast_group,
                           "*< If this is a multicast endpoint, this is the group it belongs to.")
            .def_readwrite("on_receive_callback",
                           &espp::UdpSocket::ReceiveConfig::on_receive_callback,
                           "*< Function containing business logic to handle data received.");
    auto pyClassUdpSocket_ClassSendConfig =
        py::class_<espp::UdpSocket::SendConfig>(pyClassUdpSocket, "SendConfig", py::dynamic_attr(),
                                                "")
            .def(py::init<>([](std::string ip_address = std::string(), size_t port = size_t(),
                               bool is_multicast_endpoint = {false},
                               bool wait_for_response = {false}, size_t response_size = {0},
                               espp::Socket::response_callback_fn on_response_callback = {nullptr},
                               std::chrono::duration<float> response_timeout =
                                   std::chrono::duration<float>(0.5f)) {
                   auto r = std::make_unique<espp::UdpSocket::SendConfig>();
                   r->ip_address = ip_address;
                   r->port = port;
                   r->is_multicast_endpoint = is_multicast_endpoint;
                   r->wait_for_response = wait_for_response;
                   r->response_size = response_size;
                   r->on_response_callback = on_response_callback;
                   r->response_timeout = response_timeout;
                   return r;
                 }),
                 py::arg("ip_address") = std::string(), py::arg("port") = size_t(),
                 py::arg("is_multicast_endpoint") = bool{false},
                 py::arg("wait_for_response") = bool{false}, py::arg("response_size") = size_t{0},
                 py::arg("on_response_callback") = espp::Socket::response_callback_fn{nullptr},
                 py::arg("response_timeout") = std::chrono::duration<float>(0.5f))
            .def_readwrite("ip_address", &espp::UdpSocket::SendConfig::ip_address,
                           "*< Address to send data to.")
            .def_readwrite("port", &espp::UdpSocket::SendConfig::port,
                           "*< Port number to send data to.")
            .def_readwrite("is_multicast_endpoint",
                           &espp::UdpSocket::SendConfig::is_multicast_endpoint,
                           "*< Whether this should be a multicast endpoint.")
            .def_readwrite("wait_for_response", &espp::UdpSocket::SendConfig::wait_for_response,
                           "*< Whether to wait for a response from the remote or not.")
            .def_readwrite(
                "response_size", &espp::UdpSocket::SendConfig::response_size,
                "*< If waiting for a response, this is the maximum size response we will receive.")
            .def_readwrite("on_response_callback",
                           &espp::UdpSocket::SendConfig::on_response_callback,
                           "*< If waiting for a response, this is an optional handler which is "
                           "provided the\n                     response data.")
            .def_readwrite("response_timeout", &espp::UdpSocket::SendConfig::response_timeout,
                           "*< If waiting for a response, this is the maximum timeout to wait.");
    auto pyClassUdpSocket_ClassConfig =
        py::class_<espp::UdpSocket::Config>(pyClassUdpSocket, "Config", py::dynamic_attr(), "")
            .def(
                py::init<>([](espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                  auto r = std::make_unique<espp::UdpSocket::Config>();
                  r->log_level = log_level;
                  return r;
                }),
                py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("log_level", &espp::UdpSocket::Config::log_level,
                           "*< Verbosity level for the UDP socket logger.");
  } // end of inner classes & enums of UdpSocket

  pyClassUdpSocket.def(py::init<espp::UdpSocket::Config>())
      .def("send",
           py::overload_cast<const std::vector<uint8_t> &, const espp::UdpSocket::SendConfig &>(
               &espp::UdpSocket::send),
           py::arg("data"), py::arg("send_config"),
           "*\n   * @brief Send data to the endpoint specified by the send_config.\n   *        "
           "Can be configured to multicast (within send_config) and can be\n   *        configured "
           "to block waiting for a response from the remote.\n   *\n   *        @note in the case "
           "of multicast, it will block only until the first\n   *              response.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data vector of bytes to send to the remote endpoint.\n   * @param send_config "
           "SendConfig struct indicating where to send and whether\n   *        to wait for a "
           "response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("send",
           py::overload_cast<std::string_view, const espp::UdpSocket::SendConfig &>(
               &espp::UdpSocket::send),
           py::arg("data"), py::arg("send_config"),
           "*\n   * @brief Send data to the endpoint specified by the send_config.\n   *        "
           "Can be configured to multicast (within send_config) and can be\n   *        configured "
           "to block waiting for a response from the remote.\n   *\n   *        @note in the case "
           "of multicast, it will block only until the first\n   *              response.\n   *\n  "
           " *        If response is requested, a callback can be provided in\n   *        "
           "send_config which will be provided the response data for\n   *        processing.\n   "
           "* @param data String view of bytes to send to the remote endpoint.\n   * @param "
           "send_config SendConfig struct indicating where to send and whether\n   *        to "
           "wait for a response.\n   * @return True if the data was sent, False otherwise.\n")
      .def("receive", &espp::UdpSocket::receive, py::arg("max_num_bytes"), py::arg("data"),
           py::arg("remote_info"),
           "*\n   * @brief Call recvfrom on the socket, assuming it has already been\n   *        "
           "configured appropriately.\n   *\n   * @param max_num_bytes Maximum number of bytes to "
           "receive.\n   * @param data Vector of bytes of received data.\n   * @param remote_info "
           "Socket::Info containing the sender's information. This\n   *        will be populated "
           "with the information about the sender.\n   * @return True if successfully received, "
           "False otherwise.\n")
      .def("start_receiving", &espp::UdpSocket::start_receiving, py::arg("task_config"),
           py::arg("receive_config"),
           "*\n   * @brief Configure a server socket and start a thread to continuously\n   *      "
           "  receive and handle data coming in on that socket.\n   *\n   * @param task_config "
           "Task::Config struct for configuring the receive task.\n   * @param receive_config "
           "ReceiveConfig struct with socket and callback info.\n   * @return True if the socket "
           "was created and task was started, False otherwise.\n");
  ////////////////////    </generated_from:udp_socket.hpp>    ////////////////////

  ////////////////////    <generated_from:task.hpp>    ////////////////////
  auto pyClassTask = py::class_<espp::Task>(
      m, "Task", py::dynamic_attr(),
      "*\n * @brief Task provides an abstraction over std::thread which optionally\n * includes "
      "memory / priority configuration on ESP systems. It allows users to\n * easily stop the "
      "task, and will automatically stop itself if destroyed.\n *\n * There is also a utility "
      "function which can be used to get the info for the\n * task of the current context, or for "
      "a provided Task object.\n *\n * There is also a helper function to run a lambda on a "
      "specific core, which can\n * be used to run a specific function on a specific core, as you "
      "might want to\n * do when registering an interrupt driver on a specific core.\n *\n * "
      "\\section task_ex1 Basic Task Example\n * \\snippet task_example.cpp Task example\n * "
      "\\section task_ex2 Many Task Example\n * \\snippet task_example.cpp ManyTask example\n * "
      "\\section task_ex3 Long Running Task Example\n * \\snippet task_example.cpp LongRunningTask "
      "example\n * \\section task_ex4 Task Info Example\n * \\snippet task_example.cpp Task Info "
      "example\n * \\section task_ex5 Task Request Stop Example\n * \\snippet task_example.cpp "
      "Task Request Stop example\n *\n * \\section run_on_core_ex1 Run on Core Example\n * "
      "\\snippet task_example.cpp run on core example\n");

  { // inner classes & enums of Task
    auto pyClassTask_ClassBaseConfig =
        py::class_<espp::Task::BaseConfig>(
            pyClassTask, "BaseConfig", py::dynamic_attr(),
            "*\n   * @brief Base configuration struct for the Task.\n   * @note This is designed "
            "to be used as a configuration struct in other classes\n   *       that may have a "
            "Task as a member.\n")
            .def(py::init<>([](std::string name = std::string(), size_t stack_size_bytes = {4096},
                               size_t priority = {0}, int core_id = {-1}) {
                   auto r = std::make_unique<espp::Task::BaseConfig>();
                   r->name = name;
                   r->stack_size_bytes = stack_size_bytes;
                   r->priority = priority;
                   r->core_id = core_id;
                   return r;
                 }),
                 py::arg("name") = std::string(), py::arg("stack_size_bytes") = size_t{4096},
                 py::arg("priority") = size_t{0}, py::arg("core_id") = int{-1})
            .def_readwrite("name", &espp::Task::BaseConfig::name, "*< Name of the task")
            .def_readwrite("stack_size_bytes", &espp::Task::BaseConfig::stack_size_bytes,
                           "*< Stack Size (B) allocated to the task.")
            .def_readwrite("priority", &espp::Task::BaseConfig::priority,
                           "*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.")
            .def_readwrite("core_id", &espp::Task::BaseConfig::core_id,
                           "*< Core ID of the task, -1 means it is not pinned to any core.");
    auto pyClassTask_ClassConfig =
        py::class_<espp::Task::Config>(
            pyClassTask, "Config", py::dynamic_attr(),
            "*\n   * @brief Configuration struct for the Task.\n   * @note This is the recommended "
            "way to configure the Task, and allows you to\n   *       use the condition variable "
            "and mutex from the task to wait_for and\n   *       wait_until.\n   * @note This is "
            "an older configuration struct, and is kept for backwards\n   *       compatibility. "
            "It is recommended to use the AdvancedConfig struct\n   *       instead.\n")
            .def(py::init<>(
                     [](std::string name = std::string(),
                        espp::Task::callback_fn callback = espp::Task::callback_fn(),
                        size_t stack_size_bytes = {4096}, size_t priority = {0}, int core_id = {-1},
                        espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                       auto r = std::make_unique<espp::Task::Config>();
                       r->name = name;
                       r->callback = callback;
                       r->stack_size_bytes = stack_size_bytes;
                       r->priority = priority;
                       r->core_id = core_id;
                       r->log_level = log_level;
                       return r;
                     }),
                 py::arg("name") = std::string(), py::arg("callback") = espp::Task::callback_fn(),
                 py::arg("stack_size_bytes") = size_t{4096}, py::arg("priority") = size_t{0},
                 py::arg("core_id") = int{-1},
                 py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("name", &espp::Task::Config::name, "*< Name of the task")
            .def_readwrite("callback", &espp::Task::Config::callback, "*< Callback function")
            .def_readwrite("stack_size_bytes", &espp::Task::Config::stack_size_bytes,
                           "*< Stack Size (B) allocated to the task.")
            .def_readwrite("priority", &espp::Task::Config::priority,
                           "*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.")
            .def_readwrite("core_id", &espp::Task::Config::core_id,
                           "*< Core ID of the task, -1 means it is not pinned to any core.")
            .def_readwrite("log_level", &espp::Task::Config::log_level,
                           "*< Log verbosity for the task.");
    auto pyClassTask_ClassSimpleConfig =
        py::class_<espp::Task::SimpleConfig>(
            pyClassTask, "SimpleConfig", py::dynamic_attr(),
            "*\n   * @brief Simple configuration struct for the Task.\n   * @note This is useful "
            "for when you don't need to use the condition variable\n   *       or mutex in the "
            "callback.\n")
            .def(py::init<>(
                     [](espp::Task::simple_callback_fn callback = espp::Task::simple_callback_fn(),
                        espp::Task::BaseConfig task_config = espp::Task::BaseConfig(),
                        espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                       auto r = std::make_unique<espp::Task::SimpleConfig>();
                       r->callback = callback;
                       r->task_config = task_config;
                       r->log_level = log_level;
                       return r;
                     }),
                 py::arg("callback") = espp::Task::simple_callback_fn(),
                 py::arg("task_config") = espp::Task::BaseConfig(),
                 py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("callback", &espp::Task::SimpleConfig::callback, "*< Callback function")
            .def_readwrite("task_config", &espp::Task::SimpleConfig::task_config,
                           "*< Base configuration for the task.")
            .def_readwrite("log_level", &espp::Task::SimpleConfig::log_level,
                           "*< Log verbosity for the task.");
    auto pyClassTask_ClassAdvancedConfig =
        py::class_<espp::Task::AdvancedConfig>(
            pyClassTask, "AdvancedConfig", py::dynamic_attr(),
            "*\n   * @brief Advanced configuration struct for the Task.\n   * @note This is the "
            "recommended way to configure the Task, and allows you to\n   *       use the "
            "condition variable and mutex from the task to wait_for and\n   *       wait_until.\n")
            .def(
                py::init<>([](espp::Task::callback_fn callback = espp::Task::callback_fn(),
                              espp::Task::BaseConfig task_config = espp::Task::BaseConfig(),
                              espp::Logger::Verbosity log_level = {espp::Logger::Verbosity::WARN}) {
                  auto r = std::make_unique<espp::Task::AdvancedConfig>();
                  r->callback = callback;
                  r->task_config = task_config;
                  r->log_level = log_level;
                  return r;
                }),
                py::arg("callback") = espp::Task::callback_fn(),
                py::arg("task_config") = espp::Task::BaseConfig(),
                py::arg("log_level") = espp::Logger::Verbosity{espp::Logger::Verbosity::WARN})
            .def_readwrite("callback", &espp::Task::AdvancedConfig::callback,
                           "*< Callback function")
            .def_readwrite("task_config", &espp::Task::AdvancedConfig::task_config,
                           "*< Base configuration for the task.")
            .def_readwrite("log_level", &espp::Task::AdvancedConfig::log_level,
                           "*< Log verbosity for the task.");
  } // end of inner classes & enums of Task

  pyClassTask.def(py::init<const espp::Task::Config &>())
      .def(py::init<const espp::Task::SimpleConfig &>())
      .def(py::init<const espp::Task::AdvancedConfig &>())
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::Config &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config Config struct to initialize the Task with.\n   * @return "
                  "std::unique_ptr<Task> pointer to the newly created task.\n")
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::SimpleConfig &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config SimpleConfig struct to initialize the Task with.\n   * @return "
                  "std::unique_ptr<Task> pointer to the newly created task.\n")
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::AdvancedConfig &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config AdvancedConfig struct to initialize the Task with.\n   * "
                  "@return std::unique_ptr<Task> pointer to the newly created task.\n")
      .def("start", &espp::Task::start,
           "*\n   * @brief Start executing the task.\n   *\n   * @return True if the task started, "
           "False if it was already started.\n")
      .def("stop", &espp::Task::stop,
           "*\n   * @brief Stop the task execution, blocking until it stops.\n   *\n   * @return "
           "True if the task stopped, False if it was not started / already\n   * stopped.\n")
      .def("is_started", &espp::Task::is_started,
           "*\n   * @brief Has the task been started or not?\n   *\n   * @return True if the task "
           "is started / running, False otherwise.\n")
      .def("is_running", &espp::Task::is_running,
           "*\n   * @brief Is the task running?\n   *\n   * @return True if the task is running, "
           "False otherwise.\n");
  ////////////////////    </generated_from:task.hpp>    ////////////////////

  ////////////////////    <generated_from:timer.hpp>    ////////////////////
  auto pyClassTimer = py::class_<espp::Timer>(
      m, "Timer", py::dynamic_attr(),
      "/ @brief A timer that can be used to schedule tasks to run at a later time.\n/ @details A "
      "timer can be used to schedule a task to run at a later time.\n/          The timer will run "
      "in the background and will call the task when\n/          the time is up. The timer can be "
      "canceled at any time. A timer\n/          can be configured to run once or to repeat.\n/\n/ "
      "         The timer uses a task to run in the background. The task will\n/          sleep "
      "until the timer is ready to run. When the timer is ready to\n/          run, the task will "
      "call the callback function. The callback\n/          function can return True to cancel the "
      "timer or False to keep the\n/          timer running. If the timer is configured to repeat, "
      "then the\n/          callback function will be called again after the period has\n/         "
      " elapsed. If the timer is configured to run once, then the\n/          callback function "
      "will only be called once.\n/\n/          The timer can be configured to start automatically "
      "when it is\n/          constructed. If the timer is not configured to start\n/          "
      "automatically, then the timer can be started by calling start().\n/          The timer can "
      "be canceled at any time by calling cancel().\n/\n/ @note The timer uses a task to run in "
      "the background, so the timer\n/       callback function will be called in the context of "
      "the task. The\n/       timer callback function should not block for a long time because "
      "it\n/       will block the task. If the timer callback function blocks for a\n/       long "
      "time, then the timer will not be able to keep up with the\n/       period.\n/\n/ \\section "
      "timer_ex1 Timer Example 1\n/ \\snippet timer_example.cpp timer example\n/ \\section "
      "timer_ex2 Timer Delay Example\n/ \\snippet timer_example.cpp timer delay example\n/ "
      "\\section timer_ex3 Oneshot Timer Example\n/ \\snippet timer_example.cpp timer oneshot "
      "example\n/ \\section timer_ex4 Timer Cancel Itself Example\n/ \\snippet timer_example.cpp "
      "timer cancel itself example\n/ \\section timer_ex5 Oneshot Timer Cancel Itself Then Start "
      "again with Delay Example\n/ \\snippet timer_example.cpp timer oneshot restart example\n/ "
      "\\section timer_ex6 Timer Update Period Example\n/ \\snippet timer_example.cpp timer update "
      "period example");

  { // inner classes & enums of Timer
    auto pyClassTimer_ClassConfig =
        py::class_<espp::Timer::Config>(pyClassTimer, "Config", py::dynamic_attr(),
                                        "/ @brief The configuration for the timer.")
            .def(py::init<>([](std::string_view name = std::string_view(),
                               std::chrono::duration<float> period = std::chrono::duration<float>(),
                               std::chrono::duration<float> delay = std::chrono::duration<float>(0),
                               espp::Timer::callback_fn callback = espp::Timer::callback_fn(),
                               bool auto_start = {true}, size_t stack_size_bytes = {4096},
                               size_t priority = {0}, int core_id = {-1},
                               espp::Logger::Verbosity log_level = espp::Logger::Verbosity::WARN) {
                   auto r = std::make_unique<espp::Timer::Config>();
                   r->name = name;
                   r->period = period;
                   r->delay = delay;
                   r->callback = callback;
                   r->auto_start = auto_start;
                   r->stack_size_bytes = stack_size_bytes;
                   r->priority = priority;
                   r->core_id = core_id;
                   r->log_level = log_level;
                   return r;
                 }),
                 py::arg("name") = std::string_view(),
                 py::arg("period") = std::chrono::duration<float>(),
                 py::arg("delay") = std::chrono::duration<float>(0),
                 py::arg("callback") = espp::Timer::callback_fn(),
                 py::arg("auto_start") = bool{true}, py::arg("stack_size_bytes") = size_t{4096},
                 py::arg("priority") = size_t{0}, py::arg("core_id") = int{-1},
                 py::arg("log_level") = espp::Logger::Verbosity::WARN)
            .def_readwrite("name", &espp::Timer::Config::name, "/< The name of the timer.")
            .def_readwrite(
                "period", &espp::Timer::Config::period,
                "/< The period of the timer. If 0, the timer callback will only be called once.")
            .def_readwrite("delay", &espp::Timer::Config::delay,
                           "/< The delay before the first execution of the timer callback after "
                           "start() is called.")
            .def_readwrite("callback", &espp::Timer::Config::callback,
                           "/< The callback function to call when the timer expires.")
            .def_readwrite("auto_start", &espp::Timer::Config::auto_start,
                           "/< If True, the timer will start automatically when constructed.")
            .def_readwrite("stack_size_bytes", &espp::Timer::Config::stack_size_bytes,
                           "/< The stack size of the task that runs the timer.")
            .def_readwrite("priority", &espp::Timer::Config::priority,
                           "/< Priority of the timer, 0 is lowest priority on ESP / FreeRTOS.")
            .def_readwrite("core_id", &espp::Timer::Config::core_id,
                           "/< Core ID of the timer, -1 means it is not pinned to any core.")
            .def_readwrite("log_level", &espp::Timer::Config::log_level,
                           "/< The log level for the timer.");
  } // end of inner classes & enums of Timer

  pyClassTimer.def(py::init<const espp::Timer::Config &>())
      .def(
          "start", [](espp::Timer &self) { return self.start(); },
          "/ @brief Start the timer.\n/ @details Starts the timer. Does nothing if the timer is "
          "already running.")
      .def("start", py::overload_cast<const std::chrono::duration<float> &>(&espp::Timer::start),
           py::arg("delay"),
           "/ @brief Start the timer with a delay.\n/ @details Starts the timer with a delay. If "
           "the timer is already running,\n/          this will cancel the timer and start it "
           "again with the new\n/          delay. If the timer is not running, this will start the "
           "timer\n/          with the delay. Overwrites any previous delay that might have\n/     "
           "     been set.\n/ @param delay The delay before the first execution of the timer "
           "callback.")
      .def("stop", &espp::Timer::stop,
           "/ @brief Stop the timer, same as cancel().\n/ @details Stops the timer, same as "
           "cancel().")
      .def("cancel", &espp::Timer::cancel,
           "/ @brief Cancel the timer.\n/ @details Cancels the timer.")
      .def("set_period", &espp::Timer::set_period, py::arg("period"),
           "/ @brief Set the period of the timer.\n/ @details Sets the period of the timer.\n/ "
           "@param period The period of the timer.\n/ @note If the period is 0, the timer will run "
           "once.\n/ @note If the period is negative, the period will not be set / updated.\n/ "
           "@note If the timer is running, the period will be updated after the\n/       current "
           "period has elapsed.")
      .def("is_running", &espp::Timer::is_running,
           "/ @brief Check if the timer is running.\n/ @details Checks if the timer is running.\n/ "
           "@return True if the timer is running, False otherwise.");
  ////////////////////    </generated_from:timer.hpp>    ////////////////////

  // </litgen_pydef> // Autogenerated code end
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
