#include <chrono>
#include <memory>
#include <string>
#include <system_error>
#include <vector>

#include <pybind11/chrono.h>
#include <pybind11/functional.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include "espp.hpp"

namespace py = pybind11;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

void py_init_module_espp_lib(py::module &m) {
  // using namespace espp;  // NON!

  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  // <litgen_pydef> // Autogenerated code below! Do not edit!
  ////////////////////    <generated_from:csv.hpp>    ////////////////////
  auto pyClass__csv_documentation__ =
      py::class_<espp::__csv_documentation__>(
          m, "__csv_documentation__",
          "*\n * @brief Comma Separated Value (CSV) reader/writer convenience wrapper around\n *   "
          "     <a href=\"https://github.com/p-ranav/csv2\">p-ranav/csv2</a> which\n *        "
          "exposes csv2::Reader and csv2::Writer classes for managing efficient\n *        "
          "(lazy-loaded) parsing and serizaliztion of human-readable\n *        CSV-formatted "
          "data.\n *\n * @note This class does not really exist or do anything, but it's the "
          "only\n *       way I could figure out how to get this documentation built into the\n *  "
          "     system :(\n *\n * \\section csv_ex1 CSV Reader Example\n * \\snippet "
          "csv_example.cpp csv reader example\n * \\section csv_ex2 Complex CSV Writer Example\n * "
          "\\snippet csv_example.cpp csv writer example\n")
          .def(py::init<>()) // implicit default constructor
      ;
  ////////////////////    </generated_from:csv.hpp>    ////////////////////

  ////////////////////    <generated_from:event_manager.hpp>    ////////////////////
  auto pyClassEventManager =
      py::class_<espp::EventManager>(
          m, "EventManager",
          "*\n * @brief Singleton class for managing events. Provides mechanisms for\n *        "
          "anonymous publish / subscribe interactions - enabling one to one,\n *        one to "
          "many, many to one, and many to many data distribution with\n *        loose coupling "
          "and low overhead. Each topic runs a thread for that\n *        topic's subscribers, "
          "executing all the callbacks in sequence and\n *        then going to sleep again until "
          "new data is published.\n *\n * @note In c++ objects, it's recommended to call the\n *   "
          "    add_publisher/add_subscriber functions in the class constructor and\n *       then "
          "to call the remove_publisher/remove_subscriber functions in the\n *       class "
          "destructor.\n *\n * @note It is recommended (unless you are only interested in events "
          "and not\n *       data or are only needing to transmit actual strings) to use a\n *     "
          "  serialization library (such as espp::serialization - which wraps\n *       alpaca) to "
          "serialize your data structures to string when publishing\n *       and then deserialize "
          "your data from string in the subscriber\n *       callbacks.\n *\n * \\section "
          "event_manager_ex1 Event Manager Example\n * \\snippet event_manager_example.cpp event "
          "manager example\n")
          .def_static("get", &espp::EventManager::get,
                      "*\n   * @brief Get the singleton instance of the EventManager.\n   * "
                      "@return A reference to the EventManager singleton.\n")
          .def("add_publisher", &espp::EventManager::add_publisher, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Register a publisher for \\p component on \\p topic.\n   * @param "
               "topic Topic name for the data being published.\n   * @param component Name of the "
               "component publishing data.\n   * @return True if the publisher was added, False if "
               "it was already\n   *         registered for that component.\n")
          .def(
              "add_subscriber",
              py::overload_cast<const std::string &, const std::string &, const event_callback_fn &,
                                const size_t>(&espp::EventManager::add_subscriber),
              py::arg("topic"), py::arg("component"), py::arg("callback"),
              py::arg("stack_size_bytes") = 8192,
              "*\n   * @brief Register a subscriber for \\p component on \\p topic.\n   * @param "
              "topic Topic name for the data being subscribed to.\n   * @param component Name of "
              "the component publishing data.\n   * @param callback The event_callback_fn to be "
              "called when receicing data on\n   *        \\p topic.\n   * @param stack_size_bytes "
              "The stack size in bytes to use for the subscriber\n   * @note The stack size is "
              "only used if a subscriber is not already registered\n   *       for that topic. If "
              "a subscriber is already registered for that topic,\n   *       the stack size is "
              "ignored.\n   * @return True if the subscriber was added, False if it was already\n  "
              " *         registered for that component.\n")
          .def(
              "add_subscriber",
              py::overload_cast<const std::string &, const std::string &, const event_callback_fn &,
                                const Task::BaseConfig &>(&espp::EventManager::add_subscriber),
              py::arg("topic"), py::arg("component"), py::arg("callback"), py::arg("task_config"),
              "*\n   * @brief Register a subscriber for \\p component on \\p topic.\n   * @param "
              "topic Topic name for the data being subscribed to.\n   * @param component Name of "
              "the component publishing data.\n   * @param callback The event_callback_fn to be "
              "called when receicing data on\n   *        \\p topic.\n   * @param task_config The "
              "task configuration to use for the subscriber.\n   * @note The task_config is only "
              "used if a subscriber is not already\n   *       registered for that topic. If a "
              "subscriber is already registered for\n   *       that topic, the task_config is "
              "ignored.\n   * @return True if the subscriber was added, False if it was already\n  "
              " *         registered for that component.\n")
          .def("publish", &espp::EventManager::publish, py::arg("topic"), py::arg("data"),
               "*\n   * @brief Publish \\p data on \\p topic.\n   * @param topic Topic to publish "
               "data on.\n   * @param data Data to publish, within a vector container.\n   * "
               "@return True if \\p data was successfully published to \\p topic, False\n   *      "
               "   otherwise. Publish will not occur (and will return False) if\n   *         "
               "there are no subscribers for this topic.\n")
          .def("remove_publisher", &espp::EventManager::remove_publisher, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Remove \\p component's publisher for \\p topic.\n   * @param topic "
               "The topic that \\p component was publishing on.\n   * @param component The "
               "component for which the publisher was registered.\n   * @return True if the "
               "publisher was removed, False if it was not\n   *         registered.\n")
          .def("remove_subscriber", &espp::EventManager::remove_subscriber, py::arg("topic"),
               py::arg("component"),
               "*\n   * @brief Remove \\p component's subscriber for \\p topic.\n   * @param topic "
               "The topic that \\p component was subscribing to.\n   * @param component The "
               "component for which the subscriber was registered.\n   * @return True if the "
               "subscriber was removed, False if it was not\n   *         registered.\n");
  ////////////////////    </generated_from:event_manager.hpp>    ////////////////////

  ////////////////////    <generated_from:file_system.hpp>    ////////////////////
  auto pyClassFileSystem = py::class_<espp::FileSystem>(
      m, "FileSystem",
      "/ @brief File system class\n/ @details\n/ This class is a singleton and should be accessed "
      "via the get() method.\n/ The class is responsible for mounting the file system and "
      "providing\n/ access to the file system. It is configured via the menuconfig system and "
      "will\n/ use the partition with the label specified in the menuconfig. The partition\n/ must "
      "be formatted with the LittleFS file system. The file system is mounted\n/ at the root "
      "directory of the partition such that all files will be stored\n/ under the path "
      "\"/<partition_label>/\".\n/ @see get_partition_label()\n/\n/ The class provides methods to "
      "get the amount of free, used and total space\n/ on the file system. It also provides a "
      "method to get a human readable string\n/ for a byte size.\n/\n/ \\section fs_ex1 File "
      "System Info Example\n/ \\snippet file_system_example.cpp file_system info example\n/ "
      "\\section fs_ex2 File System POSIX / NEWLIB Example\n/ \\snippet file_system_example.cpp "
      "file_system posix example\n/ \\section fs_ex3 File System Info std::filesystem Example\n/ "
      "\\snippet file_system_example.cpp file_system std filesystem example");

  { // inner classes & enums of FileSystem
    auto pyClassFileSystem_ClassListConfig =
        py::class_<espp::FileSystem::ListConfig>(
            pyClassFileSystem, "ListConfig",
            "/ @brief Config for listing the contents of a directory\n/ @details\n/ This struct is "
            "used to configure the output of the list_directory() method.\n/ It contains boolean "
            "values for each of the fields to include in the output.")
            .def(py::init<>([](bool type = true, bool permissions = true,
                               bool number_of_links = true, bool owner = true, bool group = true,
                               bool size = true, bool date_time = true, bool recursive = false) {
                   auto r = std::make_unique<espp::FileSystem::ListConfig>();
                   r->type = type;
                   r->permissions = permissions;
                   r->number_of_links = number_of_links;
                   r->owner = owner;
                   r->group = group;
                   r->size = size;
                   r->date_time = date_time;
                   r->recursive = recursive;
                   return r;
                 }),
                 py::arg("type") = true, py::arg("permissions") = true,
                 py::arg("number_of_links") = true, py::arg("owner") = true,
                 py::arg("group") = true, py::arg("size") = true, py::arg("date_time") = true,
                 py::arg("recursive") = false)
            .def_readwrite("type", &espp::FileSystem::ListConfig::type,
                           "/< The type of the file (directory, file, etc.)")
            .def_readwrite("permissions", &espp::FileSystem::ListConfig::permissions,
                           "/< The permissions of the file")
            .def_readwrite("number_of_links", &espp::FileSystem::ListConfig::number_of_links,
                           "/< The number of links to the file")
            .def_readwrite("owner", &espp::FileSystem::ListConfig::owner,
                           "/< The owner of the file")
            .def_readwrite("group", &espp::FileSystem::ListConfig::group,
                           "/< The group of the file")
            .def_readwrite("size", &espp::FileSystem::ListConfig::size, "/< The size of the file")
            .def_readwrite("date_time", &espp::FileSystem::ListConfig::date_time,
                           "/< The date and time of the file")
            .def_readwrite("recursive", &espp::FileSystem::ListConfig::recursive,
                           "/< Whether to list the contents of subdirectories");
  } // end of inner classes & enums of FileSystem

  pyClassFileSystem
      .def_static(
          "human_readable", &espp::FileSystem::human_readable, py::arg("bytes"),
          "/ @brief Get a human readable string for a byte size\n/ @details\n/ This method returns "
          "a human readable string for a byte size.\n/ It is copied from the example on the "
          "page:\n/ https://en.cppreference.com/w/cpp/filesystem/file_size\n/ @param bytes The "
          "byte size\n/ @return The human readable string")
      .def_static("get_mount_point", &espp::FileSystem::get_mount_point,
                  "/ @brief Get the mount point\n/ @details\n/ The mount point is the root "
                  "directory of the file system.\n/ It is the root directory of the partition with "
                  "the partition label.\n/ @see get_root_path()\n/ @return The mount point")
      .def_static("get_root_path", &espp::FileSystem::get_root_path,
                  "/ @brief Get the root path\n/ @details\n/ The root path is the root directory "
                  "of the file system.\n/ @see get_mount_point()\n/ @return The root path")
      .def_static("to_string",
                  py::overload_cast<const std::filesystem::perms &>(&espp::FileSystem::to_string),
                  py::arg("permissions"),
                  "/ @brief Convert file permissions to a string\n/ @details This method converts "
                  "file permissions to a string in the format \"rwxrwxrwx\".\n/ @param permissions "
                  "The file permissions\n/ @return The file permissions as a string")
      .def_static("to_string", py::overload_cast<time_t>(&espp::FileSystem::to_string),
                  py::arg("time"),
                  "/ @brief Convert a time_t to a string\n/ @details This method converts a time_t "
                  "to a string in the format \"Jan 01 00:00\".\n/ @param time The time_t to "
                  "convert\n/ @return The time as a string")
      .def_static("get", &espp::FileSystem::get,
                  "/ @brief Access the singleton instance of the file system\n/ @return Reference "
                  "to the file system instance")
      .def(py::init<const espp::FileSystem &>(), py::arg("param_0"))
      .def(py::init<espp::FileSystem &&>(), py::arg("param_0"))
      .def("get_free_space", &espp::FileSystem::get_free_space,
           "/ @brief Get the amount of free space on the file system\n/ @return The amount of free "
           "space in bytes")
      .def("get_total_space", &espp::FileSystem::get_total_space,
           "/ @brief Get the total amount of space on the file system\n/ @return The total amount "
           "of space in bytes")
      .def("get_used_space", &espp::FileSystem::get_used_space,
           "/ @brief Get the amount of used space on the file system\n/ @return The amount of used "
           "space in bytes")
      .def("get_file_time_as_string", &espp::FileSystem::get_file_time_as_string, py::arg("path"),
           "/ @brief Get the time of a file as a string\n/ @details This method gets the time of a "
           "file as a string in the format \"Jan 01 00:00\".\n/ @param path The path to the "
           "file\n/ @return The time of the file as a string\n/ @see file_time_to_string()")
      .def("get_files_in_path", &espp::FileSystem::get_files_in_path, py::arg("path"),
           py::arg("include_directories") = false, py::arg("recursive") = false,
           "/ @brief Get a vector of files in a directory\n/ @details This method returns a vector "
           "of paths to the files in a directory.\n/ @param path The path to the directory\n/ "
           "@param include_directories Whether to include directories in the output\n/ @param "
           "recursive Whether to include files in subdirectories\n/ @return A vector of paths to "
           "the files in the directory")
      .def("remove", &espp::FileSystem::remove, py::arg("path"), py::arg("ec"),
           "/ @brief Completely remove a file or directory (including contents)\n/ @details This "
           "method removes a file or directory and all of its contents.\n/          If the path is "
           "a directory, it will iterate over the contents\n/          and remove them "
           "recursively. If the path is a file, it will\n/          remove the file. If the path "
           "does not exist, it will return False.\n/ @param path The path to the file or "
           "directory\n/ @param ec The error code to set if an error occurs\n/ @return Whether the "
           "file or directory was successfully removed")
      .def("remove_contents", &espp::FileSystem::remove_contents, py::arg("path"), py::arg("ec"),
           "/ @brief Remove the contents of a directory, but not the directory itself\n/ @details "
           "This method removes the contents of a directory, but not the\n/          directory "
           "itself. If the path is not a directory, it will return\n/          False. If the path "
           "does not exist, it will return False. If the\n/          path is a directory, it will "
           "iterate over the contents and remove\n/          them recursively.\n/ @param path The "
           "path to the directory\n/ @param ec The error code to set if an error occurs\n/ @return "
           "Whether the contents of the directory were successfully removed")
      .def("list_directory",
           py::overload_cast<const std::filesystem::path &, const espp::FileSystem::ListConfig &,
                             const std::string &>(&espp::FileSystem::list_directory),
           py::arg("path"), py::arg("config"), py::arg("prefix") = "",
           "/ @brief List the contents of a directory\n/ @details\n/ This method lists the "
           "contents of a directory. It returns a string\n/ containing the contents of the "
           "directory. The contents are formatted\n/ according to the config. The config is a "
           "struct with boolean values\n/ for each of the fields to include in the output. The "
           "fields are:\n/ - type: The type of the file (directory, file, etc.)\n/ - permissions: "
           "The permissions of the file\n/ - number_of_links: The number of links to the file\n/ - "
           "owner: The owner of the file\n/ - group: The group of the file\n/ - size: The size of "
           "the file\n/ - date_time: The date and time of the file\n/ - recursive: Whether to list "
           "the contents of subdirectories\n/ @param path The path to the directory\n/ @param "
           "config The config for the output\n/ @param prefix The prefix to use for the output\n/ "
           "@return The contents of the directory")
      .def("list_directory",
           py::overload_cast<const std::string &, const espp::FileSystem::ListConfig &,
                             const std::string &>(&espp::FileSystem::list_directory),
           py::arg("path"), py::arg("config"), py::arg("prefix") = "",
           "/ @brief List the contents of a directory\n/ @details\n/ This method lists the "
           "contents of a directory. It returns a string\n/ containing the contents of the "
           "directory. The contents are formatted\n/ according to the config. The config is a "
           "struct with boolean values\n/ for each of the fields to include in the output. The "
           "fields are:\n/ - type: The type of the file (directory, file, etc.)\n/ - permissions: "
           "The permissions of the file\n/ - number_of_links: The number of links to the file\n/ - "
           "owner: The owner of the file\n/ - group: The group of the file\n/ - size: The size of "
           "the file\n/ - date_time: The date and time of the file\n/ - recursive: Whether to list "
           "the contents of subdirectories\n/ @param path The path to the directory\n/ @param "
           "config The config for the output\n/ @param prefix The prefix to use for the output\n/ "
           "@return The contents of the directory")
      .def_static(
          "to_time_t_filesystem_file_time_type",
          &espp::FileSystem::to_time_t<std::filesystem::file_time_type>, py::arg("tp"),
          "/ Function to convert a time_point to a time_t.\n/ \\details This function converts a "
          "time_point to a time_t. This function\n/     is needed because the standard library "
          "does not provide a function to\n/     convert a time_point to a time_t (until c++20 but "
          "support seems lacking\n/     on esp32). This function is taken from\n/     "
          "https://stackoverflow.com/a/61067330\n/ \tparam TP The type of the time_point.\n/ "
          "\\param tp The time_point to convert.\n/ \\return The time_t.");
  ////////////////////    </generated_from:file_system.hpp>    ////////////////////

  ////////////////////    <generated_from:ftp_server.hpp>    ////////////////////
  auto pyClassFtpServer =
      py::class_<espp::FtpServer>(m, "FtpServer", "/ \\brief A class that implements a FTP server.")
          .def(py::init<std::string_view, uint16_t, const std::filesystem::path &>(),
               py::arg("ip_address"), py::arg("port"), py::arg("root"),
               "/ \\brief A class that implements a FTP server.\n/ \note The IP Address is not "
               "currently used to select the right\n/       interface, but is instead passed to "
               "the FtpClientSession so that\n/       it can be used in the PASV command.\n/ "
               "\\param ip_address The IP address to listen on.\n/ \\param port The port to listen "
               "on.\n/ \\param root The root directory of the FTP server.")
          .def("start", &espp::FtpServer::start,
               "/ \\brief Start the FTP server.\n/ Bind to the port and start accepting "
               "connections.\n/ \\return True if the server was started, False otherwise.")
          .def("stop", &espp::FtpServer::stop, "/ \\brief Stop the FTP server.");
  ////////////////////    </generated_from:ftp_server.hpp>    ////////////////////

  ////////////////////    <generated_from:gaussian.hpp>    ////////////////////
  auto pyClassGaussian = py::class_<espp::Gaussian>(
      m, "Gaussian",
      "*\n * @brief Implements a gaussian function\n *        "
      "\\f$y(t)=\\alpha\\exp(-\\frac{(t-\\beta)^2}{2\\gamma^2})\\f$.\n * @details Alows you to "
      "store the alpha, beta, and gamma coefficients as well\n *          as update them "
      "dynamically.\n *\n * \\section gaussian_ex1 Example\n * \\snippet math_example.cpp gaussian "
      "example\n");

  { // inner classes & enums of Gaussian
    auto pyClassGaussian_ClassConfig =
        py::class_<espp::Gaussian::Config>(
            pyClassGaussian, "Config",
            "*\n   * @brief Configuration structure for initializing the gaussian.\n")
            .def(py::init<>([](float gamma = float(), float alpha = 1.0f, float beta = 0.5f) {
                   auto r = std::make_unique<espp::Gaussian::Config>();
                   r->gamma = gamma;
                   r->alpha = alpha;
                   r->beta = beta;
                   return r;
                 }),
                 py::arg("gamma") = float(), py::arg("alpha") = 1.0f, py::arg("beta") = 0.5f)
            .def_readwrite(
                "gamma", &espp::Gaussian::Config::gamma,
                "/< Slope of the gaussian, range [0, 1]. 0 is more of a thin spike from 0 up to")
            .def_readwrite("alpha", &espp::Gaussian::Config::alpha,
                           "/< Max amplitude of the gaussian output, defautls to 1.0.")
            .def_readwrite(
                "beta", &espp::Gaussian::Config::beta,
                "/< Beta value for the gaussian, default to be symmetric at 0.5 in range [0,1].");
  } // end of inner classes & enums of Gaussian

  pyClassGaussian
      .def(py::init<>()) // implicit default constructor
      .def("gamma", &espp::Gaussian::gamma, py::arg("g"),
           "*\n   * @brief Set / Update the gamma (shape) value.\n   * @param g New gamma (shape) "
           "to use.\n")
      .def(
          "alpha", [](espp::Gaussian &self) { return self.alpha(); },
          "*\n   * @brief Get the currently configured alpha (scaling) value.\n   * @return The "
          "current alpha (scaler) value.\n")
      .def("alpha", py::overload_cast<float>(&espp::Gaussian::alpha), py::arg("a"),
           "*\n   * @brief Set / Update the alpha (scaling) value.\n   * @param a New alpha "
           "(scaler) to use.\n")
      .def(
          "beta", [](espp::Gaussian &self) { return self.beta(); },
          "*\n   * @brief Get the currently configured beta (shifting) value.\n   * @return The "
          "current beta (shifter) value [0, 1].\n")
      .def("beta", py::overload_cast<float>(&espp::Gaussian::beta), py::arg("b"),
           "*\n   * @brief Set / Update the beta (shifting) value.\n   * @param b New beta "
           "(shifter) to use.\n")
      .def("at", &espp::Gaussian::at, py::arg("t"),
           "*\n   * @brief Evaluate the gaussian at \\p t.\n   * @param t The evaluation "
           "parameter, [0, 1].\n   * @return The gaussian evaluated at \\p t.\n")
      .def("__call__", &espp::Gaussian::operator(), py::arg("t"),
           "*\n   * @brief Evaluate the gaussian at \\p t.\n   * @note Convienience wrapper around "
           "the at() method.\n   * @param t The evaluation parameter, [0, 1].\n   * @return The "
           "gaussian evaluated at \\p t.\n");
  ////////////////////    </generated_from:gaussian.hpp>    ////////////////////

  ////////////////////    <generated_from:task.hpp>    ////////////////////
  auto pyClassTask = py::class_<espp::Task>(
      m, "Task",
      "*\n * @brief Task provides an abstraction over std::thread which optionally\n * includes "
      "memory / priority configuration on ESP systems. It allows users to\n * easily stop the "
      "task, and will automatically stop itself if destroyed.\n *\n * There is also a utility "
      "function which can be used to get the info for the\n * task of the current context, or for "
      "a provided Task object.\n *\n * There is also a helper function to run a lambda on a "
      "specific core, which can\n * be used to run a specific function on a specific core, as you "
      "might want to\n * do when registering an interrupt driver on a specific core.\n *\n * "
      "\\section task_ex1 Basic Task Example\n * \\snippet task_example.cpp Task example\n * "
      "\\section task_ex2 Many Task Example\n * \\snippet task_example.cpp ManyTask example\n * "
      "\\section task_ex3 Long Running Task Example\n * \\snippet task_example.cpp LongRunningTask "
      "example\n * \\section task_ex4 Task Info Example\n * \\snippet task_example.cpp Task Info "
      "example\n * \\section task_ex5 Task Request Stop Example\n * \\snippet task_example.cpp "
      "Task Request Stop example\n *\n * \\section run_on_core_ex1 Run on Core Example\n * "
      "\\snippet task_example.cpp run on core example\n");

  { // inner classes & enums of Task
    auto pyClassTask_ClassBaseConfig =
        py::class_<espp::Task::BaseConfig>(
            pyClassTask, "BaseConfig",
            "*\n   * @brief Base configuration struct for the Task.\n   * @note This is designed "
            "to be used as a configuration struct in other classes\n   *       that may have a "
            "Task as a member.\n")
            .def(py::init<>([](std::string name = std::string(), size_t stack_size_bytes = {4096},
                               size_t priority = {0}, int core_id = {-1}) {
                   auto r = std::make_unique<espp::Task::BaseConfig>();
                   r->name = name;
                   r->stack_size_bytes = stack_size_bytes;
                   r->priority = priority;
                   r->core_id = core_id;
                   return r;
                 }),
                 py::arg("name") = std::string(), py::arg("stack_size_bytes") = size_t{4096},
                 py::arg("priority") = size_t{0}, py::arg("core_id") = int{-1})
            .def_readwrite("name", &espp::Task::BaseConfig::name, "*< Name of the task")
            .def_readwrite("stack_size_bytes", &espp::Task::BaseConfig::stack_size_bytes,
                           "*< Stack Size (B) allocated to the task.")
            .def_readwrite("priority", &espp::Task::BaseConfig::priority,
                           "*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.")
            .def_readwrite("core_id", &espp::Task::BaseConfig::core_id,
                           "*< Core ID of the task, -1 means it is not pinned to any core.");
    auto pyClassTask_ClassConfig =
        py::class_<espp::Task::Config>(
            pyClassTask, "Config",
            "*\n   * @brief Configuration struct for the Task.\n   * @note This is the recommended "
            "way to configure the Task, and allows you to\n   *       use the condition variable "
            "and mutex from the task to wait_for and\n   *       wait_until.\n   * @note This is "
            "an older configuration struct, and is kept for backwards\n   *       compatibility. "
            "It is recommended to use the AdvancedConfig struct\n   *       instead.\n")
            .def(py::init<>(
                     [](std::string name = std::string(), callback_fn callback = callback_fn(),
                        size_t stack_size_bytes = {4096}, size_t priority = {0}, int core_id = {-1},
                        Logger::Verbosity log_level = {Logger::Verbosity::WARN}) {
                       auto r = std::make_unique<espp::Task::Config>();
                       r->name = name;
                       r->callback = callback;
                       r->stack_size_bytes = stack_size_bytes;
                       r->priority = priority;
                       r->core_id = core_id;
                       r->log_level = log_level;
                       return r;
                     }),
                 py::arg("name") = std::string(), py::arg("callback") = callback_fn(),
                 py::arg("stack_size_bytes") = size_t{4096}, py::arg("priority") = size_t{0},
                 py::arg("core_id") = int{-1},
                 py::arg("log_level") = Logger::Verbosity{Logger::Verbosity::WARN})
            .def_readwrite("name", &espp::Task::Config::name, "*< Name of the task")
            .def_readwrite("callback", &espp::Task::Config::callback, "*< Callback function")
            .def_readwrite("stack_size_bytes", &espp::Task::Config::stack_size_bytes,
                           "*< Stack Size (B) allocated to the task.")
            .def_readwrite("priority", &espp::Task::Config::priority,
                           "*< Priority of the task, 0 is lowest priority on ESP / FreeRTOS.")
            .def_readwrite("core_id", &espp::Task::Config::core_id,
                           "*< Core ID of the task, -1 means it is not pinned to any core.")
            .def_readwrite("log_level", &espp::Task::Config::log_level,
                           "*< Log verbosity for the task.");
    auto pyClassTask_ClassSimpleConfig =
        py::class_<espp::Task::SimpleConfig>(
            pyClassTask, "SimpleConfig",
            "*\n   * @brief Simple configuration struct for the Task.\n   * @note This is useful "
            "for when you don't need to use the condition variable\n   *       or mutex in the "
            "callback.\n")
            .def(py::init<>([](simple_callback_fn callback = simple_callback_fn(),
                               BaseConfig task_config = BaseConfig(),
                               Logger::Verbosity log_level = {Logger::Verbosity::WARN}) {
                   auto r = std::make_unique<espp::Task::SimpleConfig>();
                   r->callback = callback;
                   r->task_config = task_config;
                   r->log_level = log_level;
                   return r;
                 }),
                 py::arg("callback") = simple_callback_fn(), py::arg("task_config") = BaseConfig(),
                 py::arg("log_level") = Logger::Verbosity{Logger::Verbosity::WARN})
            .def_readwrite("callback", &espp::Task::SimpleConfig::callback, "*< Callback function")
            .def_readwrite("task_config", &espp::Task::SimpleConfig::task_config,
                           "*< Base configuration for the task.")
            .def_readwrite("log_level", &espp::Task::SimpleConfig::log_level,
                           "*< Log verbosity for the task.");
    auto pyClassTask_ClassAdvancedConfig =
        py::class_<espp::Task::AdvancedConfig>(
            pyClassTask, "AdvancedConfig",
            "*\n   * @brief Advanced configuration struct for the Task.\n   * @note This is the "
            "recommended way to configure the Task, and allows you to\n   *       use the "
            "condition variable and mutex from the task to wait_for and\n   *       wait_until.\n")
            .def(py::init<>([](callback_fn callback = callback_fn(),
                               BaseConfig task_config = BaseConfig(),
                               Logger::Verbosity log_level = {Logger::Verbosity::WARN}) {
                   auto r = std::make_unique<espp::Task::AdvancedConfig>();
                   r->callback = callback;
                   r->task_config = task_config;
                   r->log_level = log_level;
                   return r;
                 }),
                 py::arg("callback") = callback_fn(), py::arg("task_config") = BaseConfig(),
                 py::arg("log_level") = Logger::Verbosity{Logger::Verbosity::WARN})
            .def_readwrite("callback", &espp::Task::AdvancedConfig::callback,
                           "*< Callback function")
            .def_readwrite("task_config", &espp::Task::AdvancedConfig::task_config,
                           "*< Base configuration for the task.")
            .def_readwrite("log_level", &espp::Task::AdvancedConfig::log_level,
                           "*< Log verbosity for the task.");
  } // end of inner classes & enums of Task

  pyClassTask
      .def(py::init<>()) // implicit default constructor
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::Config &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config Config struct to initialize the Task with.\n   * @return "
                  "std::unique_ptr<Task> pointer to the newly created task.\n")
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::SimpleConfig &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config SimpleConfig struct to initialize the Task with.\n   * @return "
                  "std::unique_ptr<Task> pointer to the newly created task.\n")
      .def_static("make_unique",
                  py::overload_cast<const espp::Task::AdvancedConfig &>(&espp::Task::make_unique),
                  py::arg("config"),
                  "*\n   * @brief Get a unique pointer to a new task created with \\p config.\n   "
                  "*        Useful to not have to use templated std::make_unique (less typing).\n  "
                  " * @param config AdvancedConfig struct to initialize the Task with.\n   * "
                  "@return std::unique_ptr<Task> pointer to the newly created task.\n")
      .def("start", &espp::Task::start,
           "*\n   * @brief Start executing the task.\n   *\n   * @return True if the task started, "
           "False if it was already started.\n")
      .def("stop", &espp::Task::stop,
           "*\n   * @brief Stop the task execution, blocking until it stops.\n   *\n   * @return "
           "True if the task stopped, False if it was not started / already\n   * stopped.\n")
      .def("is_started", &espp::Task::is_started,
           "*\n   * @brief Has the task been started or not?\n   *\n   * @return True if the task "
           "is started / running, False otherwise.\n")
      .def("is_running", &espp::Task::is_running,
           "*\n   * @brief Is the task running?\n   *\n   * @return True if the task is running, "
           "False otherwise.\n");
  ////////////////////    </generated_from:task.hpp>    ////////////////////

  ////////////////////    <generated_from:tcp_socket.hpp>    ////////////////////
  auto pyClassTcpSocket = py::class_<espp::TcpSocket>(
      m, "TcpSocket",
      "*\n *   @brief Class for managing sending and receiving data using TCP/IP. Can be\n *       "
      "   used to create client or server sockets.\n *\n * \\section tcp_ex1 TCP Client Example\n "
      "* \\snippet socket_example.cpp TCP Client example\n * \\section tcp_ex2 TCP Server "
      "Example\n * \\snippet socket_example.cpp TCP Server example\n *\n * \\section tcp_ex3 TCP "
      "Client Response Example\n * \\snippet socket_example.cpp TCP Client Response example\n * "
      "\\section tcp_ex4 TCP Server Response Example\n * \\snippet socket_example.cpp TCP Server "
      "Response example\n *\n");

  { // inner classes & enums of TcpSocket
    auto pyClassTcpSocket_ClassConfig =
        py::class_<espp::TcpSocket::Config>(pyClassTcpSocket, "Config",
                                            "*\n   * @brief Config struct for the TCP socket.\n")
            .def(py::init<>([](Logger::Verbosity log_level = {Logger::Verbosity::WARN}) {
                   auto r = std::make_unique<espp::TcpSocket::Config>();
                   r->log_level = log_level;
                   return r;
                 }),
                 py::arg("log_level") = Logger::Verbosity{Logger::Verbosity::WARN})
            .def_readwrite("log_level", &espp::TcpSocket::Config::log_level,
                           "*< Verbosity level for the TCP socket logger.");
    auto pyClassTcpSocket_ClassConnectConfig =
        py::class_<espp::TcpSocket::ConnectConfig>(
            pyClassTcpSocket, "ConnectConfig",
            "*\n   * @brief Config struct for connecting to a remote TCP server.\n")
            .def(py::init<>([](std::string ip_address = std::string(), size_t port = size_t()) {
                   auto r = std::make_unique<espp::TcpSocket::ConnectConfig>();
                   r->ip_address = ip_address;
                   r->port = port;
                   return r;
                 }),
                 py::arg("ip_address") = std::string(), py::arg("port") = size_t())
            .def_readwrite("ip_address", &espp::TcpSocket::ConnectConfig::ip_address,
                           "*< Address to send data to.")
            .def_readwrite("port", &espp::TcpSocket::ConnectConfig::port,
                           "*< Port number to send data to.");
  } // end of inner classes & enums of TcpSocket

  pyClassTcpSocket
      .def(py::init<>()) // implicit default constructor
      .def("reinit", &espp::TcpSocket::reinit,
           "*\n   * @brief Reinitialize the socket, cleaning it up if first it is already\n   *    "
           "    initalized.\n")
      .def("close", &espp::TcpSocket::close, "*\n   * @brief Close the socket.\n")
      .def("is_connected", &espp::TcpSocket::is_connected,
           "*\n   * @brief Check if the socket is connected to a remote endpoint.\n   * @return "
           "True if the socket is connected to a remote endpoint.\n")
      .def("connect", &espp::TcpSocket::connect, py::arg("connect_config"),
           "*\n   * @brief Open a connection to the remote TCP server.\n   * @param connect_config "
           "ConnectConfig struct describing the server endpoint.\n   * @return True if the client "
           "successfully connected to the server.\n")
      .def("get_remote_info", &espp::TcpSocket::get_remote_info,
           "*\n   * @brief Get the remote endpoint info.\n   * @return The remote endpoint info.\n")
      .def("transmit",
           py::overload_cast<const std::vector<uint8_t> &, const espp::detail::TcpTransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::detail::TcpTransmitConfig{})
      .def("transmit",
           py::overload_cast<const std::vector<char> &, const espp::detail::TcpTransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::detail::TcpTransmitConfig{})
      .def("transmit",
           py::overload_cast<std::string_view, const espp::detail::TcpTransmitConfig &>(
               &espp::TcpSocket::transmit),
           py::arg("data"), py::arg("transmit_config") = espp::detail::TcpTransmitConfig{})
      .def("receive", py::overload_cast<std::vector<uint8_t> &, size_t>(&espp::TcpSocket::receive),
           py::arg("data"), py::arg("max_num_bytes"),
           "*\n   * @brief Call read on the socket, assuming it has already been configured\n   *  "
           "      appropriately.\n   *\n   * @param data Vector of bytes of received data.\n   * "
           "@param max_num_bytes Maximum number of bytes to receive.\n   * @return True if "
           "successfully received, False otherwise.\n")
      .def("receive", py::overload_cast<uint8_t *, size_t>(&espp::TcpSocket::receive),
           py::arg("data"), py::arg("max_num_bytes"),
           "*\n   * @brief Call read on the socket, assuming it has already been configured\n   *  "
           "      appropriately.\n   * @note This function will block until max_num_bytes are "
           "received or the\n   *       receive timeout is reached.\n   * @note The data pointed "
           "to by data must be at least max_num_bytes in size.\n   * @param data Pointer to buffer "
           "to receive data.\n   * @param max_num_bytes Maximum number of bytes to receive.\n   * "
           "@return Number of bytes received.\n")
      .def("bind", &espp::TcpSocket::bind, py::arg("port"),
           "*\n   * @brief Bind the socket as a server on \\p port.\n   * @param port The port to "
           "which to bind the socket.\n   * @return True if the socket was bound.\n")
      .def("listen", &espp::TcpSocket::listen, py::arg("max_pending_connections"),
           "*\n   * @brief Listen for incoming client connections.\n   * @note Must be called "
           "after bind and before accept.\n   * @see bind\n   * @see accept\n   * @param "
           "max_pending_connections Max number of allowed pending connections.\n   * @return True "
           "if socket was able to start listening.\n")
      .def("accept", &espp::TcpSocket::accept,
           "*\n   * @brief Accept an incoming connection.\n   * @note Blocks until a connection is "
           "accepted.\n   * @note Must be called after listen.\n   * @note This function will "
           "block until a connection is accepted.\n   * @return A unique pointer to a "
           "TcpClientSession if a connection was\n   *         accepted, None otherwise.\n");
  ////////////////////    </generated_from:tcp_socket.hpp>    ////////////////////

  ////////////////////    <generated_from:deep_history_state.hpp>    ////////////////////

  { // <namespace state_machine>
    py::module_ pyNsstate_machine = m.def_submodule("state_machine", "namespace state_machine");
    auto pyNsstate_machine_ClassDeepHistoryState =
        py::class_<espp::state_machine::DeepHistoryState>(
            pyNsstate_machine, "DeepHistoryState",
            "*\n * @brief Deep History Pseudostates exist purely to re-implement the\n *  "
            "makeActive() function to actually call\n *  _parentState->setDeepHistory()\n")
            .def(py::init<>(), "*\n   * @brief Construct a new Deep History State object\n")
            .def(py::init<StateBase *>(), py::arg("_parent"),
                 "*\n   * @brief Construct a new Deep History State object\n   * @param _parent "
                 "The parent state of this state\n")
            .def("make_active", &espp::state_machine::DeepHistoryState::makeActive,
                 "*\n   * @brief Calls _parentState->setDeepHistory()\n");
  } // </namespace state_machine>
  ////////////////////    </generated_from:deep_history_state.hpp>    ////////////////////

  ////////////////////    <generated_from:shallow_history_state.hpp>    ////////////////////

  { // <namespace state_machine>
    py::module_ pyNsstate_machine = m.def_submodule("state_machine", "namespace state_machine");
    auto pyNsstate_machine_ClassShallowHistoryState =
        py::class_<espp::state_machine::ShallowHistoryState>(
            pyNsstate_machine, "ShallowHistoryState",
            "*\n * @brief Shallow History Pseudostates exist purely to re-implement\n *  the "
            "makeActive() function to actually call\n *  _parentState->setShallowHistory()\n")
            .def(py::init<>(), "*\n   * @brief Default constructor\n")
            .def(py::init<StateBase *>(), py::arg("_parent"),
                 "*\n   * @brief Constructor\n   * @param _parent The parent state\n")
            .def("make_active", &espp::state_machine::ShallowHistoryState::makeActive,
                 "*\n   * @brief Calls _parentState->setShallowHistory().\n");
  } // </namespace state_machine>
  ////////////////////    </generated_from:shallow_history_state.hpp>    ////////////////////

  ////////////////////    <generated_from:state_base.hpp>    ////////////////////

  { // <namespace state_machine>
    py::module_ pyNsstate_machine = m.def_submodule("state_machine", "namespace state_machine");
    auto pyNsstate_machine_ClassEventBase =
        py::class_<espp::state_machine::EventBase>(pyNsstate_machine, "EventBase",
                                                   "class EventBase")
            .def(py::init<>()) // implicit default constructor
            .def("to_string", &espp::state_machine::EventBase::to_string,
                 "/ Returns a string representation of the event");

    auto pyNsstate_machine_ClassStateBase =
        py::class_<espp::state_machine::StateBase>(pyNsstate_machine, "StateBase",
                                                   "class StateBase")
            .def(py::init<>(), "*\n   * @brief Default constructor\n")
            .def(py::init<espp::state_machine::StateBase *>(), py::arg("parent"),
                 "*\n   * @brief Constructor that sets the parent state.\n   * @param[in] parent "
                 "Pointer to parent state\n")
            .def("initialize", &espp::state_machine::StateBase::initialize,
                 "*\n   * @brief Will be generated to call entry() then handle any child\n   *  "
                 "initialization. Finally calls makeActive on the leaf.\n")
            .def("entry", &espp::state_machine::StateBase::entry,
                 "*\n   * @brief Will be generated to run the entry() function defined in\n   *  "
                 "the model.\n")
            .def("exit", &espp::state_machine::StateBase::exit,
                 "*\n   * @brief Will be generated to run the exit() function defined in\n   *   "
                 "the model.\n")
            .def("handle_event", &espp::state_machine::StateBase::handleEvent, py::arg("event"),
                 "*\n   * @brief Calls handleEvent on the activeLeaf.\n   * @param[in] event Event "
                 "needing to be handled\n   * @return True if event is consumed, False otherwise\n")
            .def("tick", &espp::state_machine::StateBase::tick,
                 "*\n   * @brief Will be generated to run the tick() function defined in\n   *  "
                 "the model and then call _activeState->tick().\n")
            .def("get_timer_period", &espp::state_machine::StateBase::getTimerPeriod,
                 "*\n   * @brief Returns the timer period for the state.\n")
            .def("get_initial", &espp::state_machine::StateBase::getInitial,
                 "*\n   * @brief Will be known from the model so will be generated in\n   *  "
                 "derived classes to immediately return the correct initial\n   *  state pointer "
                 "for quickly transitioning to the proper state\n   *  during external transition "
                 "handling.\n   * @return Pointer to initial substate\n")
            .def("exit_children", &espp::state_machine::StateBase::exitChildren,
                 "*\n   * @brief Recurses down to the leaf state and calls the exit\n   *  actions "
                 "as it unwinds.\n")
            .def("get_active_child", &espp::state_machine::StateBase::getActiveChild,
                 "*\n   * @brief Will return _activeState if it exists, otherwise will\n   *  "
                 "return None.\n   * @return Pointer to last active substate\n")
            .def("get_active_leaf", &espp::state_machine::StateBase::getActiveLeaf,
                 "*\n   * @brief Will return the active leaf state, otherwise will return\n   *  "
                 "None.\n   * @return Pointer to last active leaf state.\n")
            .def("make_active", &espp::state_machine::StateBase::makeActive,
                 "*\n   * @brief Make this state the active substate of its parent and\n   *  then "
                 "recurse up through the tree to the root.\n   * @note Should only be called on "
                 "leaf nodes!\n")
            .def("set_active_child", &espp::state_machine::StateBase::setActiveChild,
                 py::arg("child_state"), "*\n   * @brief Update the active child state.\n")
            .def("set_shallow_history", &espp::state_machine::StateBase::setShallowHistory,
                 "*\n   * @brief Sets the currentlyActive state to the last active state\n   *  "
                 "and re-initializes them.\n")
            .def("set_deep_history", &espp::state_machine::StateBase::setDeepHistory,
                 "*\n   * @brief Go to the last active leaf of this state. If none\n   *  exists, "
                 "re-initialize.\n")
            .def("set_parent_state", &espp::state_machine::StateBase::setParentState,
                 py::arg("parent"),
                 "*\n   * @brief Will set the parent state.\n   * @param[in] parent Pointer to "
                 "parent state\n")
            .def("get_parent_state", &espp::state_machine::StateBase::getParentState,
                 "*\n   * @brief Will return the parent state.\n")
            .def_readwrite(
                "_active_state", &espp::state_machine::StateBase::_activeState,
                " Pointer to the currently or most recently active substate of this\n state.")
            .def_readwrite("_parent_state", &espp::state_machine::StateBase::_parentState,
                           "Pointer to the parent state of this state.");
  } // </namespace state_machine>
  ////////////////////    </generated_from:state_base.hpp>    ////////////////////

  ////////////////////    <generated_from:rtsp_server.hpp>    ////////////////////
  auto pyClassRtspServer = py::class_<espp::RtspServer>(
      m, "RtspServer",
      "/ Class for streaming MJPEG data from a camera using RTSP + RTP\n/ Starts a TCP socket to "
      "listen for RTSP connections, and then spawns off a\n/ new RTSP session for each "
      "connection.\n/ @see RtspSession\n/ @note This class does not currently send RTCP "
      "packets\n/\n/ \\section RtspServer example\n/ \\snippet rtsp_example.cpp "
      "rtsp_server_example");

  { // inner classes & enums of RtspServer
    auto pyClassRtspServer_ClassConfig =
        py::class_<espp::RtspServer::Config>(pyClassRtspServer, "Config",
                                             "/ @brief Configuration for the RTSP server")
            .def(py::init<>([](std::string server_address = std::string(), int port = int(),
                               std::string path = std::string(), size_t max_data_size = 1000,
                               Logger::Verbosity log_level = Logger::Verbosity::WARN) {
                   auto r = std::make_unique<espp::RtspServer::Config>();
                   r->server_address = server_address;
                   r->port = port;
                   r->path = path;
                   r->max_data_size = max_data_size;
                   r->log_level = log_level;
                   return r;
                 }),
                 py::arg("server_address") = std::string(), py::arg("port") = int(),
                 py::arg("path") = std::string(), py::arg("max_data_size") = 1000,
                 py::arg("log_level") = Logger::Verbosity::WARN)
            .def_readwrite("server_address", &espp::RtspServer::Config::server_address,
                           "/< The ip address of the server")
            .def_readwrite("port", &espp::RtspServer::Config::port, "/< The port to listen on")
            .def_readwrite("path", &espp::RtspServer::Config::path,
                           "/< The path to the RTSP stream")
            .def_readwrite("max_data_size", &espp::RtspServer::Config::max_data_size,
                           "/< The maximum size of RTP packet data for the MJPEG stream. Frames "
                           "will be broken")
            .def_readwrite("log_level", &espp::RtspServer::Config::log_level,
                           "/< The log level for the RTSP server");
  } // end of inner classes & enums of RtspServer

  pyClassRtspServer
      .def(py::init<>()) // implicit default constructor
      .def("set_session_log_level", &espp::RtspServer::set_session_log_level, py::arg("log_level"),
           "/ @brief Sets the log level for the RTSP sessions created by this server\n/ @note This "
           "does not affect the log level of the RTSP server itself\n/ @note This does not change "
           "the log level of any sessions that have\n/       already been created\n/ @param "
           "log_level The log level to set")
      .def("start", &espp::RtspServer::start,
           "/ @brief Start the RTSP server\n/ Starts the accept task, session task, and binds the "
           "RTSP socket\n/ @return True if the server was started successfully, False otherwise")
      .def("stop", &espp::RtspServer::stop,
           "/ @brief Stop the FTP server\n/ Stops the accept task, session task, and closes the "
           "RTSP socket")
      .def("send_frame", &espp::RtspServer::send_frame, py::arg("frame"),
           "/ @brief Send a frame over the RTSP connection\n/ Converts the full JPEG frame into a "
           "series of simplified RTP/JPEG\n/ packets and stores it to be sent over the RTP socket, "
           "but does not\n/ actually send it\n/ @note Overwrites any existing frame that has not "
           "been sent\n/ @param frame The frame to send");
  ////////////////////    </generated_from:rtsp_server.hpp>    ////////////////////

  ////////////////////    <generated_from:color.hpp>    ////////////////////
  auto pyClassRgb =
      py::class_<espp::Rgb>(m, "Rgb",
                            "*\n * @brief Class representing a color using RGB color space.\n")
          .def_readwrite("r", &espp::Rgb::r, "/< Red value ∈ [0, 1]")
          .def_readwrite("g", &espp::Rgb::g, "/< Green value ∈ [0, 1]")
          .def_readwrite("b", &espp::Rgb::b, "/< Blue value ∈ [0, 1]")
          .def(py::init<>())
          .def(py::init<const float &, const float &, const float &>(), py::arg("r"), py::arg("g"),
               py::arg("b"),
               "*\n   * @brief Construct an Rgb object from the provided rgb values.\n   * @note "
               "If provided values outside the range [0,1], it will rescale them to\n   *       be "
               "within the range [0,1] by dividing by 255.\n   * @param r Floating point value for "
               "the red channel, should be in range [0,\n   *        1]\n   * @param g Floating "
               "point value for the green channel, should be in range\n   *        [0, 1]\n   * "
               "@param b Floating point value for the blue channel, should be in range\n   *       "
               " [0, 1]\n")
          .def(py::init<const espp::Rgb &>(), py::arg("rgb"),
               "*\n   * @brief Copy-construct an Rgb object from the provided object.\n   * @note "
               "If provided values outside the range [0,1], it will rescale them to\n   *       be "
               "within the range [0,1] by dividing by 255.\n   * @param rgb Rgb struct containing "
               "the values to copy.\n")
          .def(py::init<const espp::Hsv &>(), py::arg("hsv"),
               "*\n   * @brief Construct an Rgb object from the provided Hsv object.\n   * @note "
               "This calls hsv.rgb() on the provided object, which means fthat\n   *       invalid "
               "HSV data (not in the ranges [0,360], [0,1], and [0,1])\n   *       could lead to "
               "bad RGB data. The Rgb constructor will automatically\n   *       convert the "
               "values to be in the proper range, but the perceived\n   *       color will be "
               "changed.\n   * @param hsv Hsv object to copy.\n")
          .def("__add__", &espp::Rgb::operator+, py::arg("rhs"),
               "*\n   * @brief Perform additive color blending (averaging)\n   * @param rhs Other "
               "color to add to this color to create the resultant color\n   * @return Resultant "
               "color from blending this color with the \\p rhs color.\n")
          .def("__iadd__", &espp::Rgb::operator+=, py::arg("rhs"),
               "*\n   * @brief Perform additive color blending (averaging)\n   * @param rhs Other "
               "color to add to this color\n")
          .def("__eq__", &espp::Rgb::operator==, py::arg("rhs"))
          .def("__ne__", &espp::Rgb::operator!=, py::arg("rhs"))
          .def("hsv", &espp::Rgb::hsv,
               "*\n   * @brief Get a HSV representation of this RGB color.\n   * @return An HSV "
               "object containing the HSV representation.\n");

  auto pyClassHsv =
      py::class_<espp::Hsv>(m, "Hsv",
                            "*\n * @brief Class representing a color using HSV color space.\n")
          .def_readwrite("h", &espp::Hsv::h, "/< Hue ∈ [0, 360]")
          .def_readwrite("s", &espp::Hsv::s, "/< Saturation ∈ [0, 1]")
          .def_readwrite("v", &espp::Hsv::v, "/< Value ∈ [0, 1]")
          .def(py::init<>())
          .def(py::init<const float &, const float &, const float &>(), py::arg("h"), py::arg("s"),
               py::arg("v"),
               "*\n   * @brief Construct a Hsv object from the provided values.\n   * @param h Hue "
               "- will be clamped to be in range [0, 360]\n   * @param s Saturation - will be "
               "clamped to be in range [0, 1]\n   * @param v Value - will be clamped to be in "
               "range [0, 1]\n")
          .def(py::init<const espp::Hsv &>(), py::arg("hsv"),
               "*\n   * @brief Copy-construct the Hsv object\n   * @param hsv Object to copy "
               "from.\n")
          .def(py::init<const espp::Rgb &>(), py::arg("rgb"),
               "*\n   * @brief Construct Hsv object from Rgb object. Calls rgb.hsv() to perform\n  "
               " *        the conversion.\n   * @param rgb The Rgb object to convert and copy.\n")
          .def("__eq__", &espp::Hsv::operator==, py::arg("rhs"))
          .def("__ne__", &espp::Hsv::operator!=, py::arg("rhs"))
          .def("rgb", &espp::Hsv::rgb,
               "*\n   * @brief Get a RGB representation of this HSV color.\n   * @return An RGB "
               "object containing the RGB representation.\n");
  ////////////////////    </generated_from:color.hpp>    ////////////////////

  // </litgen_pydef> // Autogenerated code end
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
